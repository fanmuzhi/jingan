/* -*- mode: c; tab-width: 4 -*- */
/* $Header$ */

/*
 * Copyright (c) 2008-2015 Synaptics Incorporated.  All rights reserved.
 */

/*
 * moduletest.h -- This file defines the moduletest-patch private
 *  interface for the Falcon part.
 *
 * Bjoren Davis, 26. November, 2008.
 */

/*
 * Note that as of September 1, 2015, this file is controlled
 *  authoritatively in the git repository
 *    ssh://gitms@git.synaptics.com/git/biometrics/include.git.
 * Updates will continue to be copied into the CVSNT repository
 *  in /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4moduletest.h.
 * The last authoritative version of this file in CVSNT was
 *   /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4moduletest.h,v 1.18 2014/09/06 01:50:30 bdavis
 * DO NOT EDIT THIS FILE IN THE CVSNT REPOSITORY.  Your changes will
 *  be overwritten.
 */
#ifndef __MODULETEST_H
#define __MODULETEST_H

#include "vcsPushPack1.h"

/****************************************************************************/
/* VCSFW_CMD_TEST_USB                                                       */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_test_usb_s
{
    vcsUint16_t     delaytime;      /* milliseconds to wait until starting */
    vcsUint16_t     loopcount;      /* how many times to go through the loop
                                     * 0 = loop forever */
    vcsUint16_t     statecount;     /* how many valid states are there? */
    /* followed by statecount states, as defined below */
} vcsfw_cmd_test_usb_t;

typedef struct VCS_PACKED vcsfw_test_usb_state_s
{
    vcsUint16_t     flags;      /* how to set the drivers */
    vcsUint16_t     holdtime;   /* how long to hold them there */
} vcsfw_test_usb_state_t;

#define VCSFW_TEST_USB_STATE_FLAGS_TXEN     0x0001  /* enable xceiver output */
#define VCSFW_TEST_USB_STATE_FLAGS_TXMINUS  0x0002  /* drive DM high */
#define VCSFW_TEST_USB_STATE_FLAGS_TXPLUS   0x0004  /* drive DP high */
#define VCSFW_TEST_USB_STATE_FLAGS_TEST     0x0008  /* enable diag ctrl. */

        
/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_TEST_ROM_CHECKSUM                                              */
/****************************************************************************/
/* COMMAND                                                                  */
/*
 * NOTE: This command structure is OPTIONAL.  If the structure does
 *  not appear then the firmware acts as if it were set to 0
 *  (it does an XOR).
 */
typedef struct VCS_PACKED vcsfw_cmd_test_rom_checksum_s
{
    vcsUint8_t  kind;
} vcsfw_cmd_test_rom_checksum_t;

#define VCSFW_TEST_ROM_CHECKSUM_KIND_XOR        0
#define VCSFW_TEST_ROM_CHECKSUM_KIND_CRC32      1
#define VCSFW_TEST_ROM_CHECKSUM_KIND_SHA256     2
#define VCSFW_TEST_ROM_CHECKSUM_KIND_SHA1       3
#define VCSFW_TEST_ROM_CHECKSUM_KIND_MASK       0x0f
#define VCSFW_TEST_ROM_CHECKSUM_KIND_CHECK      0x80    /* check against
                                                         * compiled-known
                                                         * value */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_rom_checksum_s
{
    vcsUint32_t checksum;
} vcsfw_reply_test_rom_checksum_t;

/*
 * Note: if vcsfw_cmd_test_rom_checksum_t::kind =
 *  = VCSFW_TEST_ROM_CHECKSUM_KIND_SHA256 then the reply is 32 bytes long.
 */

/****************************************************************************/
/* VCSFW_CMD_TEST_OTP_READ                                                  */
/****************************************************************************/

/* How big is the OTP (in bytes): */
#define VCSFW_TEST_OTP_SIZE     128

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_otp_read_s
{
    vcsUint8_t      otp[VCSFW_TEST_OTP_SIZE];
} vcsfw_reply_test_otp_read_t;


/****************************************************************************/
/* VCSFW_CMD_TEST_OTP_WRITE                                                 */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_test_otp_write_s
{
    vcsUint8_t      otp[VCSFW_TEST_OTP_SIZE];
} vcsfw_cmd_test_otp_write_t;

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_TEST_OTP_READ_EX                                               */
/****************************************************************************/

/* Sector and boot are sizes (in bytes) for
** Sidense SiPROM_TSMC130G33_1Kx32_1S2Y2_AC OTPROM chip used in Eagle. */

#define VCSFW_TEST_SIPROM_SECTOR_SIZE    (4 * 512) /* 512 rows = 2048 bytes */
#define VCSFW_TEST_SIPROM_BOOT_AREA_SIZE (4 * 16)  /* 16 rows = 64 bytes    */   

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_test_otp_read_ex_s
{
    vcsUint8_t sector_index;       /* Index of the sensor to read.  */
    vcsUint8_t isboot;             /* Boot part or the main memory? */
} vcsfw_cmd_test_otp_read_ex_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_otp_read_ex_s
{
    vcsUint16_t data_size;            /* Sector size or boot area size.*/
} vcsfw_reply_test_otp_read_ex_t;
/* Followed by 'data_size'-byte data. */


/****************************************************************************/
/* VCSFW_CMD_TEST_OTP_WRITE_EX                                              */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_test_otp_write_ex_s
{
    vcsUint8_t sector_index;       /* Index of the sensor to program. */
    vcsUint8_t isboot;             /* Boot part or the main memory?   */
    vcsUint8_t reprog_num;         /* Maximal number of re-programming 
                                   ** cycles with SOAK pulses if PGM 
                                   ** programming is failed. Default 
                                   ** value is 1 (when reprog_num = 0).
                                   ** The maximal allowed number is 10. */
    vcsUint8_t flags;             /* was dummy1 for data alignment. */
} vcsfw_cmd_test_otp_write_ex_t;

#define VCSFW_CMD_TEST_OTP_WRITE_EX_FLAGS_SOAKBM    0x01    /* send back a
                                                             * bitmap of bits
                                                             * that required
                                                             * soaking. */
/* Followed by data of sector or boot area size depending on 'isboot' flag.  */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_otp_write_ex_s
{
    vcsUint16_t total_pgm_pulses;
    vcsUint16_t total_soak_pulses;
    vcsUint16_t total_failed;
    vcsUint16_t total_programming_time; /* In milliseconds. */
} vcsfw_reply_test_otp_write_ex_t;
/*
 * If the VCSFW_CMD_TEST_OTP_WRITE_EX_FLAGS_SOAKBM flag is set then
 *  this is followed by 64 bytes (for boot rows) or
 *  2048 bytes (for normal sectors) of soak bitmap.
 * If a bit is 1 in this bitmap, then it means that a SOAK
 *  was required to program it.  If the bit is 0, then no SOAK
 *  was needed.
 */

/****************************************************************************/
/* VCSFW_CMD_PROVISION                                                      */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

#define VCSFW_REPLY_TEST_PROVISION_FAIL_NBITS 416
/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_provision_s
{
    vcsUint16_t status;
    vcsUint32_t fail_bits[VCSFW_REPLY_TEST_PROVISION_FAIL_NBITS / 32];
} vcsfw_reply_test_provision_t;

/****************************************************************************/
/* VCSFW_CMD_TEST_AESSHA_EXPO                                               */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* Definitions for "results" bit-field: */
/* Prime P generation. */
#define TEST_PERFORMED_PRIME1GEN            0x00000001
#define TEST_PASSED_PRIME1GEN               0x00000002
/* Prime Q generation. */
#define TEST_PERFORMED_PRIME2GEN            0x00000004
#define TEST_PASSED_PRIME2GEN               0x00000008
/* RSA key generation. */
#define TEST_PERFORMED_RSAKEYGEN            0x00000010
#define TEST_PASSED_RSAKEYGEN               0x00000020
/* RSA signing. */
#define TEST_PERFORMED_RSASIGN              0x00000040
#define TEST_PASSED_RSASIGN                 0x00000080
/* RSA verification. */
#define TEST_PERFORMED_RSAVERIFY            0x00000100
#define TEST_PASSED_RSAVERIFY               0x00000200
/* AES encryption. */
#define TEST_PERFORMED_AESENC               0x00000400
#define TEST_PASSED_AESENC                  0x00000800
/* AES decryption. */
#define TEST_PERFORMED_AESDEC               0x00001000
#define TEST_PASSED_AESDEC                  0x00002000
/* SHA256 calculation. */
#define TEST_PERFORMED_SHA                  0x00004000
#define TEST_PASSED_SHA                     0x00008000
/* SHA1 calculation. */
#define TEST_PERFORMED_SHA1                 0x00010000
#define TEST_PASSED_SHA1                    0x00020000
/* HMAC-SHA1 calculation. */
#define TEST_PERFORMED_HMAC_SHA1            0x00040000
#define TEST_PASSED_HMAC_SHA1               0x00080000
/* HMAC-SHA256 calculation. */
#define TEST_PERFORMED_HMAC_SHA             0x00100000
#define TEST_PASSED_HMAC_SHA                0x00200000
/* AES_ENC-SHA256 calculation. */
#define TEST_PERFORMED_AES_ENC_SHA          0x00400000
#define TEST_PASSED_AES_ENC_SHA             0x00800000
/* AES_DEC-SHA256 calculation. */
#define TEST_PERFORMED_AES_DEC_SHA          0x01000000
#define TEST_PASSED_AES_DEC_SHA             0x02000000
/* AES_ENC-HMAC_SHA256 calculation. */
#define TEST_PERFORMED_AES_ENC_HMAC         0x04000000
#define TEST_PASSED_AES_ENC_HMAC            0x08000000
/* AES_DEC-HMAC_SHA256 calculation. */
#define TEST_PERFORMED_AES_DEC_HMAC         0x10000000
#define TEST_PASSED_AES_DEC_HMAC            0x20000000

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_aessha_expo_s
{
    vcsUint16_t status;
    vcsUint32_t results;     /* Bit-field, containing the test results.     */
                             /* Each bit-pair describes a test result:      */
                             /* First bit indicates if the test is          */
                             /* performed or not (it may not be performed   */
                             /* in consequence of failed previous tests:    */
                             /* e.g. encryption test may be failed because  */
                             /* key generation is failed on previous step). */
                             /* The second bit indicates if the test passed.*/
    vcsUint32_t time[8];     /* Execution time of the tests (in CPU cycles):*/
                             /* time[0] corresponds to prime1 gen. test     */
                             /* time[7] corresponds to SHA test.            */
} vcsfw_reply_test_aessha_expo_t;

/****************************************************************************/
/* VCSFW_CMD_GET_ECC_CORRECTION_INFO                                        */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_ecc_correction_info_s
{
    vcsUint16_t status;
    vcsUint16_t icid_errors;
    vcsUint16_t icid_floppingbits;
} vcsfw_reply_get_ecc_correction_info_t;

/****************************************************************************/
/* VCSFW_CMD_TEST_RESET_OWNERSHIP                                           */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure */

/****************************************************************************/
/* VCSFW_CMD_TEST_GET_SPECIAL_GPIO_STATE                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_cmd_get_special_gpio_state_s
{
    vcsUint32_t gpio_state;
} vcsfw_reply_test_cmd_get_special_gpio_state_t;

/* Bit0 is LOCKN*/
#define VCSFW_GET_SPECIAL_GPIO_STATE__LOCKN(gpio_state) \
    ((gpio_state) & 1)

/* Bit1 is FPR_OFF*/
#define VCSFW_GET_SPECIAL_GPIO_STATE__FPROFF(gpio_state) \
    (((gpio_state) >> 1) & 1)

/* Bits 2-31 are unused. */

/****************************************************************************/
/* VCSFW_CMD_TEST_SET_VCKIV                                                 */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_reply_test_otp_write_ex_t structure */

/****************************************************************************/
/* VCSFW_CMD_TEST_GEN_SSK                                                   */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_reply_test_otp_write_ex_t structure */

/****************************************************************************/
/* VCSFW_CMD_TEST_SET_MT_PASSED                                             */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_reply_test_otp_write_ex_t structure */

/****************************************************************************/
/* VCSFW_CMD_TEST_SPIFLASH_OP                                               */
/****************************************************************************/

/* NOTE: this command must not be implemented in moduletest patch ever. */

/* Flash operations. */
#define VCSFW_TEST_SPIFLASH_OPID_READ         0x01
#define VCSFW_TEST_SPIFLASH_OPID_PROG         0x02
#define VCSFW_TEST_SPIFLASH_OPID_BLCK_ERASE   0x03 /* 64KB block */
#define VCSFW_TEST_SPIFLASH_OPID_BULK_ERASE   0x04
#define VCSFW_TEST_SPIFLASH_OPID_SECTOR_ERASE 0x05

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_test_spiflash_op_s
{
    vcsUint8_t  opid;             /* Operation ID (see definitions above)  */
    vcsUint8_t  unused;
    vcsUint16_t data_size;        /* Read/Prog/erase data size.            */
    vcsUint32_t address;          /* Flash memory address.                 */
} vcsfw_cmd_test_spiflash_op_t;
/* Followed by 'data_size'-byte data. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_test_spiflash_op_s
{
    vcsUint16_t data_size;        /* Returned back data size.               */
} vcsfw_reply_test_spiflash_op_t;
/* Followed by 'data_size'-byte data. */

/****************************************************************************/
/* VCSFW_CMD_TEST_OTPROM_TAG_WRITE                                          */
/****************************************************************************/

/* Command */
typedef struct VCS_PACKED vcsfw_cmd_test_otprom_tag_write_s
{
    vcsUint32_t         flags;
} vcsfw_cmd_test_otprom_tag_write_t;

#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_FLAGS_SIGNED        0x0001
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_FLAGS_FORCE         0x0002

/*
 * Flags:
 *  [SIGNED] This command has a signature at its end.  This may
 *           require empty padding after the data.
 *  [FORCE]  Force the execution of this command.  This means that
 *           the command will overwrite data already present
 *           without checking for blanks first.
 */

typedef struct VCS_PACKED vcsfw_cmd_test_otprom_tag_write_item_s
{
    vcsUint32_t          flags;
    vcsUint32_t          offset;
    vcsUint32_t          extended_tag;
    vcsUint16_t          nbytes;
    vcsUint8_t           tag;           /* tag type */
    vcsUint8_t           maxntags;
    vcsUint8_t           firstidx;
    vcsUint8_t           dummy[3];
} vcsfw_cmd_test_otprom_tag_write_item_t;

/*
 * Note that this command interface is EXACTLY the same as
 *  VCSFW_CMD_OTPROM_TAG_FIND
 */
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS                   \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS_B                 \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_B
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS_N                 \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_N
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS_BOTH              \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_BOTH
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS_ONLYLOW           \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYLOW
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CHAINS_ONLYHIGH          \
    VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYHIGH

#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD      0x000000f0
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_B        4
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_N        4
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_NOOP         0
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_WRITE        1
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_INVALIDATE   2
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_CMD_CHAINLOCK    3

#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_FULLPROG 0x00000100
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE_ITEM_FLAGS_OFFSET   0x00000200

/*
 * Here are the possible commands and options:
 *
 *                  NOOP     WRITE    INVALIDATE    CHAINLOCK
 * nbytes           valid    valid    n/a           n/a
 * firstidx         n/a      n/a      valid         n/a
 * maxntags         n/a      n/a      valid         n/a
 * tag              n/a      valid    valid         n/a
 * extended_tag     n/a      maybe    maybe         n/a
 * CHAINS           n/a      valid    valid         valid 
 * FULLPROG         n/a      n/a      valid         n/a
 * OFFSET           n/a      valid    valid         n/a
 */

/*
 * Note that we round all WRITE/NOOP data up to a multiple of 32-bits.
 */


/* Reply */
typedef struct VCS_PACKED vcsfw_reply_test_otprom_tag_write_s
{
    vcsUint16_t total_pgm_pulses;
    vcsUint16_t total_soak_pulses;
    vcsUint16_t total_failed;
    vcsUint16_t total_programming_time; /* In milliseconds. */
} vcsfw_reply_test_otprom_tag_write_t;



#include "vcsPopPack.h"

#endif      /* __MODULETEST_H */
