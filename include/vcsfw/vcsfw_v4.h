/* -*- mode: c; tab-width: 4 -*- */
/* $Header$ */

/*
 * INTERNAL USE ONLY
 *
 * Copyright (c) 2006-2017 Synaptics Incorporated.  All rights reserved.
 *
 * This file contains information that is proprietary to Synaptics
 * Incorporated ("Synaptics"). The holder of this file shall treat all
 * information contained herein as confidential, shall use the
 * information only for its intended purpose, and shall not duplicate,
 * disclose, or disseminate any of this information in any manner unless
 * Synaptics has otherwise provided express, written permission.
 */

/*
 * vcsfw.h -- This file defines the externally accessible command
 *  mechanism for the Falcon part.
 *
 *
 * Frank Schwab, May 2007
 */

/*
 * Note that as of September 1, 2015, this file is controlled
 *  authoritatively in the git repository
 *    ssh://gitms@git.synaptics.com/git/biometrics/include.git.
 * Updates will continue to be copied into the CVSNT repository
 *  in /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4.h.
 * The last authoritative version of this file in CVSNT was
 *   /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4.h,v 1.541 2015/08/10 15:32:57 bdavis
 * DO NOT EDIT THIS FILE IN THE CVSNT REPOSITORY.  Your changes will
 *  be overwritten.
 */

#ifndef __VCSFW_H
#define __VCSFW_H

#include "vcsPushPack1.h"

/****************************************************************************/
/* Supported Commands:                                                      */
/* These IOCTLS/COMMANDS are used to communicate with the sensor device fw  */
/****************************************************************************/
/*
 * DO NOT EDIT THIS LIST.  You may only add new commands to the end.
 *  Never rename or delete any defined command here.
 *  If a command becomes deprecated, simply note this in a comment,
 *  but leave the command defined.
 */
#define VCSFW_CMD_NOOP                          0
#define VCSFW_CMD_GET_VERSION                   1
#define VCSFW_CMD_GET_PRINT                     2
#define VCSFW_CMD_GET_PRINT_SIGNATURE           3
#define VCSFW_CMD_STOP_PRINT                    4
#define VCSFW_CMD_RESET                         5
#define VCSFW_CMD_PATCH                         6
#define VCSFW_CMD_PEEK                          7
#define VCSFW_CMD_POKE                          8
#define VCSFW_CMD_SET_REFCLK                    9
#define VCSFW_CMD_SET_SPIMODE                   10 /* deprecated */
#define VCSFW_CMD_SPI_TRANSFER                  11
#define VCSFW_CMD_WOE_ENTER                     12
#define VCSFW_CMD_GPIO                          13
#define VCSFW_CMD_PROVISION                     14
#define VCSFW_CMD_TAKE_OWNERSHIP                15
#define VCSFW_CMD_RESET_OWNERSHIP               16
#define VCSFW_CMD_SSL                           17
#define VCSFW_CMD_WOE_SETUP                     18
#define VCSFW_CMD_SET_CPUCLK                    19
#define VCSFW_CMD_RESERVED_1                    20
#define VCSFW_CMD_GET_CONFIGURATION             21
#define VCSFW_CMD_DECOMMISSION                  22
#define VCSFW_CMD_GET_FINGER_STATUS             23
#define VCSFW_CMD_RESERVED_2                    24
#define VCSFW_CMD_GET_STARTINFO                 25
#define VCSFW_CMD_UNLOAD_PATCH                  26
#define VCSFW_CMD_SENSOR_LOCK                   27
#define VCSFW_CMD_MATCH_VERIFY                  28
#define VCSFW_CMD_SIGN_ENC_TEMPLATE_DATA        29
#define VCSFW_CMD_DEC_VERIFY_TEMPLATE_DATA      30
#define VCSFW_CMD_SPISLV_FAST_READ              31
#define VCSFW_CMD_TEST_USB                      32
#define VCSFW_CMD_TEST_ROM_CHECKSUM             33
#define VCSFW_CMD_TEST_OTP_READ                 34
#define VCSFW_CMD_TEST_OTP_WRITE                35
#define VCSFW_CMD_LED                           36
#define VCSFW_CMD_TEST_PROVISION                37
#define VCSFW_CMD_GET_OWNERSHIP_INFO            38
#define VCSFW_CMD_GET_UID                       39
#define VCSFW_CMD_KEY_EXCHANGE_DH               40
#define VCSFW_CMD_GET_CERTIFICATE               41
#define VCSFW_CMD_LED_EX                        42
#define VCSFW_CMD_GET_AUTH_DATA                 43
#define VCSFW_CMD_TAKE_OWNERSHIP_EX             44
#define VCSFW_CMD_REWRITE_PM_SECTOR             45
#define VCSFW_CMD_TEST_AESSHA_EXPO              46
#define VCSFW_CMD_GEN_VCK                       47
#define VCSFW_CMD_GET_ECC_CORRECTION_INFO       48
#define VCSFW_CMD_VIP_CREATE_CLIENT_AUTH_TOKEN  49
#define VCSFW_CMD_VIP_PROVISION_OTP_SEED        50
#define VCSFW_CMD_VIP_CREATE_TOTP_TOKEN         51
#define VCSFW_CMD_TEST_RESET_OWNERSHIP          52
#define VCSFW_CMD_POKE32                        53 /* eagle */
#define VCSFW_CMD_INPLACE_PATCH                 54 /* eagle */
#define VCSFW_CMD_GEN_SEC_KEY                   55
#define VCSFW_CMD_GET_CFGTSBL                   56 /* eagle */
#define VCSFW_CMD_LED_EX2                       57 /* eagle */
#define VCSFW_CMD_SPI_FLASH                     58 /* eagle */
#define VCSFW_CMD_TEST_OTP_READ_EX              59 /* eagle */
#define VCSFW_CMD_TEST_OTP_WRITE_EX             60 /* eagle */
#define VCSFW_CMD_TEST_GET_SPECIAL_GPIO_STATE   61
#define VCSFW_CMD_STORAGE_INFO_GET              62 /* windsor */
#define VCSFW_CMD_STORAGE_PART_FORMAT           63 /* windsor */
#define VCSFW_CMD_STORAGE_PART_READ             64 /* windsor */
#define VCSFW_CMD_STORAGE_PART_WRITE            65 /* windsor */
#define VCSFW_CMD_STORAGE_FWPART_VALIDATE       66 /* windsor */
#define VCSFW_CMD_STORAGE_FWPART_INFO_GET       67 /* windsor */
#define VCSFW_CMD_TLS_HANDSHAKE                 68 /* windsor */
#define VCSFW_CMD_DB_INFO_GET                   69 /* windsor */
#define VCSFW_CMD_DB_OBJECT_INFO_GET            70 /* windsor */
#define VCSFW_CMD_DB_OBJECT_CREATE              71 /* windsor */
#define VCSFW_CMD_DB_OBJECT_DELETE              72 /* windsor */
#define VCSFW_CMD_DB_OBJECT_DATA_GET            73 /* windsor */
#define VCSFW_CMD_DB_USER_INFO_GET              74 /* windsor */
#define VCSFW_CMD_DB_USER_CONTAINER_INFO_GET    75 /* windsor */
#define VCSFW_CMD_DB_OBJECT_RESTORE             76 /* windsor */
#define VCSFW_CMD_DB_SYSTEM_PARAM_GET           77 /* windsor */
#define VCSFW_CMD_DB_SYSTEM_PARAM_SET           78 /* windsor */
#define VCSFW_CMD_TAKE_OWNERSHIP_EX2            79 /* windsor */
#define VCSFW_CMD_GET_CERTIFICATE_EX            80 /* windsor */
#define VCSFW_CMD_READ_FPDATA                   81 /* windsor */
#define VCSFW_CMD_FLUSH_FPDATA                  82 /* windsor */
#define VCSFW_CMD_SSL_FAST_RECOVERY             83
#define VCSFW_CMD_TEST_SET_VCKIV                84 /* eagle */
#define VCSFW_CMD_TEST_GEN_SSK                  85 /* eagle */
#define VCSFW_CMD_TEST_HASH_SHA256              86
#define VCSFW_CMD_TIDLE_SET                     87 /* cosworth */
#define VCSFW_CMD_SLEEP                         88 /* cosworth */
#define VCSFW_CMD_TEST_SET_MT_PASSED            89 /* eagle */
#define VCSFW_CMD_FIDOOP                        90
#define VCSFW_CMD_GET_PATCHINFO                 91
#define VCSFW_CMD_GLOBAL_KEY_GEN                92
#define VCSFW_CMD_GET_NAV_STATUS                93 /* metallica */
#define VCSFW_CMD_AUTH_SESSION_START            94
#define VCSFW_CMD_AUTH_SESSION_STATUS_GET       95
#define VCSFW_CMD_AUTH_SESSION_RESULT_GET       96
#define VCSFW_CMD_AUTH_SESSION_DATA_GET         97
#define VCSFW_CMD_AUTH_SESSION_FINISH           98
#define VCSFW_CMD_CAL_WOF2                      99 /* metallica */
#define VCSFW_CMD_CAL_STATUS_GET                100 /* metallica */
#define VCSFW_CMD_TEST_SPIFLASH_OP              101 /* metallica */
#define VCSFW_CMD_TEST_CLOCKTUNE                102
#define VCSFW_CMD_EVENTSIGCLR                   103
#define VCSFW_CMD_ENROLL_SESSION_START          104 /* metallica */
#define VCSFW_CMD_ENROLL_SESSION_FINISH         105 /* metallica */
#define VCSFW_CMD_ENROLL_SESSION_STATUS_GET     106 /* metallica */
#define VCSFW_CMD_TEMPLATE_UPDATE               107 /* metallica */
#define VCSFW_CMD_CAL_WOF2_V3                   108 /* metallica */
#define VCSFW_CMD_TSCONFIG_SSC_PROGRAM          109 /* metallica */
#define VCSFW_CMD_SECURE_WRAP                   110 /* metallica */
#define VCSFW_CMD_OTPROM_TAG_FIND               111
#define VCSFW_CMD_TEST_OTPROM_TAG_WRITE         112
#define VCSFW_CMD_TEST_OTPROM_TAG_INVALIDATE    113
#define VCSFW_CMD_IFS_STATS_GET                 114
#define VCSFW_CMD_APPLICATION_REQUEST           115
#define VCSFW_CMD_STORAGE_FWPART_INFO_GET_V2    116
#define VCSFW_CMD_CUSTID_GET                    117
#define VCSFW_CMD_WOF2_CONFIGURE                118
#define VCSFW_CMD_WOF2_STATUS_GET               119
#define VCSFW_CMD_READ_RAW_FPDATA               120
#define VCSFW_CMD_RXSELECT                      121 /* viper2 */
#define VCSFW_CMD_TEST_RXSELECT                 VCSFW_CMD_RXSELECT
#define VCSFW_CMD_TEMPERATURE_READ              122
#define VCSFW_CMD_AUTORESTART_STAT_GET          123
#define VCSFW_CMD_ECHO                          124
#define VCSFW_CMD_BOOTLDR_PATCH                 125
#define VCSFW_CMD_GET_NAV_STATUS_V2             126
#define VCSFW_CMD_FRAME_READ                    127
#define VCSFW_CMD_FRAME_ACQ                     128
#define VCSFW_CMD_FRAME_FINISH                  129
#define VCSFW_CMD_FRAME_STATE_GET               130
#define VCSFW_CMD_IOTA_WRITE                    131
#define VCSFW_CMD_FLASH_ERASE                   132
#define VCSFW_CMD_TEST_SPIFLASH_CHECKSUM        133
#define VCSFW_CMD_EVENT_CONFIG                  134
#define VCSFW_CMD_EVENT_READ                    135
#define VCSFW_CMD_FMNO_GET                      136
#define VCSFW_CMD_FDETECT_START                 137
#define VCSFW_CMD_FLASH_READ                    138
#define VCSFW_CMD_FRAME_STREAM                  139
#define VCSFW_CMD_PRNG                          140
#define VCSFW_CMD_TEST_LOOPBACK                 141
#define VCSFW_CMD_IOTA_FIND                     142
#define VCSFW_CMD_FRAME_STATS_GET               143
#define VCSFW_CMD_IOTA_INSINUATE                144
#define VCSFW_CMD_PUBK_GET                      145

/*
 * These following commands are for ATE, characterization and firmware test
 * patches the also get used in the USDK5 for device specific calibration.
 */
#define VCSFW_CMD_TEST_PARAMETER_SET            250
#define VCSFW_CMD_TEST_CONTINUE                 251
#define VCSFW_CMD_TEST_LENGTH_READ              252
#define VCSFW_CMD_TEST_READ                     253
#define VCSFW_CMD_TEST_RUN                      254


/****************************************************************************/
/*  Returned Status values.                                                 */
/****************************************************************************/
/*
 * Note that even though 16 bits are allocated for the command status,
 *  we keep all of our constants within 12 bits.  This is an optimization
 *  for the Tensilica processor.
 */

#define VCSFW_STATUS_OKAY                     0
#define VCSFW_STATUS_CAPTURE_PROGRESS         1
#define VCSFW_STATUS_FINGER_SETTLED           2
#define VCSFW_STATUS_TEST_OTPROM_TAG_WRITE_DIDNOTHING    3
#define VCSFW_STATUS_FINGER_REMOVED           4
#define VCSFW_STATUS_FINGER_ON_SENSOR         5
#define VCSFW_STATUS_FINGER_DETECTED          6
#define VCSFW_STATUS_IMAGE_ACQUISITION_NO_IMAGE         7
#define VCSFW_STATUS_ERR_FLAG                 0x0400
#define VCSFW_STATUS_ERR_INVALID_CMD          (VCSFW_STATUS_ERR_FLAG | 1)
#define VCSFW_STATUS_ERR_BUSY                 (VCSFW_STATUS_ERR_FLAG | 2)
#define VCSFW_STATUS_ERR_INVALID_PARAM        (VCSFW_STATUS_ERR_FLAG | 3)
#define VCSFW_STATUS_ERR_DENIED               (VCSFW_STATUS_ERR_FLAG | 4)
#define VCSFW_STATUS_ERR_CMDTOOSHORT          (VCSFW_STATUS_ERR_FLAG | 5)
#define VCSFW_STATUS_ERR_CMDTOOLONG           (VCSFW_STATUS_ERR_FLAG | 6)
#define VCSFW_STATUS_ERR_PATCH_DATA_BADADDR   (VCSFW_STATUS_ERR_FLAG | 7)
#define VCSFW_STATUS_ERR_PATCH_DATA_NOADDR    (VCSFW_STATUS_ERR_FLAG | 9)
#define VCSFW_STATUS_ERR_PATCH_DATA_SHORTADDR (VCSFW_STATUS_ERR_FLAG | 10)
#define VCSFW_STATUS_ERR_PATCH_DATA_ZEROLEN   (VCSFW_STATUS_ERR_FLAG | 11)
#define VCSFW_STATUS_ERR_PATCH_JMPVEC_NOADDR  (VCSFW_STATUS_ERR_FLAG | 12)
#define VCSFW_STATUS_ERR_PATCH_JMPVEC_SHORTADDR (VCSFW_STATUS_ERR_FLAG | 13)
#define VCSFW_STATUS_ERR_PATCH_JMPVEC_LONGADDR (VCSFW_STATUS_ERR_FLAG | 14)
#define VCSFW_STATUS_ERR_PATCH_JMPVEC_BADADDR (VCSFW_STATUS_ERR_FLAG | 15)
#define VCSFW_STATUS_ERR_PATCH_BADTAG         (VCSFW_STATUS_ERR_FLAG | 16)
#define VCSFW_STATUS_ERR_PATCH_EARLYEND       (VCSFW_STATUS_ERR_FLAG | 17)
#define VCSFW_STATUS_ERR_NOTRUNNING           (VCSFW_STATUS_ERR_FLAG | 18)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_SET32_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 19)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_SET32_TOOLONG                        \
                                                (VCSFW_STATUS_ERR_FLAG | 20)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_SET32_BADOFFSET                      \
                                                (VCSFW_STATUS_ERR_FLAG | 21)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 22)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 23)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32_BADOFFSET                       \
                                                (VCSFW_STATUS_ERR_FLAG | 24)
#define VCSFW_STATUS_ERR_GET_PRINT_TSCONFIG_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 25)
#define VCSFW_STATUS_ERR_GET_PRINT_TSCONFIG_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 26)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 27)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 28)
#define VCSFW_STATUS_ERR_GET_PRINT_WOE_TOOSHORT                             \
                                                (VCSFW_STATUS_ERR_FLAG | 29)
#define VCSFW_STATUS_ERR_GET_PRINT_WOE_TOOLONG                              \
                                                (VCSFW_STATUS_ERR_FLAG | 30)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 31)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_TOOLONG                            \
                                                (VCSFW_STATUS_ERR_FLAG | 32)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_1_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 33)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_1_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 34)
#define VCSFW_STATUS_ERR_GET_PRINT_TAGNOSPACE                               \
                                                (VCSFW_STATUS_ERR_FLAG | 35)
#define VCSFW_STATUS_ERR_GET_PRINT_SWIPE_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 36)
#define VCSFW_STATUS_ERR_GET_PRINT_SWIPE_TOOLONG                            \
                                                (VCSFW_STATUS_ERR_FLAG | 37)
#define VCSFW_STATUS_ERR_SSL_NOTREADY           (VCSFW_STATUS_ERR_FLAG | 38)
#define VCSFW_STATUS_ERR_GET_PRINT_CPUCLK_TOOSHORT                          \
                                                (VCSFW_STATUS_ERR_FLAG | 39)
#define VCSFW_STATUS_ERR_GET_PRINT_CPUCLK_TOOLONG                           \
                                                (VCSFW_STATUS_ERR_FLAG | 40)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_2_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 41)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_2_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 42)
#define VCSFW_STATUS_ERR_NO_SHARED_SECRET       (VCSFW_STATUS_ERR_FLAG | 43)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_NOSPACE                         \
                                                (VCSFW_STATUS_ERR_FLAG | 44)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_NOSUPPORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 45)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_BADKEYSIZE                      \
                                                (VCSFW_STATUS_ERR_FLAG | 46)
#define VCSFW_STATUS_ERR_GET_PRINT_SECURITY_BADMODE                         \
                                                (VCSFW_STATUS_ERR_FLAG | 47)
#define VCSFW_STATUS_ERR_NO_PRINT_SIGNATURE                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 48)
#define VCSFW_STATUS_ERR_NO_MEMORY              (VCSFW_STATUS_ERR_FLAG | 49)
#define VCSFW_STATUS_ERR_GET_PRINT_ZONECFG_TOOSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 50)
#define VCSFW_STATUS_ERR_GET_PRINT_ZONECFG_TOOLONG                          \
                                                (VCSFW_STATUS_ERR_FLAG | 51)
#define VCSFW_STATUS_ERR_GET_PRINT_ZONESPERSWEEP_TOOSHORT                   \
                                                (VCSFW_STATUS_ERR_FLAG | 52)
#define VCSFW_STATUS_ERR_GET_PRINT_ZONESPERSWEEP_TOOLONG                    \
                                                (VCSFW_STATUS_ERR_FLAG | 53)
#define VCSFW_STATUS_ERR_GET_PRINT_LINESPERSWEEPITER_TOOSHORT               \
                                                (VCSFW_STATUS_ERR_FLAG | 54)
#define VCSFW_STATUS_ERR_GET_PRINT_LINESPERSWEEPITER_TOOLONG                \
                                                (VCSFW_STATUS_ERR_FLAG | 55)
#define VCSFW_STATUS_ERR_GET_PRINT_LINESPERSWEEP_TOOSHORT                   \
                                                (VCSFW_STATUS_ERR_FLAG | 56)
#define VCSFW_STATUS_ERR_GET_PRINT_LINESPERSWEEP_TOOLONG                    \
                                                (VCSFW_STATUS_ERR_FLAG | 57)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_BLOCK_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 58)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_BLOCK_TOOLONG                        \
                                                (VCSFW_STATUS_ERR_FLAG | 59)
#define VCSFW_STATUS_ERR_GET_PRINT_TOTALZONES_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 60)
#define VCSFW_STATUS_ERR_GET_PRINT_TOTALZONES_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 61)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOECTRL_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 62)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOECTRL_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 63)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOEMASK_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 64)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOEMASK_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 65)
#define VCSFW_STATUS_ERR_BW_REDUCTION_TOOSHORT  (VCSFW_STATUS_ERR_FLAG | 66)
#define VCSFW_STATUS_ERR_BW_REDUCTION_TOOLONG   (VCSFW_STATUS_ERR_FLAG | 67)
#define VCSFW_STATUS_ERR_GET_PRINT_EARLYEND     (VCSFW_STATUS_ERR_FLAG | 68)
#define VCSFW_STATUS_ERR_GET_PRINT_ZEROLINELEN  (VCSFW_STATUS_ERR_FLAG | 69)
#define VCSFW_STATUS_ERR_GET_PRINT_BADLINELEN   (VCSFW_STATUS_ERR_FLAG | 70)
#define VCSFW_STATUS_ERR_WOE_SETUP_TOOSHORT     (VCSFW_STATUS_ERR_FLAG | 71)
#define VCSFW_STATUS_ERR_WOE_SETUP_TOOLONG      (VCSFW_STATUS_ERR_FLAG | 72)
#define VCSFW_STATUS_ERR_AGC_TOOSHORT           (VCSFW_STATUS_ERR_FLAG | 73)
#define VCSFW_STATUS_ERR_AGC_TOOLONG            (VCSFW_STATUS_ERR_FLAG | 74)
#define VCSFW_STATUS_ERR_AGC_NOT_LOADED         (VCSFW_STATUS_ERR_FLAG | 75)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 76)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 77)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER_RESTRICTED                      \
                                                (VCSFW_STATUS_ERR_FLAG | 78)
#define VCSFW_STATUS_ERR_SIGN_VERIFICATION_FAILED                           \
                                                (VCSFW_STATUS_ERR_FLAG | 79)
#define VCSFW_STATUS_ERR_GET_PRINT_BUSY                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 80)
#define VCSFW_STATUS_ERR_NO_TEMPLATE                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 81)
#define VCSFW_STATUS_ERR_MATCH_FAILED                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 82)
#define VCSFW_STATUS_ERR_PATCH_CHECKSUM         (VCSFW_STATUS_ERR_FLAG | 83)
#define VCSFW_STATUS_ERR_PATCH_CHECKSUM_LEN     (VCSFW_STATUS_ERR_FLAG | 84)
#define VCSFW_STATUS_ERR_PATCH_NO_SIGNATURE     (VCSFW_STATUS_ERR_FLAG | 85)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_LEN     (VCSFW_STATUS_ERR_FLAG | 86)
#define VCSFW_STATUS_ERR_COOKIE_VERIFICATION_FAILED                         \
                                                (VCSFW_STATUS_ERR_FLAG | 87)
#define VCSFW_STATUS_ERR_TEST_OTP_WRITE_TOOSHORT                            \
                                                (VCSFW_STATUS_ERR_FLAG | 88)
#define VCSFW_STATUS_ERR_TEST_OTP_WRITE_TOOLONG                             \
                                                (VCSFW_STATUS_ERR_FLAG | 89)
#define VCSFW_STATUS_ERR_TEST_USB_HDRSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 90)
#define VCSFW_STATUS_ERR_TEST_USB_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 91)
#define VCSFW_STATUS_ERR_TEST_USB_TOOLONG                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 92)
#define VCSFW_STATUS_ERR_TEST_USB_ZEROSTATES                                \
                                                (VCSFW_STATUS_ERR_FLAG | 93)
#define VCSFW_STATUS_ERR_TEST_USB_NO_MEMORY                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 94)
#define VCSFW_STATUS_ERR_TEST_OTP_READ_NO_MEMORY                            \
                                                (VCSFW_STATUS_ERR_FLAG | 95)
#define VCSFW_STATUS_ERR_TEST_OTP_READ_NO_OTP                               \
                                                (VCSFW_STATUS_ERR_FLAG | 96)
#define VCSFW_STATUS_ERR_TEST_OTP_WRITE_NO_MEMORY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 97)
#define VCSFW_STATUS_ERR_TEST_OTP_WRITE_NO_OTP                              \
                                                (VCSFW_STATUS_ERR_FLAG | 98)
#define VCSFW_STATUS_ERR_TEST_PROVISION_NO_OTP                              \
                                                (VCSFW_STATUS_ERR_FLAG | 99)
#define VCSFW_STATUS_ERR_TEST_PROVISION_NO_MEMORY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 100)
#define VCSFW_STATUS_ERR_TEST_PROVISION_ICID_READ_FAILED                    \
                                                (VCSFW_STATUS_ERR_FLAG | 101)
#define VCSFW_STATUS_ERR_OUT_OF_OTP_OWNERSHIP                               \
                                                (VCSFW_STATUS_ERR_FLAG | 102)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_3_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 103)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_3_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 104)
#define VCSFW_STATUS_SENSOR_KEYS_NOT_READY                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 105)
#define VCSFW_STATUS_ERR_SPISFR_NOMEM_HDR                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 106)
#define VCSFW_STATUS_ERR_SPISFR_CMDTOOLONG                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 107)
#define VCSFW_STATUS_ERR_SPISFR_CMDTOOSHORT                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 108)
#define VCSFW_STATUS_ERR_SPISFR_DENIED                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 109)
#define VCSFW_STATUS_ERR_SPISFR_DMA_BUSY                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 110)
#define VCSFW_STATUS_ERR_SPISFR_NOMEM_WRDATA                                \
                                                (VCSFW_STATUS_ERR_FLAG | 111)
#define VCSFW_STATUS_ERR_SPISFR_BUSY                                        \
                                                (VCSFW_STATUS_ERR_FLAG | 112)
#define VCSFW_STATUS_ERR_MATCHVER_HMAC_IS_NOT_LOADED                        \
                                                (VCSFW_STATUS_ERR_FLAG | 113)
#define VCSFW_STATUS_ERR_RSA_OPERATION_FAILED                               \
                                                (VCSFW_STATUS_ERR_FLAG | 114)
#define VCSFW_STATUS_ERR_GET_PRINT_WOVAR_NO_MEM                             \
                                                (VCSFW_STATUS_ERR_FLAG | 115)
#define VCSFW_STATUS_ERR_GET_PRINT_WOVAR_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 116)
#define VCSFW_STATUS_ERR_GET_PRINT_WOVAR_BADBITDEPTH                        \
                                                (VCSFW_STATUS_ERR_FLAG | 117)
#define VCSFW_STATUS_ERR_GET_PRINT_WOVAR_BADFIRSTCHAN                       \
                                                (VCSFW_STATUS_ERR_FLAG | 118)
#define VCSFW_STATUS_ERR_GET_PRINT_WOVAR_BADNCHAN                           \
                                                (VCSFW_STATUS_ERR_FLAG | 119)
#define VCSFW_STATUS_ERR_SPI_TRANSFER_DENIED                                \
                                                (VCSFW_STATUS_ERR_FLAG | 120)
#define VCSFW_STATUS_ERR_NO_AUTH_PATCH                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 121)
#define VCSFW_STATUS_ERR_NOT_VERIFIED                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 122)
#define VCSFW_STATUS_ERR_GET_PRINT_BIT_REDUCTION_TOOSHORT                   \
                                                (VCSFW_STATUS_ERR_FLAG | 123)
#define VCSFW_STATUS_ERR_GET_PRINT_BIT_REDUCTION_TOOLONG                    \
                                                (VCSFW_STATUS_ERR_FLAG | 124)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_4_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 125)
#define VCSFW_STATUS_ERR_GET_PRINT_MOTION_4_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 126)
#define VCSFW_STATUS_ERR_RSA_KEY_GENERATION                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 127)
#define VCSFW_STATUS_ERR_FLASH_OPERATION                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 128)
#define VCSFW_STATUS_ERR_ALGORITHM_MISMATCH                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 129)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOENF_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 130)
#define VCSFW_STATUS_ERR_GET_PRINT_CALWOENF_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 131)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_TOOSHORT                             \
                                                (VCSFW_STATUS_ERR_FLAG | 132)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_TOOLONG                              \
                                                (VCSFW_STATUS_ERR_FLAG | 133)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER32_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 134)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER32_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 135)
#define VCSFW_STATUS_ERR_GET_PRINT_FPBUFFERING_TOOSHORT                     \
                                                (VCSFW_STATUS_ERR_FLAG | 136)
#define VCSFW_STATUS_ERR_GET_PRINT_FPBUFFERING_TOOLONG                      \
                                                (VCSFW_STATUS_ERR_FLAG | 137)
#define VCSFW_STATUS_ERR_INPLACE_PATCH_BADLOADADDR                          \
                                                (VCSFW_STATUS_ERR_FLAG | 138)
#define VCSFW_STATUS_ERR_INPLACE_PATCH_BADSTARTADDR                         \
                                                (VCSFW_STATUS_ERR_FLAG | 139)
#define VCSFW_STATUS_ERR_CMDOVERFLOW                                        \
                                                (VCSFW_STATUS_ERR_FLAG | 140)
#define VCSFW_STATUS_ERR_GET_PRINT_TAGALIGN                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 141)
#define VCSFW_STATUS_ERR_GET_PRINT_TAGHEADER                                \
                                                (VCSFW_STATUS_ERR_FLAG | 142)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32A_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 143)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32A_TOOLONG                        \
                                                (VCSFW_STATUS_ERR_FLAG | 144)
#define VCSFW_STATUS_ERR_UNLOAD_PATCH_NOPATCH                               \
                                                (VCSFW_STATUS_ERR_FLAG | 145)
#define VCSFW_STATUS_ERR_GET_CFGTSBL_NO_MEMORY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 146)
#define VCSFW_STATUS_ERR_GET_CFGTSBL_TOOSHORT                               \
                                                (VCSFW_STATUS_ERR_FLAG | 147)
#define VCSFW_STATUS_ERR_GET_CFGTSBL_TOOLONG                                \
                                                (VCSFW_STATUS_ERR_FLAG | 148)
#define VCSFW_STATUS_ERR_GET_PRINT_CFGTSBL_NO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 149)
#define VCSFW_STATUS_ERR_GET_PRINT_TSCONFIG_NO_MEMORY                       \
                                                (VCSFW_STATUS_ERR_FLAG | 150)
#define VCSFW_STATUS_ERR_GET_PRINT_BASELINE_NO_MEMORY                       \
                                                (VCSFW_STATUS_ERR_FLAG | 151)
#define VCSFW_STATUS_ERR_GET_PRINT_STREAMLENX64                             \
                                                (VCSFW_STATUS_ERR_FLAG | 152)
#define VCSFW_STATUS_ERR_SO_ALT_TOOSHORT                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 153)
#define VCSFW_STATUS_ERR_SO_ALT_TOOLONG                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 154)
#define VCSFW_STATUS_ERR_GET_PRINT_SAMPLE_POKES_NO_MEMORY                   \
                                                (VCSFW_STATUS_ERR_FLAG | 155)
#define VCSFW_STATUS_ERR_GET_PRINT_SCAN_POKES_NO_MEMORY                     \
                                                (VCSFW_STATUS_ERR_FLAG | 156)
#define VCSFW_STATUS_ERR_FDETECT_TOOSHORT                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 157)
#define VCSFW_STATUS_ERR_FDETECT_TOOLONG                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 158)
#define VCSFW_STATUS_ERR_TSTBLOFF_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 159)
#define VCSFW_STATUS_ERR_TSTBLOFF_TOOLONG                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 160)
#define VCSFW_STATUS_ERR_GET_PRINT_FPBUFFRING_NO_MEMORY                     \
                                                (VCSFW_STATUS_ERR_FLAG | 161)
#define VCSFW_STATUS_ERR_GET_PRINT_FPBUFFRING_BADPARAM                      \
                                                (VCSFW_STATUS_ERR_FLAG | 162)
#define VCSFW_STATUS_ERR_SPI_FLASH_BUSY                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 163)
#define VCSFW_STATUS_ERR_SPI_FLASH_BADPARAM                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 164)
#define VCSFW_STATUS_ERR_SPI_FLASH_PAYLOAD_TOOLONG                          \
                                                (VCSFW_STATUS_ERR_FLAG | 165)
#define VCSFW_STATUS_ERR_SPI_FLASH_NO_MEMORY                                \
                                                (VCSFW_STATUS_ERR_FLAG | 166)
#define VCSFW_STATUS_ERR_GPIO_IN_USE                                        \
                                                (VCSFW_STATUS_ERR_FLAG | 167)
#define VCSFW_STATUS_ERR_SPI_FLASH_READ_LENGTH_TOOLONG                      \
                                                (VCSFW_STATUS_ERR_FLAG | 168)
#define VCSFW_STATUS_ERR_GET_PRINT_EP2_NOT_CLEARED                          \
                                                (VCSFW_STATUS_ERR_FLAG | 169)
#define VCSFW_STATUS_ERR_PATCH_HOOK_CONFLICT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 170)
#define VCSFW_STATUS_ERR_PATCH_HOOK_OUTOFRANGE                              \
                                                (VCSFW_STATUS_ERR_FLAG | 171)
#define VCSFW_STATUS_ERR_PATCH_HOOK_NOENTRY                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 172)
#define VCSFW_STATUS_ERR_OTPROM_PROG_FAILED                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 173)
#define VCSFW_STATUS_ERR_NO_PARTENTRY                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 174)
#define VCSFW_STATUS_ERR_INVALID_PARTTBL                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 175)
#define VCSFW_STATUS_ERR_NO_FWEXTENSION                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 176)
#define VCSFW_STATUS_ERR_TLS_NOTREADY                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 177)
#define VCSFW_STATUS_ERR_NO_DBSTORAGE                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 178)
#define VCSFW_STATUS_ERR_NO_DBOBJECT                                        \
                                                (VCSFW_STATUS_ERR_FLAG | 179)
#define VCSFW_STATUS_ERR_DBSTORAGE_INVALID                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 180)
#define VCSFW_STATUS_ERR_DBSTORAGE_FULL                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 181)
#define VCSFW_STATUS_ERR_DBSTORAGE_DENIED                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 182)
#define VCSFW_STATUS_ERR_INVALID_DBOBJECT                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 183)
#define VCSFW_STATUS_ERR_ACMPARAM_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 184)
#define VCSFW_STATUS_ERR_ACMPARAM_TOOLONG                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 185)
#define VCSFW_STATUS_ERR_CEMPARAM_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 186)
#define VCSFW_STATUS_ERR_CEMPARAM_TOOLONG                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 187)
#define VCSFW_STATUS_ERR_GET_PRINT_TSCONFIG_TOOMANY                         \
                                                (VCSFW_STATUS_ERR_FLAG | 188)
#define VCSFW_STATUS_ERR_GET_PRINT_BASELINE_TOOMANY                         \
                                                (VCSFW_STATUS_ERR_FLAG | 189)
#define VCSFW_STATUS_ERR_PK_ENCDEC                                          \
                                                (VCSFW_STATUS_ERR_FLAG | 190)
#define VCSFW_STATUS_ERR_SYMK_ENCDEC                                        \
                                                (VCSFW_STATUS_ERR_FLAG | 191)
#define VCSFW_STATUS_ERR_HASH_CALCULATION                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 192)
#define VCSFW_STATUS_ERR_ICID_CORRECTION                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 193)
#define VCSFW_STATUS_ERR_MISSING_DATA                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 194)
#define VCSFW_STATUS_ERR_DBOBJECT_EXIST                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 195)
#define VCSFW_STATUS_ERR_IRPARAM_TOOSHORT                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 196)
#define VCSFW_STATUS_ERR_IRPARAM_TOOLONG                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 197)
#define VCSFW_STATUS_ERR_TSTBLOFF_INVALID                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 198)
#define VCSFW_STATUS_ERR_GET_PRINT_2D_TOOSHORT                              \
                                                (VCSFW_STATUS_ERR_FLAG | 199)
#define VCSFW_STATUS_ERR_GET_PRINT_2D_TOOLONG                               \
                                                (VCSFW_STATUS_ERR_FLAG | 200)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_HDRSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 201)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_GROUPSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 202)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_ARRAYSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 203)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TSRANGE                          \
                                                (VCSFW_STATUS_ERR_FLAG | 204)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TOOLONG                          \
                                                (VCSFW_STATUS_ERR_FLAG | 205)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_NO2D                             \
                                                (VCSFW_STATUS_ERR_FLAG | 206)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_NOTSCONFIG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 207)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_NO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 208)
#define VCSFW_STATUS_ERR_GET_PRINT_TSFDETECT_NO_MEMORY                      \
                                                (VCSFW_STATUS_ERR_FLAG | 209)
#define VCSFW_STATUS_ERR_GET_PRINT_HWREG_LIST_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 210)
#define VCSFW_STATUS_ERR_GET_PRINT_HWREG_LIST_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 211)
#define VCSFW_STATUS_ERR_KEY_GENERATION_FAILED                              \
                                                (VCSFW_STATUS_ERR_FLAG | 212)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_MULTIPLE                           \
                                                (VCSFW_STATUS_ERR_FLAG | 213)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_INTERNAL                           \
                                                (VCSFW_STATUS_ERR_FLAG | 214)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_NOTBLKMULT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 215)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_NO_MEMORY                         \
                                                (VCSFW_STATUS_ERR_FLAG | 216)
#define VCSFW_STATUS_ERR_PATCH_SIGNATURE_NOTFIRST                           \
                                                (VCSFW_STATUS_ERR_FLAG | 217)
#define VCSFW_STATUS_ERR_PATCH_BABBLE                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 218)
#define VCSFW_STATUS_ERR_PATCH_NO_JMPVEC                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 219)
#define VCSFW_STATUS_ERR_GET_PRINT_IMAGE_RECON_NO_MEMORY                    \
                                                (VCSFW_STATUS_ERR_FLAG | 220)
#define VCSFW_STATUS_ERR_GET_PRINT_IMAGE_RECON_TYPE_INVALID                 \
                                                (VCSFW_STATUS_ERR_FLAG | 221)
#define VCSFW_STATUS_ERR_GET_PRINT_IMAGE_RECON_INIT_FAIL                    \
                                                (VCSFW_STATUS_ERR_FLAG | 222)
#define VCSFW_STATUS_ERR_PATCH_RELOC_HDR_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 223)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP24_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 224)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP32_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 225)
#define VCSFW_STATUS_ERR_PATCH_RELOC_LINKADDR_OUTOFBOUNDS                   \
                                                (VCSFW_STATUS_ERR_FLAG | 226)
#define VCSFW_STATUS_ERR_PATCH_RELOC_ENTRYADDR_OUTOFBOUNDS                  \
                                                (VCSFW_STATUS_ERR_FLAG | 227)
#define VCSFW_STATUS_ERR_PATCH_RELOC_ENTRYADDR_UNALIGNED                    \
                                                (VCSFW_STATUS_ERR_FLAG | 228)
#define VCSFW_STATUS_ERR_PATCH_RELOC_NO_MEMORY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 229)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP24_NOTINPATCH                     \
                                                (VCSFW_STATUS_ERR_FLAG | 230)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP24_OUTOFRANGE                     \
                                                (VCSFW_STATUS_ERR_FLAG | 231)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP24_BADINSN                        \
                                                (VCSFW_STATUS_ERR_FLAG | 232)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP32_NOTINPATCH                     \
                                                (VCSFW_STATUS_ERR_FLAG | 233)
#define VCSFW_STATUS_ERR_PATCH_RELOC_FIXUP32_OUTOFRANGE                     \
                                                (VCSFW_STATUS_ERR_FLAG | 234)
#define VCSFW_STATUS_ERR_GET_PATCHINFO_NO_MEMORY                            \
                                                (VCSFW_STATUS_ERR_FLAG | 235)
#define VCSFW_STATUS_ERR_UNLOAD_PATCH_BADID                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 236)
#define VCSFW_STATUS_ERR_UNLOAD_PATCH_NOT_UNLOADABLE                        \
                                                (VCSFW_STATUS_ERR_FLAG | 237)
#define VCSFW_STATUS_ERR_UNLOAD_PATCH_SOME_NOT_UNLOADABLE                   \
                                                (VCSFW_STATUS_ERR_FLAG | 238)
#define VCSFW_STATUS_ERR_STORAGE_FWPART_VALIDATE_FWEXT_BADSIG               \
                                                (VCSFW_STATUS_ERR_FLAG | 239)
#define VCSFW_STATUS_ERR_STORAGE_FWPART_VALIDATE_FWEXT_BADROMID             \
                                                (VCSFW_STATUS_ERR_FLAG | 240)
#define VCSFW_STATUS_ERR_NAVPARAM_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 241)
#define VCSFW_STATUS_ERR_PATCH_HOOK_GENERALFAIL                             \
                                                (VCSFW_STATUS_ERR_FLAG | 242)
#define VCSFW_STATUS_ERR_FWEXT_MODULE_NOT_FOUND                             \
                                                (VCSFW_STATUS_ERR_FLAG | 243)
#define VCSFW_STATUS_ERR_FWEXT_MODULE_LOAD_FAILED                           \
                                                (VCSFW_STATUS_ERR_FLAG | 244)
#define VCSFW_STATUS_ERR_FWEXT_MODULE_NOT_LOADED                            \
                                                (VCSFW_STATUS_ERR_FLAG | 245)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF2_NO_SO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 246)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF2_NO_PARAM_MEMORY                     \
                                                (VCSFW_STATUS_ERR_FLAG | 247)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF2_TOOSHORT                            \
                                                (VCSFW_STATUS_ERR_FLAG | 248)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF2_SO_TOOSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 249)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF_TOOSHORT                             \
                                                (VCSFW_STATUS_ERR_FLAG | 250)
#define VCSFW_STATUS_ERR_GET_PRINT_WOF_TOOLONG                              \
                                                (VCSFW_STATUS_ERR_FLAG | 251)
#define VCSFW_STATUS_ERR_AUTH_SESSION_RUNNING                               \
                                                (VCSFW_STATUS_ERR_FLAG | 252)
#define VCSFW_STATUS_ERR_MATCH_RESULT_NOTREADY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 253)
#define VCSFW_STATUS_ERR_NAV_DATA_INVALID                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 254)
#define VCSFW_STATUS_ERR_AUTH_DATA_INVALID                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 255)
#define VCSFW_STATUS_ERR_SESSION_TIMEOUT                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 256)
#define VCSFW_STATUS_ERR_MATCHER_INIT_FAIL                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 257)
#define VCSFW_STATUS_ERR_MATCHER_NULL_CONTEXT                               \
                                                (VCSFW_STATUS_ERR_FLAG | 258)
#define VCSFW_STATUS_ERR_MATCHER_NULL_TPL                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 259)
#define VCSFW_STATUS_ERR_MATCHER_TPL_IMPORT                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 260)
#define VCSFW_STATUS_ERR_MATCHER_FTR_EXTRACT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 261)
#define VCSFW_STATUS_ERR_MATCHER_NULL_TPL_HANDLE                            \
                                                (VCSFW_STATUS_ERR_FLAG | 262)
#define VCSFW_STATUS_ERR_MATCHER_NULL_FTR_HANDLE                            \
                                                (VCSFW_STATUS_ERR_FLAG | 263)
#define VCSFW_STATUS_ERR_MATCHER_VERIFY_FAIL                                \
                                                (VCSFW_STATUS_ERR_FLAG | 264)
#define VCSFW_STATUS_ERR_MATCHER_IDENTIFY_FAIL                              \
                                                (VCSFW_STATUS_ERR_FLAG | 265)
#define VCSFW_STATUS_ERR_MATCHER_IS_NOT_LOADED                              \
                                                (VCSFW_STATUS_ERR_FLAG | 266)
#define VCSFW_STATUS_ERR_IMAGE_LOADING_FAILED                               \
                                                (VCSFW_STATUS_ERR_FLAG | 267)
#define VCSFW_STATUS_ERR_TIDLE_SET_OUTOFRANGE                               \
                                                (VCSFW_STATUS_ERR_FLAG | 268)
#define VCSFW_STATUS_ERR_CAL_WOF2_TOOSHORT                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 269)
#define VCSFW_STATUS_ERR_CAL_WOF2_SO_TOOSHORT                               \
                                                (VCSFW_STATUS_ERR_FLAG | 270)
#define VCSFW_STATUS_ERR_CAL_WOF2_NO_SO_MEMORY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 271)
#define VCSFW_STATUS_ERR_CAL_WOF2_NO_PARAM_MEMORY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 272)
#define VCSFW_STATUS_ERR_CAL_WOF2_NO_MEMORY                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 273)
#define VCSFW_STATUS_ERR_CAL_WOF2_ILLEGAL_PARAMETER                         \
                                                (VCSFW_STATUS_ERR_FLAG | 274)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_WOF2_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 275)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_WOF2_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 276)
#define VCSFW_STATUS_ERR_GET_PRINT_NO_WOE_MEMORY                            \
                                                (VCSFW_STATUS_ERR_FLAG | 277)
#define VCSFW_STATUS_ERR_GET_PRINT_TOOMANY_LINES                            \
                                                (VCSFW_STATUS_ERR_FLAG | 278)
#define VCSFW_STATUS_ERR_GET_PRINT_REGISTER32_RESTRICTED                    \
                                                (VCSFW_STATUS_ERR_FLAG | 279)
#define VCSFW_STATUS_ERR_GET_PRINT_REG_OP32A_RESTRICTED                     \
                                                (VCSFW_STATUS_ERR_FLAG | 280)
#define VCSFW_STATUS_ERR_GET_PRINT_HWREG16_RESTRICTED                       \
                                                (VCSFW_STATUS_ERR_FLAG | 281)
#define VCSFW_STATUS_ERR_GET_PRINT_HWREG32_RESTRICTED                       \
                                                (VCSFW_STATUS_ERR_FLAG | 282)
#define VCSFW_STATUS_ERR_GET_PRINT_EVENTSIG_BADEVENTMASK                    \
                                                (VCSFW_STATUS_ERR_FLAG | 283)
#define VCSFW_STATUS_ERR_GET_PRINT_EVENTSIG_BADGPIONUM                      \
                                                (VCSFW_STATUS_ERR_FLAG | 284)
#define VCSFW_STATUS_ERR_GET_PRINT_EVENTSIG_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 285)
#define VCSFW_STATUS_ERR_GET_PRINT_EVENTSIG_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 286)
#define VCSFW_STATUS_ERR_GET_PRINT_EVENTSIG_ZEROEVENTMASK                   \
                                                (VCSFW_STATUS_ERR_FLAG | 287)
#define VCSFW_STATUS_ERR_EVENTSIGCLR_NOTCONFIG                              \
                                                (VCSFW_STATUS_ERR_FLAG | 288)
#define VCSFW_STATUS_ERR_GET_PRINT_IFSIMAGER_FRAMESTATS_TOOSHORT            \
                                                (VCSFW_STATUS_ERR_FLAG | 289)
#define VCSFW_STATUS_ERR_GET_PRINT_IFSIMAGER_FRAMESTATS_TOOLONG             \
                                                (VCSFW_STATUS_ERR_FLAG | 290)
#define VCSFW_STATUS_ERR_GET_PRINT_IMAGE_RECON_NOTREADY                     \
                                                (VCSFW_STATUS_ERR_FLAG | 291)
#define VCSFW_STATUS_ERR_MATCHER_TEMPLATE_CREATION_FAILED                   \
                                                (VCSFW_STATUS_ERR_FLAG | 292)
#define VCSFW_STATUS_ERR_MATCHER_TEMPLATE_NOTREADY                          \
                                                (VCSFW_STATUS_ERR_FLAG | 294)
#define VCSFW_STATUS_ERR_MATCHER_TEMPLATE_UPDATE_BUSY                       \
                                                (VCSFW_STATUS_ERR_FLAG | 295)
#define VCSFW_STATUS_ERR_RESET_PENDING                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 296)
#define VCSFW_STATUS_ERR_BAD_TEMPLATE                                       \
                                                (VCSFW_STATUS_ERR_FLAG | 297)
#define VCSFW_STATUS_ERR_GET_PRINT_SNRMETHOD4_NO_MEMORY                     \
                                                (VCSFW_STATUS_ERR_FLAG | 298)
#define VCSFW_STATUS_ERR_CAL_WOF2_INVALID_ZONE                              \
                                                (VCSFW_STATUS_ERR_FLAG | 299)
#define VCSFW_STATUS_ERR_FDETECT_RATCHET_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 300)
#define VCSFW_STATUS_ERR_FDETECT_RATCHET_TOOLONG                            \
                                                (VCSFW_STATUS_ERR_FLAG | 301)
#define VCSFW_STATUS_ERR_CONFIG_NOT_FOUND                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 302)
#define VCSFW_STATUS_ERR_CONFIG_INVALID                                     \
                                                (VCSFW_STATUS_ERR_FLAG | 303)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TRANSFORM_TOOSHORT               \
                                                (VCSFW_STATUS_ERR_FLAG | 304)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_INTERLEAVE_TOOSHORT              \
                                                (VCSFW_STATUS_ERR_FLAG | 305)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_INTERLEAVE_TOOLONG               \
                                                (VCSFW_STATUS_ERR_FLAG | 306)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TRANSFORM_NO2D                   \
                                                (VCSFW_STATUS_ERR_FLAG | 307)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TRANSFORM_EARLYEND               \
                                                (VCSFW_STATUS_ERR_FLAG | 308)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TRANSFORM_NO_MEMORY              \
                                                (VCSFW_STATUS_ERR_FLAG | 309)
#define VCSFW_STATUS_ERR_GET_PRINT_LINEUPD_TRANSFORM_TOOMANY                \
                                                (VCSFW_STATUS_ERR_FLAG | 310)
#define VCSFW_STATUS_ERR_NO_IMAGE_CAPTURED                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 311)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_TOOSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 312)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_TOOSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 313)
#define VCSFW_STATUS_ERR_TSCONFIG_ENDS_EARLY                                \
                                                (VCSFW_STATUS_ERR_FLAG | 314)
#define VCSFW_STATUS_ERR_TSCONFIG_NO_TSMACRO                                \
                                                (VCSFW_STATUS_ERR_FLAG | 315)
#define VCSFW_STATUS_ERR_TSCONFIG_UNDEFINED_MACRO                           \
                                                (VCSFW_STATUS_ERR_FLAG | 316)
#define VCSFW_STATUS_ERR_TSCONFIG_MACRO_ENDS_EARLY                          \
                                                (VCSFW_STATUS_ERR_FLAG | 317)
#define VCSFW_STATUS_ERR_TSCONFIG_NO_SOTABLE                                \
                                                (VCSFW_STATUS_ERR_FLAG | 318)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_NO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 319)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_NO_OTPROM_OFFSET                 \
                                                (VCSFW_STATUS_ERR_FLAG | 320)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_TOOLONG                          \
                                                (VCSFW_STATUS_ERR_FLAG | 321)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_OTPROM_OFFSET_TOOBIG             \
                                                (VCSFW_STATUS_ERR_FLAG | 322)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_OTPROM_OFFSET_TOOLONG            \
                                                (VCSFW_STATUS_ERR_FLAG | 323)
#define VCSFW_STATUS_ERR_GET_PRINT_SOTABLE_DATA_TOOSHORT                    \
                                                (VCSFW_STATUS_ERR_FLAG | 324)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_NO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 325)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_TOOMANY                          \
                                                (VCSFW_STATUS_ERR_FLAG | 326)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_MISSING_HEADER                   \
                                                (VCSFW_STATUS_ERR_FLAG | 327)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_SHORT_DATA                       \
                                                (VCSFW_STATUS_ERR_FLAG | 328)
#define VCSFW_STATUS_ERR_GET_PRINT_TSMACRO_TOOLONG                          \
                                                (VCSFW_STATUS_ERR_FLAG | 329)
#define VCSFW_STATUS_ERR_ENROLL_INIT_FAILED                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 330)
#define VCSFW_STATUS_ERR_ENROLL_FAILED                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 331)
#define VCSFW_STATUS_ERR_MATCHER_TPL_EXPORT                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 332)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_NOSIGNSUPPORT                \
                                                (VCSFW_STATUS_ERR_FLAG | 333)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_NOITEMS                      \
                                                (VCSFW_STATUS_ERR_FLAG | 334)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_BABBLE                       \
                                                (VCSFW_STATUS_ERR_FLAG | 335)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_EARLYEND                \
                                                (VCSFW_STATUS_ERR_FLAG | 336)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NEEDCHAIN         \
                                                (VCSFW_STATUS_ERR_FLAG | 337)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_CHAINLOCKED       \
                                                (VCSFW_STATUS_ERR_FLAG | 338)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_BADTAG            \
                                                (VCSFW_STATUS_ERR_FLAG | 339)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_UNALIGNED         \
                                                (VCSFW_STATUS_ERR_FLAG | 340)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_OFFCHAIN          \
                                                (VCSFW_STATUS_ERR_FLAG | 341)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NOLOWSPACE        \
                                                (VCSFW_STATUS_ERR_FLAG | 342)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NOHIGHSPACE       \
                                                (VCSFW_STATUS_ERR_FLAG | 343)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_INVALIDATE_NOTFOUND     \
                                                (VCSFW_STATUS_ERR_FLAG | 344)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_CHAINLOCK_NEEDCHAIN     \
                                                (VCSFW_STATUS_ERR_FLAG | 345)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_CHAINLOCK_CHAINLOCKED   \
                                                (VCSFW_STATUS_ERR_FLAG | 346)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_CMDUNKNOWN              \
                                                (VCSFW_STATUS_ERR_FLAG | 347)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_UNPROG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 348)
#define VCSFW_STATUS_ERR_CUSTID_GET_NOTSET                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 349)
#define VCSFW_STATUS_ERR_CUSTID_GET_WRONGSIZE                               \
                                                (VCSFW_STATUS_ERR_FLAG | 350)
#define VCSFW_STATUS_ERR_ASP_LIB_FAILURE                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 351)
#define VCSFW_STATUS_ERR_TEST_OTPROM_TAG_WRITE_ITEM_INVALIDATE_BADTAG       \
                                                (VCSFW_STATUS_ERR_FLAG | 352)
#define VCSFW_STATUS_ERR_GET_PRINT_FDETECT_SAMPLE_REGS_RESTRICTED           \
                                                (VCSFW_STATUS_ERR_FLAG | 353)
#define VCSFW_STATUS_ERR_GET_PRINT_FDETECT_SCAN_REGS_RESTRICTED             \
                                                (VCSFW_STATUS_ERR_FLAG | 354)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_TWOREGS_RESTRICTED                 \
                                                (VCSFW_STATUS_ERR_FLAG | 355)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_TWORANGES_RESTRICTED               \
                                                (VCSFW_STATUS_ERR_FLAG | 356)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_LIST_NUMREGS                       \
                                                (VCSFW_STATUS_ERR_FLAG | 357)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_LIST_SIZE                          \
                                                (VCSFW_STATUS_ERR_FLAG | 358)
#define VCSFW_STATUS_ERR_GET_PRINT_SWEEP_LIST_RESTRICTED                    \
                                                (VCSFW_STATUS_ERR_FLAG | 359)
#define VCSFW_STATUS_ERR_IMAGE_PARAM_NOT_AVAILABLE                          \
                                                (VCSFW_STATUS_ERR_FLAG | 360)
#define VCSFW_STATUS_ERR_IMAGE_PARAM_ASP_INFO_SIZE_NOT_ENOUGH               \
                                                (VCSFW_STATUS_ERR_FLAG | 361)
#define VCSFW_STATUS_ERR_IMAGE_PARAM_ASP_INFO_NOT_READABLE                  \
                                                (VCSFW_STATUS_ERR_FLAG | 362)
#define VCSFW_STATUS_ERR_SPI_FLASH_BAD_MODHEADER                            \
                                                (VCSFW_STATUS_ERR_FLAG | 363)
#define VCSFW_STATUS_ERR_TEST_ROM_CHECKSUM_NOREFERENCE                      \
                                                (VCSFW_STATUS_ERR_FLAG | 364)
#define VCSFW_STATUS_ERR_TEST_ROM_CHECKSUM_BADCOMPARE                       \
                                                (VCSFW_STATUS_ERR_FLAG | 365)
#define VCSFW_STATUS_ERR_NOT_SUPPORTED                                      \
                                                (VCSFW_STATUS_ERR_FLAG | 366)
#define VCSFW_STATUS_ERR_GET_PRINT_BASELINE_FRAME_TOOSHORT                  \
                                                (VCSFW_STATUS_ERR_FLAG | 367)
#define VCSFW_STATUS_ERR_GET_PRINT_RXSELECT_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 368)
#define VCSFW_STATUS_ERR_GET_PRINT_RXSELECT_SHORTDATA                       \
                                                (VCSFW_STATUS_ERR_FLAG | 369)
#define VCSFW_STATUS_ERR_GET_PRINT_RXSELECT_TOOMANYBITS                     \
                                                (VCSFW_STATUS_ERR_FLAG | 370)
#define VCSFW_STATUS_ERR_GET_PRINT_DATA_ENCODER_TOOSHORT                    \
                                                (VCSFW_STATUS_ERR_FLAG | 371)
#define VCSFW_STATUS_ERR_GET_PRINT_DATA_ENCODER_TOOLONG                     \
                                                (VCSFW_STATUS_ERR_FLAG | 372)
#define VCSFW_STATUS_ERR_GET_PRINT_RXSELECT_BABBLE                          \
                                                (VCSFW_STATUS_ERR_FLAG | 373)
#define VCSFW_STATUS_ERR_GET_PRINT_RXSELECT_FIRSTRXTOOHIGH                  \
                                                (VCSFW_STATUS_ERR_FLAG | 374)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_NO_SO_MEMORY                        \
                                                (VCSFW_STATUS_ERR_FLAG | 375)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_CFG_SIZE_NOTMIN                     \
                                                (VCSFW_STATUS_ERR_FLAG | 376)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_TOOSHORT                            \
                                                (VCSFW_STATUS_ERR_FLAG | 377)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_SO_TOOSHORT                         \
                                                (VCSFW_STATUS_ERR_FLAG | 378)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_BADMODE                             \
                                                (VCSFW_STATUS_ERR_FLAG | 379)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_BUSY                                \
                                                (VCSFW_STATUS_ERR_FLAG | 380)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_NO_MEMORY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 381)
#define VCSFW_STATUS_ERR_WOF2_STATUS_GET_NOTRUNNING                         \
                                                (VCSFW_STATUS_ERR_FLAG | 382)
#define VCSFW_STATUS_ERR_GET_PRINT_OPMODE_BUSY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 383)
#define VCSFW_STATUS_ERR_WOF2_CONFIGURE_OPMODE_BUSY                         \
                                                (VCSFW_STATUS_ERR_FLAG | 384)
#define VCSFW_STATUS_ERR_CAL_WOF2_CFG_SIZE_NOTMIN                           \
                                                (VCSFW_STATUS_ERR_FLAG | 385)
#define VCSFW_STATUS_ERR_TEMPERATURE_READ_FAILED                            \
                                                (VCSFW_STATUS_ERR_FLAG | 386)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_TOO_SHORT                \
                                                (VCSFW_STATUS_ERR_FLAG | 387)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_TOO_LONG                 \
                                                (VCSFW_STATUS_ERR_FLAG | 388)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_NO_MEMORY                \
                                                (VCSFW_STATUS_ERR_FLAG | 389)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_NO_OTPROM_ENTRY          \
                                                (VCSFW_STATUS_ERR_FLAG | 390)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_INVALID_OTPROM_ENTRY     \
                                                (VCSFW_STATUS_ERR_FLAG | 391)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_BAD_PARAM                \
                                                (VCSFW_STATUS_ERR_FLAG | 392)
#define VCSFW_STATUS_ERR_GET_PRINT_TEMPERATURE_CAL_PRINT_CANCELED           \
                                                (VCSFW_STATUS_ERR_FLAG | 393)
#define VCSFW_STATUS_ERR_GET_PRINT_FRAMESTATS_NOTRUNNING                    \
                                                (VCSFW_STATUS_ERR_FLAG | 394)
#define VCSFW_STATUS_ERR_GET_PRINT_FRAMESTATS_BADMETHOD                     \
                                                (VCSFW_STATUS_ERR_FLAG | 395)
#define VCSFW_STATUS_ERR_GET_PRINT_ACM_CONFIG_TOOSHORT                      \
                                                (VCSFW_STATUS_ERR_FLAG | 396)
#define VCSFW_STATUS_ERR_GET_PRINT_ACM_CONFIG_TOOLONG                       \
                                                (VCSFW_STATUS_ERR_FLAG | 397)
#define VCSFW_STATUS_ERR_GET_PRINT_ACM_CONTROL_TOOSHORT                     \
                                                (VCSFW_STATUS_ERR_FLAG | 398)
#define VCSFW_STATUS_ERR_GET_PRINT_ACM_CONTROL_TOOLONG                      \
                                                (VCSFW_STATUS_ERR_FLAG | 399)
#define VCSFW_STATUS_ERR_STORAGE_PART_FORMAT_BUSY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 400)
#define VCSFW_STATUS_ERR_STORAGE_PART_WRITE_BUSY                            \
                                                (VCSFW_STATUS_ERR_FLAG | 401)
#define VCSFW_STATUS_ERR_READ_FPDATA_ATIDLE                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 402)
#define VCSFW_STATUS_ERR_READ_FPDATA_BADMETHOD                              \
                                                (VCSFW_STATUS_ERR_FLAG | 403)
#define VCSFW_STATUS_ERR_READ_FPDATA_NOTRUNNING                             \
                                                (VCSFW_STATUS_ERR_FLAG | 404)
#define VCSFW_STATUS_ERR_FLUSH_FPDATA_BUSY                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 405)
#define VCSFW_STATUS_ERR_GET_ANSIDATA_ATIDLE                                \
                                                (VCSFW_STATUS_ERR_FLAG | 406)
#define VCSFW_STATUS_ERR_GET_ANSIDATA_BUSY                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 407)
#define VCSFW_STATUS_ERR_GET_ANSIDATA_NO_MEMORY                             \
                                                (VCSFW_STATUS_ERR_FLAG | 408)
#define VCSFW_STATUS_ERR_GET_ANSIDATA_NOTRUNNING                            \
                                                (VCSFW_STATUS_ERR_FLAG | 409)
#define VCSFW_STATUS_ERR_GET_PRINT_BASELINE_FRAME_NOTREADY                  \
                                                (VCSFW_STATUS_ERR_FLAG | 410)
#define VCSFW_STATUS_ERR_GET_PRINT_BASELINE_FRAME_BADMETHOD                 \
                                                (VCSFW_STATUS_ERR_FLAG | 411)
#define VCSFW_STATUS_ERR_READ_FPDATA_NO_MEMORY                              \
                                                (VCSFW_STATUS_ERR_FLAG | 412)
#define VCSFW_STATUS_ERR_READ_RAW_FPDATA_ATIDLE                             \
                                                (VCSFW_STATUS_ERR_FLAG | 413)
#define VCSFW_STATUS_ERR_READ_RAW_FPDATA_RECONDONE                          \
                                                (VCSFW_STATUS_ERR_FLAG | 414)
#define VCSFW_STATUS_ERR_READ_RAW_FPDATA_RECON                              \
                                                (VCSFW_STATUS_ERR_FLAG | 415)
#define VCSFW_STATUS_ERR_READ_RAW_FPDATA_NOTRUNNING                         \
                                                (VCSFW_STATUS_ERR_FLAG | 416)
#define VCSFW_STATUS_ERR_READ_RAW_FPDATA_NO_MEMORY                          \
                                                (VCSFW_STATUS_ERR_FLAG | 417)
#define VCSFW_STATUS_ERR_IFS_STATS_GET_NOIMGRECON                           \
                                                (VCSFW_STATUS_ERR_FLAG | 418)
#define VCSFW_STATUS_ERR_IFS_STATS_GET_NOTRUNNING                           \
                                                (VCSFW_STATUS_ERR_FLAG | 419)
#define VCSFW_STATUS_ERR_IMAGE_ACQUISITION_FAILED                           \
                                                (VCSFW_STATUS_ERR_FLAG | 420)
#define VCSFW_STATUS_ERR_TEST_OTPROM_BADBASELINE                            \
                                                (VCSFW_STATUS_ERR_FLAG | 421)
#define VCSFW_STATUS_ERR_TEST_OTPROM_FAILED                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 422)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_SHORTHDR                             \
                                                (VCSFW_STATUS_ERR_FLAG | 423)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_LOADADDR                             \
                                                (VCSFW_STATUS_ERR_FLAG | 424)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_STARTSPACE                           \
                                                (VCSFW_STATUS_ERR_FLAG | 425)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_STARTALIGN                           \
                                                (VCSFW_STATUS_ERR_FLAG | 426)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_STARTBOUND                           \
                                                (VCSFW_STATUS_ERR_FLAG | 427)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTENCRYPTED                         \
                                                (VCSFW_STATUS_ERR_FLAG | 428)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTSIGNED                            \
                                                (VCSFW_STATUS_ERR_FLAG | 429)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTENG                               \
                                                (VCSFW_STATUS_ERR_FLAG | 430)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTPROD                              \
                                                (VCSFW_STATUS_ERR_FLAG | 431)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_SHORTSIG                             \
                                                (VCSFW_STATUS_ERR_FLAG | 432)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_BADSIG                               \
                                                (VCSFW_STATUS_ERR_FLAG | 433)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_BSSBOUND                             \
                                                (VCSFW_STATUS_ERR_FLAG | 434)
#define VCSFW_STATUS_ERR_SCM_WOF_TOOSHORT                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 435)
#define VCSFW_STATUS_ERR_SCM_WOF_TOOLONG                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 436)
#define VCSFW_STATUS_ERR_FRAME_READ_NOTRUNNING                              \
                                                (VCSFW_STATUS_ERR_FLAG | 437)
#define VCSFW_STATUS_ERR_FRAME_READ_NOTYET                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 438)
#define VCSFW_STATUS_ERR_FRAME_READ_XFERNUMPAST                             \
                                                (VCSFW_STATUS_ERR_FLAG | 439)
#define VCSFW_STATUS_ERR_FRAME_READ_DONE                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 440)
#define VCSFW_STATUS_ERR_FRAME_TAG_TOOSHORT                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 441)
#define VCSFW_STATUS_ERR_FRAME_TAG_TOOLONG                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 442)
#define VCSFW_STATUS_ERR_FRAME_TAG_REG32BLK_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 443)
#define VCSFW_STATUS_ERR_FRAME_TAG_REG32BLK_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 444)
#define VCSFW_STATUS_ERR_FRAME_TAG_DIMS_TOOSHORT                            \
                                                (VCSFW_STATUS_ERR_FLAG | 445)
#define VCSFW_STATUS_ERR_FRAME_TAG_DIMS_TOOLONG                             \
                                                (VCSFW_STATUS_ERR_FLAG | 446)
#define VCSFW_STATUS_ERR_FRAME_TAG_REG16BLK_TOOSHORT                        \
                                                (VCSFW_STATUS_ERR_FLAG | 447)
#define VCSFW_STATUS_ERR_FRAME_TAG_REG16BLK_TOOLONG                         \
                                                (VCSFW_STATUS_ERR_FLAG | 448)
#define VCSFW_STATUS_ERR_FRAME_READ_NO_MEMORY                               \
                                                (VCSFW_STATUS_ERR_FLAG | 449)
#define VCSFW_STATUS_ERR_DRIVEMATRIXTOOSHORT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 450)
#define VCSFW_STATUS_ERR_DRIVEMATIXTOOLONG                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 451)
#define VCSFW_STATUS_ERR_DECODEMATRIXTOOSHORT                               \
                                                (VCSFW_STATUS_ERR_FLAG | 452)
#define VCSFW_STATUS_ERR_DECODEMATRIXTOOLONG                                \
                                                (VCSFW_STATUS_ERR_FLAG | 453)
#define VCSFW_STATUS_ERR_LNABASELINETOOSHORT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 454)
#define VCSFW_STATUS_ERR_LNABASELINETOOLONG                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 455)
#define VCSFW_STATUS_ERR_ADCBASELINETOOSHORT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 456)
#define VCSFW_STATUS_ERR_ADCBASELINETOOLONG                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 457)
#define VCSFW_STATUS_ERR_INVALID_FRAME_TAG                                  \
                                                (VCSFW_STATUS_ERR_FLAG | 458)
#define VCSFW_STATUS_ERR_FRAME_ACQ_ALREADY_RUNNING                          \
                                                (VCSFW_STATUS_ERR_FLAG | 459)
#define VCSFW_STATUS_ERR_FRAME_FINISH_NOT_RUNNING                           \
                                                (VCSFW_STATUS_ERR_FLAG | 460)
#define VCSFW_STATUS_ERR_FRAME_READ_FIRSTNOTZERO                            \
                                                (VCSFW_STATUS_ERR_FLAG | 461)
#define VCSFW_STATUS_ERR_FRAME_READ_OFFNOTMULT2                             \
                                                (VCSFW_STATUS_ERR_FLAG | 462)
#define VCSFW_STATUS_ERR_FRAME_ACQ_NODIMS                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 463)
#define VCSFW_STATUS_ERR_IOTA_WRITE_CHAINLOCKED                             \
                                                (VCSFW_STATUS_ERR_FLAG | 464)
#define VCSFW_STATUS_ERR_IOTA_WRITE_OUTOFSPACE                              \
                                                (VCSFW_STATUS_ERR_FLAG | 465)
#define VCSFW_STATUS_ERR_IOTA_WRITE_BADLENGTH                               \
                                                (VCSFW_STATUS_ERR_FLAG | 466)
#define VCSFW_STATUS_ERR_IOTA_WRITE_FLASHUNLOCK                             \
                                                (VCSFW_STATUS_ERR_FLAG | 467)
#define VCSFW_STATUS_ERR_IOTA_WRITE_FLASHWRITE                              \
                                                (VCSFW_STATUS_ERR_FLAG | 468)
#define VCSFW_STATUS_ERR_IOTA_WRITE_TOOSHORT                                \
                                                (VCSFW_STATUS_ERR_FLAG | 469)
#define VCSFW_STATUS_ERR_FRAME_TAG_ACQOPT_TOOSHORT                          \
                                                (VCSFW_STATUS_ERR_FLAG | 470)
#define VCSFW_STATUS_ERR_FRAME_TAG_ACQOPT_TOOLONG                           \
                                                (VCSFW_STATUS_ERR_FLAG | 471)
#define VCSFW_STATUS_ERR_FLASH_ERASE_SECTION_INVALID                        \
                                                (VCSFW_STATUS_ERR_FLAG | 472)
#define VCSFW_STATUS_ERR_FLASH_ERASE_FAILURE                                \
                                                (VCSFW_STATUS_ERR_FLAG | 473)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_SCM_WOF_TOOSHORT                     \
                                                (VCSFW_STATUS_ERR_FLAG | 474)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_SCM_WOF_TOOLONG                      \
                                                (VCSFW_STATUS_ERR_FLAG | 475)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_SCM_WOF_NO_MEMORY                    \
                                                (VCSFW_STATUS_ERR_FLAG | 476)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_SCM_WOF_ILLEGAL_PARAMETER            \
                                                (VCSFW_STATUS_ERR_FLAG | 477)
#define VCSFW_STATUS_ERR_GET_PRINT_CAL_SCM_WOF_INVALID_ZONE                 \
                                                (VCSFW_STATUS_ERR_FLAG | 478)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_IFVER                                \
                                                (VCSFW_STATUS_ERR_FLAG | 479)
#define VCSFW_STATUS_ERR_DATA_CORRUPTION                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 480)
#define VCSFW_STATUS_ERR_FMNO_GET_NOTSET                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 481)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTCUSTKEY                           \
                                                (VCSFW_STATUS_ERR_FLAG | 482)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_CUSTKEY_NOTDEF                       \
                                                (VCSFW_STATUS_ERR_FLAG | 483)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_CUSTKEY_BAD                          \
                                                (VCSFW_STATUS_ERR_FLAG | 484)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_CUSTKEY_NOSUP                        \
                                                (VCSFW_STATUS_ERR_FLAG | 485)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_NOTENCBLK                            \
                                                (VCSFW_STATUS_ERR_FLAG | 486)
#define VCSFW_STATUS_ERR_FRAME_STREAM_NOTRUNNING                            \
                                                (VCSFW_STATUS_ERR_FLAG | 487)
#define VCSFW_STATUS_ERR_FRAME_STREAM_NOTYET                                \
                                                (VCSFW_STATUS_ERR_FLAG | 488)
#define VCSFW_STATUS_ERR_BOOTLDR_PATCH_PRODUCT                              \
                                                (VCSFW_STATUS_ERR_FLAG | 489)
#define VCSFW_STATUS_ERR_FLASH_ERASE_DENIED                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 490)
#define VCSFW_STATUS_ERR_FRAME_ACQ_XFERNOTX4                                \
                                                (VCSFW_STATUS_ERR_FLAG | 491)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_CHAIN_CORRUPT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 492)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_CHAIN_FULL                          \
                                                (VCSFW_STATUS_ERR_FLAG | 493)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_CHAIN_LOCKED                        \
                                                (VCSFW_STATUS_ERR_FLAG | 494)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_CORRUPT                             \
                                                (VCSFW_STATUS_ERR_FLAG | 495)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_BADHASH                          \
                                                (VCSFW_STATUS_ERR_FLAG | 496)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_CHAIN_BABBLE                     \
                                                (VCSFW_STATUS_ERR_FLAG | 497)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_CHAIN_TOOLONG                    \
                                                (VCSFW_STATUS_ERR_FLAG | 498)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_CMP_FAILED                       \
                                                (VCSFW_STATUS_ERR_FLAG | 499)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_EMPTY                            \
                                                (VCSFW_STATUS_ERR_FLAG | 500)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_HASH_WRONGSIZE                   \
                                                (VCSFW_STATUS_ERR_FLAG | 501)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_BADSIZE                     \
                                                (VCSFW_STATUS_ERR_FLAG | 502)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_CHAIN_NOSPACE               \
                                                (VCSFW_STATUS_ERR_FLAG | 503)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_CMP_FAILED                  \
                                                (VCSFW_STATUS_ERR_FLAG | 504)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_PROG_FAILED                 \
                                                (VCSFW_STATUS_ERR_FLAG | 505)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_TOOSMALL                    \
                                                (VCSFW_STATUS_ERR_FLAG | 506)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_LOC_NOTXWORD                     \
                                                (VCSFW_STATUS_ERR_FLAG | 507)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_LOC_OUTOFBOUNDS                  \
                                                (VCSFW_STATUS_ERR_FLAG | 508)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_MISSIONVALID                     \
                                                (VCSFW_STATUS_ERR_FLAG | 509)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_PRODUCT                          \
                                                (VCSFW_STATUS_ERR_FLAG | 510)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_PROG_FAILED                      \
                                                (VCSFW_STATUS_ERR_FLAG | 511)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_SIZE_NOTXWORD                    \
                                                (VCSFW_STATUS_ERR_FLAG | 512)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_TOOBIG                           \
                                                (VCSFW_STATUS_ERR_FLAG | 513)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_UNKNOWN                          \
                                                (VCSFW_STATUS_ERR_FLAG | 514)
#define VCSFW_STATUS_ERR_FLASHPROG_UNLOCK_FAILED                            \
                                                (VCSFW_STATUS_ERR_FLAG | 515)
#define VCSFW_STATUS_ERR_FRAME_TAG_STRIDEBLK_TOOSHORT                       \
                                                (VCSFW_STATUS_ERR_FLAG | 516)
#define VCSFW_STATUS_ERR_FRAME_TAG_STRIDEBLK_TOOLONG                        \
                                                (VCSFW_STATUS_ERR_FLAG | 517)
#define VCSFW_STATUS_ERR_FRAME_READ_FLAG_INCONSISTENCY                      \
                                                (VCSFW_STATUS_ERR_FLAG | 518)
#define VCSFW_STATUS_ERR_FRAME_STATS_NOTGATHERING                           \
                                                (VCSFW_STATUS_ERR_FLAG | 519)
#define VCSFW_STATUS_ERR_FRAME_STATS_NOTDONE                                \
                                                (VCSFW_STATUS_ERR_FLAG | 520)
#define VCSFW_STATUS_ERR_FRAME_STATS_BADTYPE                                \
                                                (VCSFW_STATUS_ERR_FLAG | 521)
#define VCSFW_STATUS_ERR_FRAME_TAG_STATS_TOOSHORT                           \
                                                (VCSFW_STATUS_ERR_FLAG | 522)
#define VCSFW_STATUS_ERR_FRAME_TAG_STATS_TOOLONG                            \
                                                (VCSFW_STATUS_ERR_FLAG | 523)
#define VCSFW_STATUS_ERR_FRAME_TAG_STATS_NOIMGDATA                          \
                                                (VCSFW_STATUS_ERR_FLAG | 524)
#define VCSFW_STATUS_ERR_FRAME_ACQ_NOSPACESUMS                              \
                                                (VCSFW_STATUS_ERR_FLAG | 525)
#define VCSFW_STATUS_ERR_FRAME_ACQ_NOSPACESQSUMS                            \
                                                (VCSFW_STATUS_ERR_FLAG | 526)
#define VCSFW_STATUS_ERR_IOTA_INSINUATE_TOO_BIG                             \
                                                (VCSFW_STATUS_ERR_FLAG | 527)
#define VCSFW_STATUS_ERR_FRAME_ACQ_STATS_INFINITE                           \
                                                (VCSFW_STATUS_ERR_FLAG | 528)
#define VCSFW_STATUS_ERR_FRAME_ACQ_STATS_SUMSQOVERFLOW                      \
                                                (VCSFW_STATUS_ERR_FLAG | 529)
#define VCSFW_STATUS_ERR_FRAME_ACQ_STATS_SUMOVERFLOW                        \
                                                (VCSFW_STATUS_ERR_FLAG | 530)
#define VCSFW_STATUS_ERR_FRAME_STATS_OVERRUN                                \
                                                (VCSFW_STATUS_ERR_FLAG | 531)
#define VCSFW_STATUS_ERR_FRAME_ACQ_ZERO_VSIZE                               \
                                                (VCSFW_STATUS_ERR_FLAG | 532)
#define VCSFW_STATUS_ERR_FRAME_ACQ_ZERO_HSIZE                               \
                                                (VCSFW_STATUS_ERR_FLAG | 533)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_MISMATCH                        \
                                                (VCSFW_STATUS_ERR_FLAG | 534)
#define VCSFW_STATUS_ERR_FLASHPROG_PLAINHDR_TYPE                            \
                                                (VCSFW_STATUS_ERR_FLAG | 535)
#define VCSFW_STATUS_ERR_FLASHPROG_PAGE_NOT_BLANK                           \
                                                (VCSFW_STATUS_ERR_FLAG | 536)
#define VCSFW_STATUS_ERR_PROGRAMMING_SOFTSECW                               \
                                                (VCSFW_STATUS_ERR_FLAG | 537)
#define VCSFW_STATUS_ERR_PROGRAMMING_FUSE                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 538)
#define VCSFW_STATUS_ERR_PROGRAMMING_FIB_PRODOPT                            \
                                                (VCSFW_STATUS_ERR_FLAG | 539)
#define VCSFW_STATUS_ERR_PROGRAMMING_SECW                                   \
                                                (VCSFW_STATUS_ERR_FLAG | 540)
#define VCSFW_STATUS_ERR_PROGRAMMING_MKM                                    \
                                                (VCSFW_STATUS_ERR_FLAG | 541)
#define VCSFW_STATUS_ERR_FLASHPROG_SECLEVEL_READFAIL                        \
                                                (VCSFW_STATUS_ERR_FLAG | 542)
#define VCSFW_STATUS_ERR_FLASHPROG_SECLEVEL_PROG_FAIL                       \
                                                (VCSFW_STATUS_ERR_FLAG | 543)
#define VCSFW_STATUS_ERR_FLASHPROG_SECLEVEL_CMP_FAIL                        \
                                                (VCSFW_STATUS_ERR_FLAG | 544)
#define VCSFW_STATUS_ERR_FLASHPROG_SECLEVEL_FULL                            \
                                                (VCSFW_STATUS_ERR_FLAG | 545)
#define VCSFW_STATUS_ERR_FLASHPROG_SECLEVEL_INVALID_OFFSET                  \
                                                (VCSFW_STATUS_ERR_FLAG | 546)
#define VCSFW_STATUS_ERR_FLASHPROG_FLASH_SECLEVEL_TOOHIGH                   \
                                                (VCSFW_STATUS_ERR_FLAG | 547)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_READFAIL                        \
                                                (VCSFW_STATUS_ERR_FLAG | 548)
#define VCSFW_STATUS_ERR_FLASHPROG_PATCH_SECLEVEL_INVALID                   \
                                                (VCSFW_STATUS_ERR_FLAG | 549)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_PROG_READFAIL                   \
                                                (VCSFW_STATUS_ERR_FLAG | 550)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_PROG_NOTBLANK                   \
                                                (VCSFW_STATUS_ERR_FLAG | 551)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_PROG_FAIL                       \
                                                (VCSFW_STATUS_ERR_FLAG | 552)
#define VCSFW_STATUS_ERR_FLASHPROG_FWFLAVOR_CMP_FAIL                        \
                                                (VCSFW_STATUS_ERR_FLAG | 553)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_CFG_VERSION_TOOLOW               \
                                                (VCSFW_STATUS_ERR_FLAG | 554)
#define VCSFW_STATUS_ERR_FLASHPROG_FLASH_NO_IOTAS                           \
                                                (VCSFW_STATUS_ERR_FLAG | 555)
#define VCSFW_STATUS_ERR_FLASHPROG_FLASH_VERSION_NOT_LAST_IOTA              \
                                                (VCSFW_STATUS_ERR_FLAG | 556)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_CONFIGID_MISMATCH                \
                                                (VCSFW_STATUS_ERR_FLAG | 557)
#define VCSFW_STATUS_ERROR_FLASHPROG_OVERWRITE_DIFF                         \
                                                (VCSFW_STATUS_ERR_FLAG | 558)
#define VCSFW_STATUS_ERR_FLASHPROG_PAYLOAD_IOTA_CHAIN_CORRUPT               \
                                                (VCSFW_STATUS_ERR_FLAG | 559)
#define VCSFW_STATUS_ERR_FLASHPROG_FLASH_VERSION_IOTA_EMPTY                 \
                                                (VCSFW_STATUS_ERR_FLAG | 560)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_HDR_PROG_FAILED                \
                                                (VCSFW_STATUS_ERR_FLAG | 561)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_HDR_CMP_FAILED                 \
                                                (VCSFW_STATUS_ERR_FLAG | 562)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_PROG_FAILED               \
                                                (VCSFW_STATUS_ERR_FLAG | 563)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_CMP_FAILED                \
                                                (VCSFW_STATUS_ERR_FLAG | 564)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_PROG0_FAILED              \
                                                (VCSFW_STATUS_ERR_FLAG | 565)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_CMP0_FAILED               \
                                                (VCSFW_STATUS_ERR_FLAG | 566)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_PROG1_FAILED              \
                                                (VCSFW_STATUS_ERR_FLAG | 567)
#define VCSFW_STATUS_ERR_FLASHPROG_IOTA_LIST_DATA_CMP1_FAILED               \
                                                (VCSFW_STATUS_ERR_FLAG | 568)
#define VCSFW_STATUS_ERR_FDETECT_NAV_TOOSHORT                               \
                                                (VCSFW_STATUS_ERR_FLAG | 569)
#define VCSFW_STATUS_ERR_FDETECT_NAV_TOOLONG                                \
                                                (VCSFW_STATUS_ERR_FLAG | 570)
#define VCSFW_STATUS_ERR_FDETECT_FU_TOOLONG                                \
                                                (VCSFW_STATUS_ERR_FLAG | 571)
#define VCSFW_STATUS_ERR_IOTA_CRC_MISMATCH                                 \
                                                (VCSFW_STATUS_ERR_FLAG | 572)


/****************************************************************************/
/* Every command begins with the following structure.  See the vcsfw_cmd_t  */
/* structure near the bottom of this file. Subsequent data differs by       */
/* command.  Note that the end of the command is denoted out-of-band (there */
/* is no length built in).                                                  */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_generic_command_s
{
    vcsUint8_t command;
} vcsfw_generic_command_t;

typedef struct VCS_PACKED vcsfw_generic_reply_s
{
    vcsUint16_t status;
} vcsfw_generic_reply_t;


/****************************************************************************/
/* VCSFW_CMD_GET_VERSION                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_version_s
{
    vcsUint32_t   buildtime;        /* Unix-style build time, in seconds   */
                                    /*  from 1/1/1970 12:00 AM GMT         */
    vcsUint32_t   buildnum;         /* build number                        */
    vcsUint8_t    vmajor;           /* major version                       */
    vcsUint8_t    vminor;           /* minor version                       */
    vcsUint8_t    target;           /* target, e.g. VCSFW_TARGET_ROM       */
    vcsUint8_t    product;          /* product, e.g.  VCSFW_PRODUCT_FALCON */
    vcsUint8_t    siliconrev;       /* silicon revision                    */
    vcsUint8_t    formalrel;        /* boolean: non-zero -> formal release */
    vcsUint8_t    platform;         /* Platform (PCB) revision             */
    vcsUint8_t    patch;            /* patch level                         */
    vcsUint8_t    serial_number[6]; /* 48-bit Serial Number                */
    vcsUint8_t    security[2];      /* bytes 0 and 1 of OTP                */
    vcsUint32_t   patchsig;         /* opaque patch signature              */
    vcsUint8_t    iface;            /* interface type, see below           */
    vcsUint8_t    otpsig[3];        /* OTP Patch Signature                 */
    vcsUint16_t   otpspare1;        /* spare space                         */
    vcsUint8_t    reserved;         /* reserved byte                       */
    vcsUint8_t    device_type;      /* device type                         */
} vcsfw_reply_get_version_t;

/* values for vcsfw_reply_get_version_t::target */
#define VCSFW_TARGET_ROM              1
#define VCSFW_TARGET_FPGA             2
#define VCSFW_TARGET_RTLSIM           3
/* VCSFW_TARGET_ISS, below, is deprecated */
#define VCSFW_TARGET_ISS              4
#define VCSFW_TARGET_FPGADBG          5

/* values for vcsfw_reply_get_version_t::interface */
#define VCSFW_IFACE_UNKNOWN       0
#define VCSFW_IFACE_USB           1
#define VCSFW_IFACE_PARALLEL      2
#define VCSFW_IFACE_SPI           3
#define VCSFW_IFACE_SPI_MASTER    4
#define VCSFW_IFACE_SPI_MCBSP     5
#define VCSFW_IFACE_I2C           6
#define VCSFW_IFACE_PS2           7

/* defines for the product field in the preceding structure */
#define VCSFW_PRODUCT_FALCON        1
#define VCSFW_PRODUCT_RAPTOR        2
#define VCSFW_PRODUCT_FALCONUSB     3
#define VCSFW_PRODUCT_FALCONSPI     4
#define VCSFW_PRODUCT_RAPTORUSB     5
#define VCSFW_PRODUCT_RAPTORSPI     6
#define VCSFW_PRODUCT_FIJIUSB       20
#define VCSFW_PRODUCT_FIJISPI       21
#define VCSFW_PRODUCT_BUGATTI       30  /* Cosworth -- never produced */
#define VCSFW_PRODUCT_WINDSOR       40  /* Windsor -- never produced */
#define VCSFW_PRODUCT_WINDSORPP     41  /* pre-provisioned dev only FPGA */
#define VCSFW_PRODUCT_WINDSORPREPROV VCSFW_PRODUCT_WINDSORPP
#define VCSFW_PRODUCT_WINDSORUSB    42  /* Windsor -- never produced */
#define VCSFW_PRODUCT_WINDSORSPI    43  /* Windsor -- never produced */
#define VCSFW_PRODUCT_WINDSORPPUSB  44  /* Windsor -- never produced */
#define VCSFW_PRODUCT_WINDSORPPSPI  45  /* Windsor -- never produced */
#define VCSFW_PRODUCT_OSPREYUSB     46  /* Osprey 1 (Eagle based) */
#define VCSFW_PRODUCT_OSPREY2       47  /* Osprey 2 (Windsor firmware) */
#define VCSFW_PRODUCT_METALLICA     48  /* Metallica (Windsor firmware) */
#define VCSFW_PRODUCT_OSPREY2PP     49  /* Pre-provisioned Osprey2 (dev only) */
#define VCSFW_PRODUCT_VIPER         50  /* Viper (Windsor firmware) */
#define VCSFW_PRODUCT_VIPER2        51  /* Viper2 aka b1202 (Windsor f/w) */
#define VCSFW_PRODUCT_PALISADE      52  /* Palisade aka b1203 (Savoy f/w) */
#define VCSFW_PRODUCT_DENALI        53  /* Denali aka b1210 (Nassau f/w) */
#define VCSFW_PRODUCT_DENALIPBL     54  /* Denali primary boot loader */
#define VCSFW_PRODUCT_CRYSPEAKFPGA  55  /* Crystal Peak Demo FPGA */
#define VCSFW_PRODUCT_HAYES         56  /* Hayes aka b1212 (Nassau f/w) */
#define VCSFW_PRODUCT_HAYESPBL      57  /* Hayes primary boot loader */
#define VCSFW_PRODUCT_HAYESCP       58  /* Hayes Crystal Peak mission */
#define VCSFW_PRODUCT_VIPER3        59  /* Viper3 (Windsor f/w) */
#define VCSFW_PRODUCT_SHASTA        60  /* Shasta aka b1216 (Nassau f/w) */
#define VCSFW_PRODUCT_SHASTAPBL     61  /* Shasta primary boot loader */
#define VCSFW_PRODUCT_WHITNEY       62  /* Whitney ROM code */


/* The following bits are for vcsfw_reply_get_version_t::platform */
#define VCSFW_PLATFORM_SECURE_MATCH  (1 << 0)
#define VCSFW_PLATFORM_SECURE_PATCH  (1 << 1)

/* The following bits describe security options in
** vcsfw_reply_get_version_t::security[1] bit-field */
#define VCSFW_SECURITY1_PROVISIONED      (1 << 0)
#define VCSFW_SECURITY1_MODE             (1 << 1)
#define VCSFW_SECURITY1_RSA_KEYLEN_2048  (1 << 3)
#define VCSFW_SECURITY1_HOST_AUTH        (1 << 4)
#define VCSFW_SECURITY1_PROD_SENSOR      (1 << 5)
#define VCSFW_SECURITY1_BASIC_SECMODE    (1 << 6)
#define VCSFW_SECURITY1_SECCOM_ENFORCED  (1 << 7)

/* The following bits describe security options in
** vcsfw_reply_get_version_t::security[0] bit-field */
#define VCSFW_SECURITY0_PKI_SECCOM       (1 << 0)
#define VCSFW_SECURITY0_256BIT           (1 << 1)

/*
 * The following bits are for vcsfw_reply_get_version_t::patchsig.
 *
 * The signature bits.  These are derived from the patch
 *  file format description in FalconFileFormats.doc
 */

/* The list that follows is the set of canonical names. */
#define VCSFW_PATCHSIG_SECURITY_RSA          (0 << 0)
#define VCSFW_PATCHSIG_PHASE_BOOT            (1 << 0)
#define VCSFW_PATCHSIG_PHASE_CAL             (1 << 1)
#define VCSFW_PATCHSIG_PHASE_SECMGMT         (1 << 2)
#define VCSFW_PATCHSIG_PHASE_FLASH           (1 << 3)
#define VCSFW_PATCHSIG_IFACE_USB             (1 << 4)
#define VCSFW_PATCHSIG_IFACE_PARALLEL        (1 << 5)
#define VCSFW_PATCHSIG_IFACE_SPI             (1 << 6)
#define VCSFW_PATCHSIG_IFACE_SPI_MASTER      (1 << 7)
#define VCSFW_PATCHSIG_IFACE_SPI_MCBSP       (1 << 8)
#define VCSFW_PATCHSIG_SECURITY_INSECURE     (1 << 12)
#define VCSFW_PATCHSIG_SECURITY_AESONLY      (1 << 13)
#define VCSFW_PATCHSIG_PHASE_MODULETEST      (1 << 14)
#define VCSFW_PATCHSIG_PHASE_LED             (1 << 15)
#define VCSFW_PATCHSIG_PHASE_PROVISION       (1 << 16)
#define VCSFW_PATCHSIG_PHASE_GETPRINT        (1 << 17)
#define VCSFW_PATCHSIG_PHASE_NAV             (1 << 18)
#define VCSFW_PATCHSIG_PHASE_SECUREMATCH     (1 << 19)
#define VCSFW_PATCHSIG_PHASE_TAKEOWNSIMUL    (1 << 20)
#define VCSFW_PATCHSIG_PHASE_SETVCKIVENG     (1 << 21)
#define VCSFW_PATCHSIG_PHASE_SETVCKIVPRD     (1 << 22)
#define VCSFW_PATCHSIG_PHASE_SPANSUSP        (1 << 23)
#define VCSFW_PATCHSIG_PHASE_PREBOOT         (1 << 24)
#define VCSFW_PATCHSIG_PHASE_KEYEXCHANGE     (1 << 25)
#define VCSFW_PATCHSIG_PHASE_ENCDEC          (1 << 26)
#define VCSFW_PATCHSIG_PHASE_WOVAR           (1 << 27)
#define VCSFW_PATCHSIG_PHASE_PRESECMGMT      (1 << 28)
#define VCSFW_PATCHSIG_PHASE_AUTH            (1 << 29)
#define VCSFW_PATCHSIG_PHASE_VCK             (1 << 30)
#define VCSFW_PATCHSIG_PHASE_SENSOR_TEST     (1 << 31)

/* This list are the historically-used variants.  References to these
 *  should be hunted down and eliminated so that these lines can be
 *  killed off.
 */
#define VCSFW_PATCHSIG_PHASE_RUN                                            \
    VCSFW_PATCHSIG_PHASE_BOOT
#define VCSFW_PATCHSIG_PHASE_CALIBRATION                                    \
    VCSFW_PATCHSIG_PHASE_CAL
#define VCSFW_PATCHSIG_PHASE_SECURITY_MGMT                                  \
    VCSFW_PATCHSIG_PHASE_SECMGMT
#define VCSFW_PATCHSIG_PHASE_SPISFR                                         \
    VCSFW_PATCHSIG_PHASE_FLASH
#define VCSFW_PATCHSIG_PHASE_NAVIGATION                                     \
    VCSFW_PATCHSIG_PHASE_NAV
#define VCSFW_PATCHSIG_PHASE_TAKEOWNSIM                                     \
    VCSFW_PATCHSIG_PHASE_TAKEOWNSIMUL

/****************************************************************************/
/* VCSFW_CMD_RESET                                                          */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_reset_s
{
    vcsUint16_t     delaytime;    /* time (in ms) to delay after reply */
} vcsfw_cmd_reset_t;

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_GET_PRINT                                                      */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_get_print_s
{
    vcsUint16_t     linelen;    /* number of bytes/line */
    vcsUint16_t     nlines;     /* number of lines: 0 = unlimited */
} vcsfw_cmd_get_print_t;

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/*****************************************************************************/
/* GetPrint Parameter Defines                                                */
/*****************************************************************************/
/*                                                                           */
/* List of parameter types                                                   */
#define VCSFW_PARAM_SECURITY       6    /* Security Parameters for print (VFS4x1) */
#define VCSFW_PARAM_MOTION_2      11    /* Motion Detect Algorithm 2 control */
#define VCSFW_PARAM_BW_REDUCTION  21    /* Bandwidth Reduction parameters    */
#define VCSFW_PARAM_AGC           22    /* AGC Control.                      */
#define VCSFW_PARAM_CONFIGREPLY   23    /* Reply with GET_CONFIGURATION data */
#define VCSFW_PARAM_BLOCK_MODE    26    /* Specify the FP acquisition mode   */
#define VCSFW_PARAM_CFGTSBLREPLY  35    /* reply with GET_CFGTSBL data       */
#define VCSFW_PARAM_ACM_CONFIG    42    /* Advance Culling config params     */
#define VCSFW_PARAM_ACM_CONTROL   43    /* Advance Culling control params    */
#define VCSFW_PARAM_CEM_CONFIG    44    /* Correlation Engine config params  */
#define VCSFW_PARAM_CEM_CONTROL   45    /* Correlation Engine control params */
#define VCSFW_PARAM_IMAGE_RECON   46    /* Image reconstruction params       */
#define VCSFW_PARAM_2D            47    /* expecting 2D data (Osprey)        */
#define VCSFW_PARAM_LINEUPD       48    /* per-line update table (Osprey)    */
#define VCSFW_PARAM_TSFDETECT     49    /* timeslot table for fdetect (Osprey*/
#define VCSFW_PARAM_FPSECURITY    54    /* Security Parameters for print (aligned) */
#define VCSFW_PARAM_NAV           57    /* Nav params */
#define VCSFW_PARAM_DATA_ENCODER  66    /* Data encoder parameter */
#define VCSFW_PARAM_LINEUPD_INTERLEAVE  68  /* lineupdate interleave factor */

/*
 * Parameters in the range of 0x8000 - 0xffff are Validity private.
 */

/* Parameter Structure      */
typedef struct VCS_PACKED vcsfw_param_s
{
    vcsUint16_t parameter;
    vcsUint16_t length;
    /* Followed by length bytes of data */
} vcsfw_param_t;


#define VCSFW_PARAM_SECURITY_PASSTHRU 0
#define VCSFW_PARAM_SECURITY_CBC      1
#define VCSFW_PARAM_SECURITY_COUNTER  2

#define VCSFW_PARAM_SECURITY_128BIT  1
#define VCSFW_PARAM_SECURITY_192BIT  2
#define VCSFW_PARAM_SECURITY_256BIT  4

/* This definition is used for workaround of issues #43394 and #45181(cookie */
/* verification failure). It indicates the hash calculation frequency - i.e. */
/* if VCSFW_SECURITY_HASH_CALC_FREQUENCY=16 then it means that firmware and  */
/* USDK will calculate hash only on each 16-th fingerprint line.             */
#define VCSFW_SECURITY_HASH_CALC_FREQUENCY    16

/* VCSFW_PARAM_SECURITY -- Security parameters for the sweep                 */
 typedef struct VCS_PACKED
{
    vcsUint8_t AES_key[256 / 8];    /*                                       */
    vcsUint8_t AES_IV[256 / 8];     /* 64 bits of Counter in Counter mode    */
    vcsUint8_t hash_key[256 / 8];   /*                                       */
    vcsUint32_t nonce;              /*                                       */
    vcsUint32_t clock;              /* AES clock frequency                   */
    vcsUint8_t keysize;             /* Applies to AESKey, IV, and HashKey    */
    vcsUint8_t mode;                /* 0 = passthru, 1 = CBC, 2 = Counter    */
} vcsfw_param_security_t;

/* VCSFW_PARAM_FPSECURITY -- Fingerprint security parameters (aligned)       */
 typedef struct VCS_PACKED
{
    vcsUint8_t AES_key[256 / 8];    /*                                       */
    vcsUint8_t AES_IV[256 / 8];     /* 64 bits of Counter in Counter mode    */
    vcsUint8_t hash_key[256 / 8];   /*                                       */
    vcsUint32_t nonce;              /*                                       */
    vcsUint32_t clock;              /* AES clock frequency                   */
    vcsUint8_t keysize;             /* Applies to AESKey, IV, and HashKey    */
    vcsUint8_t mode;                /* 0 = passthru, 1 = CBC, 2 = Counter    */
    vcsUint16_t reserved;           /* reserved                              */
} vcsfw_param_fpsecurity_t;

/* VCSFW_PARAM_MOTION_2 -- Motion Detection Algorithm 2 Parameters          */
/* Line Cull - based Motion/Finger detection                                */
typedef struct VCS_PACKED
{
    vcsUint16_t fingerdebounce;     /* Lines to send unconditionally after GetPrint   */
    vcsUint16_t initialdebounce;    /* Lines to send unconditionally after FingerDown */
    vcsUint16_t stilldebounce;      /* Identical lines before we declare finger still */
    vcsUint16_t fingervariance;     /* variance across a line to indicate finger down */
    vcsUint16_t stillfinish;        /* Lines in Still before sensor terminates print  */
    vcsUint16_t donedebounce;       /* Lines sent unconditionally at end of print     */
    vcsUint16_t statusdebounce;     /* Lines sent unconditionally on status change    */
    vcsUint16_t StartTS;            /* Timeslot to start Variance/Cull calculation    */
    vcsUint16_t StopTS;             /* Timeslot to end Variance/Cull calculation      */
    vcsUint8_t  initialstate;       /* What state should we start in?  0=default      */
    vcsUint8_t  bitdepth;           /* Bit depth of the data used for Variance/Cull   */
} vcsfw_param_motion_2_t;

/* VCSFW_PARAM_BW_REDUCTION -- Bandwidth Reduction (Cull) functions */
#define VCSFW_BW_SUPPRESS_CULL  0x01
#define VCSFW_BW_SUPPRESS_STILL 0x02

typedef struct VCS_PACKED
{
    vcsUint32_t cull_flags;       /* VCSFW_BW_SUPPRESS_CULL and/or _STILL */
    vcsUint32_t cull_control;     /* How to cull. */
} vcsfw_param_bw_reduction_t;

/* VCSFW_PARAM_AGC -- Automatic Gain Control */
typedef struct VCS_PACKED
{
    vcsUint32_t flags;
    vcsUint32_t control;
    vcsUint32_t Z0_thresh;
    vcsUint32_t Z0_count;
    vcsUint32_t Z1_thresh;
    vcsUint32_t Z1_count;
    vcsUint8_t Z0_finish_thresh;
    vcsUint8_t Z1_finish_thresh;
    vcsUint16_t finish_debounce;
} vcsfw_param_agc_t;

/* VCSFW_PARAM_ACM_CONFIG -- Advance Culling config */
#define VCSFW_ACM_GET_LINE_COUNT(x)         (((x).pixel_info_line >>  0) & 0x3FF)
#define VCSFW_ACM_GET_HEADER_COUNT(x)       (((x).pixel_info_line >> 12) & 0x1F)
#define VCSFW_ACM_GET_MISC_DATA_COUNT(x)    (((x).pixel_info_line >> 20) & 0x0F)
#define VCSFW_ACM_GET_PRI_COUNT(x)          (((x).pixel_info_prim >>  0) & 0xFF)
#define VCSFW_ACM_GET_CORR_START(x)         (((x).pixel_info_prim >>  8) & 0xFF)

typedef struct VCS_PACKED
{
    vcsUint32_t      pixel_info_line;
    vcsUint32_t      pixel_info_prim;
} vcsfw_param_acm_config_t;

/* VCSFW_PARAM_ACM_CONTROL -- Advance Culling control */
typedef struct VCS_PACKED
{
    vcsUint32_t      acm_ctrl;
    vcsUint32_t      cull_pix_test1;
    vcsUint32_t      cull_total_thresh_test1;
    vcsUint32_t      params_test2;
    vcsUint32_t      params_test3a;
    vcsUint32_t      params_test3b;
    vcsUint32_t      params_test3c;
    vcsUint32_t      params_test5_md;
    vcsUint32_t      params_test5_ncca;
    vcsUint32_t      params_test5_nccb;
    vcsUint32_t      params_test5_nccc;
    vcsUint32_t      params_test5_nccc2;
} vcsfw_param_acm_control_t;

/* VCSFW_PARAM_CEM_CONFIG -- Correlation Engine config */
typedef struct VCS_PACKED
{
    vcsUint32_t      ctl_Offsets_updown;
    vcsUint32_t      ctl_offsets_sideab;
    vcsUint32_t      ctl_offsets_sideab_acm;
    vcsUint32_t      ctl_offsets_aux;
    vcsUint32_t      ctl_yrange_updn;
    vcsUint32_t      ctl_yrange_sideab;
    vcsUint32_t      ctl_xrange_up;
    vcsUint32_t      ctl_xrange_dn;
    vcsUint32_t      ctl_xrange_sideab;
    vcsUint32_t      ctl_xrange_aux;
} vcsfw_param_cem_config_t;

/* VCSFW_PARAM_CEM_CONTROL -- Correlation Engine control */
#define VCSFW_CEM_OPMODE_RAW    0   /* output raw line data */
#define VCSFW_CEM_OPMODE_IR     1   /* output primary image line + result data */
#define VCSFW_CEM_OPMODE_NAV    2   /* output CEM result data */
#define VCSFW_CEM_OPMODE_DEBUG  3   /* output full line data + result data */

/* Extract the OPMODE field from the CEM control */
#define VCSFW_CEM_GET_OPMODE(x) (((x) >> 9) & 0x03)
/* Set the OPMODE field in the CEM control */
#define VCSFW_CEM_SET_OPMODE(x,mode)    (((x) & ~(0x03 << 9)) | (((mode) & 0x03) << 9))

typedef struct VCS_PACKED
{
    vcsUint32_t      cem_ctrl;
    vcsUint32_t      ctl_corr_params;
    vcsUint32_t      ctl_opt_params_x1;
    vcsUint32_t      ctl_opt_params_x2;
    vcsUint32_t      ctl_opt_params_y;
    vcsUint32_t      ctl_srchspc_lag;
    vcsUint32_t      ctl_srchspc_win;
} vcsfw_param_cem_control_t;

/* VCSFW_PARAM_IMAGE_RECON -- Image reconstruction params */
typedef struct VCS_PACKED
{
    vcsUint32_t     irflags;
    vcsUint16_t     cols;               /* width of reconstructed image */
    vcsUint16_t     rows;               /* height of reconstructed image */
    vcsUint16_t     dpi;                /* resolution in dot per inch */
    vcsUint16_t     reserved;

    /* TODO: add additional parameters */
    vcsUint16_t     fpbuf_rows;         /* number of rows in the raw fpbuf */
    vcsUint16_t     reconimagesize;     /* number of dwords in recon image */
    vcsUint16_t     persistentmemsize;  /* number of dwords in persistent memory pool */
    vcsUint16_t     volatilememsize;    /* number of dwords in volatile memory pool */
} vcsfw_param_dlimager_t;

#define VCSFW_PARAM_IRFLAGS_CAPTURE_PURPOSE_ENROLL     0x01
#define VCSFW_PARAM_IRFLAGS_POST_PROCESS               0x02
#define VCSFW_PARAM_IRFLAGS_SEND_RAW_FPDATA            0x04
#define VCSFW_PARAM_IRFLAGS_CAPTURE_BASELINE           0x08
#define VCSFW_PARAM_IRFLAGS_CAPTURE_WAIT_FOR_FU        0x10
#define VCSFW_PARAM_IRFLAGS_CAPTURE_TILL_FU            0x20
#define VCSFW_PARAM_IRFLAGS_TWO_FRAME_AVERAGE          0x40
#define VCSFW_PARAM_IRFLAGS_MIDQUARTILE_BASED_NORMALIZE_ENABLE 0x80
#define VCSFW_PARAM_IRFLAGS_PRENORMALIZE_ENABLE        0x100

typedef struct VCS_PACKED
{
    vcsUint32_t     irflags;
    vcsUint16_t     cols;               /* width of reconstructed image */
    vcsUint16_t     rows;               /* height of reconstructed image */
    vcsUint16_t     dpi;                /* resolution in dot per inch */
    vcsUint16_t     reserved1;

    /* various frame selection parameters */
    vcsUint8_t      stride;
    vcsUint8_t      numDarkerThresh;
    vcsUint8_t      numDarkerThreshPct;
    vcsUint8_t      settleHistDiffThreshPct;
    vcsUint8_t      settleHistDiffThreshPctHighconf;
    vcsUint8_t      settleHistDiffThreshPctAvg;
    vcsUint8_t      settleHistDiffThreshPctPrev;
    vcsUint8_t      settleHistDarkerThreshPct;
    vcsUint8_t      settleHistDarkerThreshPct2;
    vcsUint8_t      settleHistLighterThreshPct;
    vcsUint8_t      chooseHistLighterThreshPct;
    vcsUint8_t      chooseHistLighterThreshPctExper;
    vcsUint8_t      chooseHistLighterDiffThreshPctPrev;
    vcsUint8_t      settleDarkCountThreshPct;
    vcsUint8_t      fingerLiftNumLighterThreshPct;
    vcsUint8_t      fingerLiftHistDiffThreshPct;
    vcsUint8_t      fastChooseHistLighterThreshPct;
    vcsUint8_t      fastChooseHistBelowAvgPct;
    vcsUint8_t      fastChooseHistLighterThreshAltPct;
    vcsUint8_t      fastChooseHistDiffThreshPct;
    vcsUint8_t      fastChooseHistDiffThreshPctPrev;
    vcsUint8_t      fastChooseHistBelowAvgCountDiff;
    vcsUint8_t      fastChooseMaxFrameCount;
    vcsUint8_t      baselineDiffThreshPct;
    vcsUint8_t      maxFramesWithoutFinger;
    vcsUint8_t      reserved2[3];
} vcsfw_param_ifsimager_t;

typedef struct VCS_PACKED
{
    vcsUint32_t     irflags;
    vcsUint16_t     cols;               /* width of reconstructed image */
    vcsUint16_t     rows;               /* height of reconstructed image */
    vcsUint16_t     dpi;                /* resolution in dot per inch */
    union {
        vcsUint16_t     reserved1;
        vcsUint16_t     frameVarThresh;
    } details;

    /* various frame selection parameters */
    vcsUint16_t         fingerPresentThresh;        /* avg line variance threshold for finger presence detect */
    vcsUint16_t         fingerAbsentThresh;         /* avg line variance threshold for finger absent detect */
    vcsUint8_t          fingerPresentThreshPct;     /* percent of lines with variance above threshold */
    vcsUint8_t          fingerLiftThreshPct;        /* percent of lines with variance below threshold */
    vcsUint8_t          fingerPresentVarThresh;     /* variance of the line variance threshold for finger detect */
    vcsUint8_t          fingerFastSettleThresh;     /* frame delta threshold for fast settling */
    vcsUint8_t          fingerSettleThresh;         /* frame delta threshold for normal settling */
    vcsUint8_t          maxFramesWithoutFinger;     /* wait this long before giving up on seeing a finger */
    vcsUint8_t          stride;
    vcsUint8_t          rxRepeat;                   /* Rx repeat count to support line averaging */
} vcsfw_param_ifsimager_v2_t;

/* imager type definitions */
#define IMGRECON_IMAGER_DLI     1       /* Dual line imager */
#define IMGRECON_IMAGER_IFS     2       /* Image frame selection */

typedef struct VCS_PACKED
{
    vcsUint16_t     imagertype;         /* imager type to use */
    vcsUint16_t     paramsize;          /* size of the imager parameters follow */
} vcsfw_param_image_recon_t;

/* VCSFW_PARAM_IFSIMAGER_FRAMESTATS -- Frame stats param */
typedef struct VCS_PACKED
{
    vcsUint16_t thresh;
    vcsUint16_t margin;
    vcsUint16_t pixCount;
    vcsUint16_t aboveAvgCount;
    vcsUint16_t belowAvgCount;
    vcsInt16_t  medianBin;      /* Use signed because subtracting */
    vcsUint16_t histogram[16];  /* 4-bit data only */
    vcsUint16_t diffPct;        /* As calculated, so we have some history */
    vcsUint16_t diffPctBaseline;/* As calculated, so we have some history */
} vcsfw_param_framestats_t;


/* VCSFW_PARAM_2D -- Indicate that we're getting 2D data (Osprey) */
typedef struct VCS_PACKED
{
    vcsUint32_t      linesperframe;     /* number of lines per frame nom=160*/
} vcsfw_param_2d_t;

/* VCSFW_PARAM_LINEUPD -- Per-line update tables.  These are introduced
 *  for 2D sensors with Osprey. */

typedef struct VCS_PACKED
{
    vcsUint32_t      ngroups;           /* number of groups to follow */
} vcsfw_param_lineupd_t;

typedef struct VCS_PACKED
{
    vcsUint32_t      mask;              /* mask to use for packing or r/m/w */
    vcsUint32_t      flags;             /* flags and offset */
} vcsfw_param_lineupd_group_t;


#define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_B      30
#define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_N      2
#define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH        0xc0000000
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_8           0
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_16          1
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_32          2
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_RMW32       3

#define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_B      28
#define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_N      2
#define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE        0x30000000
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_TSLOT            0
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_HWREG            1
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_RAM              2
#   define VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_LINE             3

/* If you use VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_LINE,
 * then we sign-extend the offset */

/*
 * ARRAYREPEAT allows us to reuse the same array data for two
 *  contiguous groups.  The array data should be present for the
 *  first group and the ARRAYREPEAT bit should be set.  The
 *  second group should have no data but the ARRAYREPEAT bit
 *  should be clear.
 */

#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYREPEAT_B     27
#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYREPEAT_N     1
#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYREPEAT       0x08000000

#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_B      24
#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_N      3
#define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH        0x07000000
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_1           0x0
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_2           0x1
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_4           0x2
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_8           0x3
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_16          0x4
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_32          0x5
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_LINE        0x6
#   define VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_FRAMELINE   0x7

/*
 * Specify the transform handler to use.  "Identity" means that
 *  whatever value is cooked up from the arraywidth item
 *  above is used unchanged.
 * The "RX" transform uses the value from the arraywidth item
 *  as an index into a table of receivers which is loaded from
 *  the OTPROM (OTPROM_TAGTYPE_RXMAP).  This transform then is
 *  typically used with VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_FRAMELINE.
 * The remaining transforms are reserved.  If they are not
 *  implemented in a part then they are equivalent to the identity
 *  transform.
 * Transform 15 is reserved for a custom, soft-loaded transform.
 *  That is: all transforms are expected to work the same in
 *  all ROM parts, except transform 15.  Its behavior is
 *  patch-defined.
 */
#define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_B      20
#define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_N      4
#define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM        0x00f00000
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_IDENTITY    0x0
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_RX          0x1
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_2           0x2
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_3           0x3
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_4           0x4
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_5           0x5
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_6           0x6
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_7           0x7
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_8           0x8
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_9           0x9
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_10          0xa
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_11          0xb
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_12          0xc
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_13          0xd
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_14          0xe
#   define VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM_CUSTOM      0xf

#define VCSFW_PARAM_LINEUPD_FLAGS_OFFSET_B          0
#define VCSFW_PARAM_LINEUPD_FLAGS_OFFSET_N          20
#define VCSFW_PARAM_LINEUPD_FLAGS_OFFSET            0x000fffff


/*
 * Layout is:
 *          vcsfw_param_lineupd_t        taghdr
 *          vcsfw_param_lineupd_group_t  groups[ngroups]
 *          vcsUint32_t                  groupdata[nwordstotal]
 *                             (each groupdata is rounded up to n*32-bits)
 *
 *  nwordstotal = sum foreach group { roundup(linesperframe*arraywidth/32) }
 */

/* VCSFW_PARAM_LINEUPD_INTERLEAVE */

/*
 * Indicate only to run lineupdate every 'interleavecount'+1 lines.
 *  This means that if you had a VCSFW_PARAM_LINEUPD_INTERLEAVE with
 *  interleavecount=0 it's effectively a NOOP.  interleavecount=1
 *  will only do the lineupdate once for every two interrupts from
 *  the SCM.  interleavecount=2 will only do the lineupdate once for
 *  every three interrupts from the SCM.
 * I chose this design so that the magic value of 0 would mean
 *  the same as things are without this tag.
 * By the way, if you want no interleaving you don't need a
 *  VCSFW_PARAM_LINEUPD_INTERLEAVE tag at all.
 */
typedef struct VCS_PACKED vcsfw_param_lineupd_interleave_s
{
    vcsUint32_t     interleavecount;
} vcsfw_param_lineupd_interleave_t;

/* VCSFW_PARAM_NAV -- Navigation parameters */
typedef struct VCS_PACKED vcsfw_param_nav_s
{
    vcsUint16_t       navsendtime;
    vcsUint16_t       navidletime;
    vcsUint8_t        navmode;
    vcsUint8_t        finger_det_thresh;
    vcsUint8_t        finger_det_thresh2;
    vcsUint8_t        updn_corr_thresh_low_snr;
    vcsUint8_t        updn_corr_thresh_must_use;
    vcsUint8_t        updn_corr_thresh;
    vcsUint8_t        sd_corr_thresh;
    vcsUint8_t        sd_corr_thresh_min;
    vcsUint8_t        reli_corr_thresh;
    vcsUint8_t        debounce_scan_up;
    vcsUint8_t        debounce_scan_down;
    vcsUint8_t        min_iter_time;
    vcsUint8_t        event_qu_lat_proc;
    vcsUint8_t        event_qu_lat_output;
    vcsUint8_t        event_time_comb_eve_within;
    vcsUint8_t        event_filter_stale_time;
} vcsfw_param_nav_t;

/* VCSFW_PARAM_TSFDETECT -- Program the Timeslot configuration table for
 *  use with finger detection */
typedef struct VCS_PACKED vcsfw_param_tsfdetect_s
{
    vcsUint32_t tscfg[352];
} vcsfw_param_tsfdetect_t;

/* VCSFW_PARAM_WOF2_V3 -- Set up WOE WOF2 parameters,
   first used in Metallica B1 silicon. */
typedef struct VCS_PACKED vcsfw_param_wof2_v3_s
{
    vcsUint32_t wof2_ctrl2;     /* WOE_WOF2_CTRL2 register  */
    vcsUint32_t wof2_thresh;    /* WOE_WOF2_THRESH register, zone 0 */
    vcsUint32_t wof2_threshz1;  /* WOE_WOF2_THRESH_Z1 register, zone 1 */
    vcsUint16_t wof2_ctrl1;     /* WOE_WOF2_CTRL1 register  */
    vcsUint16_t wof2_cfg_size;  /* Number of bytes of cfg data follow */
    vcsUint8_t  wof2_flags;     /* Calibration directives defined in vcsfw_v4.h */
    vcsUint8_t reserved[3];     /* Now used to contain the INVERTED values
                                 *  of WOF2_ZONE_CFG[23:0] */
} vcsfw_param_wof2_v3_t;

/* VCSFW_PARAM_DATA_ENCODER -- Fingerprint data encoder parameter */
typedef struct VCS_PACKED vcsfw_param_data_encoder_s
{
    vcsUint8_t  encoder;    /* encoder type */
    vcsUint8_t  offset;     /* offset from the beginning of the line */
    vcsUint16_t pixels;     /* number of pixels encoded */
    vcsUint32_t param;      /* encoder specific parameter */
} vcsfw_param_data_encoder_t;

/* VCSFW_PARAM_SCM_WOF -- Set up SCM WOF parameters */
typedef struct VCS_PACKED vcsfw_param_scm_wof_s {
    vcsUint32_t woe_wof2_thresh;    /* WOE_WOF2_THRESH register, zone 0 */
    vcsUint32_t woe_wof2_threshz1;  /* WOE_WOF2_THRESH_Z1 register, zone 1 */
    vcsUint8_t scm_wof_thresh;      /* SCM_WOF_THRESH register */
    vcsUint8_t reserved[3];
} vcsfw_param_scm_wof_t;

/* VCSFW_PARAM_SCM_WOF_V2 -- Set up SCM WOF parameters */
typedef struct VCS_PACKED vcsfw_param_scm_wof_v2_s {
    vcsUint32_t woe_wof2_thresh;    /* WOE_WOF2_THRESH register, zone 0 */
    vcsUint32_t woe_wof2_threshz1;  /* WOE_WOF2_THRESH_Z1 register, zone 1 */
    vcsUint8_t scm_wof_thresh;      /* SCM_WOF_THRESH register */
    vcsUint8_t scm_wof_debounceup;  /* Debounce count for FU detection */
    vcsUint8_t reserved[2];
} vcsfw_param_scm_wof_v2_t;

#if !defined(VCSFW_SCM_WOF_CAL_Z0)
#define VCSFW_SCM_WOF_CAL_Z0 0x1 /* Calibrate SCM WOF zone 0 */
#endif
#if !defined(VCSFW_SCM_WOF_CAL_Z1)
#define VCSFW_SCM_WOF_CAL_Z1 0x2 /* Calibrate SCM WOF zone 1 */
#endif

/* VCSFW_PARAM_CAL_SCM_WOF */
typedef struct VCS_PACKED vcsfw_param_cal_scm_wof_s
{
    vcsUint16_t max_replysize; /* Maximum bytes in reply, based on params */
    vcsUint8_t  max_gain;      /* Highest gain allowed */
    vcsUint8_t  min_gain;      /* Lowest gain allowed */
    vcsUint8_t  start_gain;    /* Starting gain */
    vcsUint8_t  step_gain;     /* Step size for gain */
    vcsUint8_t  max_thresh;    /* Highest threshold allowed */
    vcsUint8_t  min_thresh;    /* Lowest threshold allowed */
    vcsUint8_t  wof_flags;     /* WOF directives; use VCSFW_SCM_WOF_CAL_Z0/Z1 */
    vcsUint8_t  reserved[3];
    vcsfw_param_scm_wof_t scm_wof; /* VCSFW_PARAM_SCM_WOF params */
} vcsfw_param_cal_scm_wof_t;
/* (followed by vcsfw_param_scm_wof_t) */
/*-------- NOTE: Maintain equivalence to vcsfw_param_scm_wof_t ---- */

/* Reply data format:
   Bytecount is divisible by 4.
   Byte  Description
   ----  -----------
   [+0]  SCM_SEN_STATUS Register value
   [+4]  SCM_WOF_STATUS Register value
   [+8]  Current calibration state (start of sweep or end of cal)
   [+9]  Current gain
   [+10] Current threshold
   [+11] Reserved
   [+12] Repeat values as in bytes 0:11, for each sweep iteration
   .
   .
   .
   [ITERATIONS * 12 + 0]   Final SCM_SEN_STATUS Register value
   [ITERATIONS * 12 + 4]   Final SCM_WOF_STATUS Register value
   [ITERATIONS * 12 + 8]   Final calibration state
   [ITERATIONS * 12 + 9]   Gain result, or current gain if Final Calibration
   state is non-zero
   [ITERATIONS * 12 + 10]  Threshold result, or current threshold if Final
   Calibration state is non-zero
   [ITERATIONS * 12 + 11]  Reserved
*/
typedef struct vcsfw_cal_scm_wof_status_s {
    vcsUint32_t scm_status;     /* SCM_SEN_STATUS register value */
    vcsUint32_t wof_status;     /* SCM_WOF_STATUS register value */
    vcsUint8_t  current_state;  /* Calibration current state */
    vcsUint8_t  current_gain;   /* Gain register field value */
    vcsUint8_t  current_thresh; /* Threshold register field value */
    vcsUint8_t  reserved;
} vcsfw_cal_scm_wof_status_t;

typedef struct vcsfw_reply_cal_scm_wof_s
{
    vcsUint32_t   bytes;   /* Number of status bytes returned */
    /* This is followed by the calibration status data
     * in 1 or more vcsfw_cal_scm_wof_status_t blobs. */
} vcsfw_reply_cal_scm_wof_t;

/* Data encoder type definitions */
#define VCSFW_PARAM_ENCODER_CDM4        1
#define VCSFW_PARAM_ENCODER_CDM16       2
#define VCSFW_PARAM_ENCODER_3XSAMPLE    3


/****************************************************************************/
/* VCSFW_CMD_GET_PRINT_SIGNATURE                                            */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

#define VCSFW_FP_SIGN_TYPE_HMAC     0
#define VCSFW_FP_SIGN_TYPE_RSA      1

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_print_signature_s
{
    vcsUint8_t HashType;                    /* Signature type               */
    vcsUint8_t unused;                      /* Inserted for alignment       */
    vcsUint8_t Signature[2048/8];           /* We will always generate a    */
                                            /* max-length signature         */
                                            /* (in big endian byte order)   */
} vcsfw_reply_get_print_signature_t;

/****************************************************************************/
/* VCSFW_CMD_STOP_PRINT                                                     */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_PATCH */
/****************************************************************************/
/* COMMAND                                                                  */
/*
 * A patch consists of a set of segments in the form
 *  {tag, length, data}.  The tags can be: DATA, JMPVEC, SIGNATURE.
 */
typedef struct VCS_PACKED vcsfw_cmd_patch_s
{
    vcsUint16_t   tag;
    vcsUint16_t   length;
} vcsfw_cmd_patch_t;

typedef struct VCS_PACKED vcsfw_cmd_patch_relochdr_s
{
    vcsUint32_t     linkaddr;       /* base (in SRAM_RAM) of patch */
    vcsUint32_t     entryaddr;      /* pointer to entry function */
    vcsUint16_t     nfixups24;      /* number of 3-byte fixups to follow */
    vcsUint16_t     nfixups32;      /* number of 4-byte fixups to follow */
} vcsfw_cmd_patch_relochdr_t;

/*
 * For the relocatable patch tag:
 *   + linkaddr is the original linked address of the patch.  The
 *     firmware must allocate a new block of space for the patch
 *     and then adjust the fixups based on the difference between
 *     the allocated address and linkaddr.
 *   + entryaddr is the original linked address of the patch_start
 *     function.
 *   + nfixups24 refers to the number of 3-byte fixups (l32r, call{0,4,8,12},
 *     and j instructions -- though l32r shouldn't need it).  The
 *     offsets for these fixups appear as an array of 16-bit
 *     unsigned values immediately after this header.
 *   + nfixups32 refers to the number of 4-byte fixups (literals and
 *     data).  The offsets for these fixups appear as an array of
 *     16-bit unsigned values immediately after any and all 3-byte
 *     fixups.
 */

#define VCSFW_TAG_PATCH_DATA       0x0000
/* Format: VCSFW_TAG_PATCH_DATA + 2-bytes-length + 4-bytes-address + data... */
#define VCSFW_TAG_PATCH_JMPVEC     0x0001
/* Format: VCSFW_TAG_PATCH_JMPVEC + 2-bytes-length + 4-bytes-address */
#define VCSFW_TAG_PATCH_SIGNATURE  0x0002
/* Format: VCSFW_TAG_PATCH_SIGNATURE + 2-bytes-length + signature... */
#define VCSFW_TAG_PATCH_CHECKSUM   0x0003
/* Format: VCSFW_TAG_PATCH_CHECKSUM + 2-bytes-length + checksum... */
#define VCSFW_TAG_PATCH_PADDING    0x0004
/* Format: VCSFW_TAG_PATCH_PADDING + 2-bytes-length + 0 or more bytes... */
#define VCSFW_TAG_PATCH_RELOC      0x0005
/* VCSFW_TAG_PATCH_RELOC + header + [3-byte fixups] + [4-byte fixups] + data */


/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_PEEK */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_peek_s
{
    vcsUint32_t   address;
    vcsUint8_t    opsize;
} vcsfw_cmd_peek_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_peek_s
{
    vcsUint32_t   value;
} vcsfw_reply_peek_t;


/* VCSFW_CMD_PRNG */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Command uses the vcsfw_generic_command_t structure                                                                  */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_prng_s
{
    vcsUint8_t   value[256];
} vcsfw_reply_prng_t;

/****************************************************************************/
/* VCSFW_CMD_POKE */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_poke_s
{
    vcsUint32_t   address;
    vcsUint32_t   value;
    vcsUint8_t    opsize;
} vcsfw_cmd_poke_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_SET_REFCLK                                                     */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_set_refclk_s
{
    vcsUint32_t refclock;    /* in Hertz (information only -- not used) */
    vcsUint32_t fastclock;   /* in Hertz (information only -- not used) */
    vcsUint32_t slowclock;   /* in Hertz (information only -- not used) */
    vcsUint32_t scdiv;
    vcsUint32_t plldiv;
} vcsfw_cmd_set_refclk_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */


/****************************************************************************/
/* VCSFW_CMD_WOE_ENTER                                                      */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_woe_enter_s
{
    vcsUint16_t     delaytime;    /* time (in ms) to delay after reply */
} vcsfw_cmd_woe_enter_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */


/****************************************************************************/
/* VCSFW_CMD_GPIO                                                           */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_gpio_reg_mask_s
{
    vcsUint32_t   newval;            /* *reg = (*reg & mask) | newval */
    vcsUint32_t   mask;
} vcsfw_gpio_reg_mask_t;

typedef struct VCS_PACKED vcsfw_cmd_gpio_s
{
    vcsfw_gpio_reg_mask_t   alt;
    vcsfw_gpio_reg_mask_t   dir;
    vcsfw_gpio_reg_mask_t   reserved;   /*
                                         *  NOTE: din is read-only
                                         *  -- Set the mask to 0xffffffff
                                         */
    vcsfw_gpio_reg_mask_t   dout;
    vcsfw_gpio_reg_mask_t   wpu;
    vcsfw_gpio_reg_mask_t   hdrv;
    vcsfw_gpio_reg_mask_t   alts;
    vcsfw_gpio_reg_mask_t   ien;
    vcsfw_gpio_reg_mask_t   pdr;
} vcsfw_cmd_gpio_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_gpio_s
{
    vcsUint32_t   alt;
    vcsUint32_t   dir;
    vcsUint32_t   din;
    vcsUint32_t   dout;
    vcsUint32_t   wpu;
    vcsUint32_t   hdrv;
    vcsUint32_t   alts;
    vcsUint32_t   ien;
    vcsUint32_t   pdr;
} vcsfw_reply_gpio_t;


/****************************************************************************/
/* VCSFW_CMD_WOE_SETUP                                                      */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED
{
    vcsUint32_t Parameters[14];
} vcsfw_cmd_woe_setup_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */


/****************************************************************************/
/* VCSFW_CMD_SET_CPUCLK                                                     */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Command uses the vcsfw_cmd_set_cpuclk_t structure.                   */
typedef struct VCS_PACKED
{
    vcsUint32_t     run_cpuclkctrl;
    vcsUint32_t     wait_cpuclkctrl;
} vcsfw_cmd_set_cpuclk_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_GET_CONFIGURATION                                              */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Command uses the vcsfw_generic_command_t structure                   */

/* REPLY                                                                    */
#define VCSFW_CONFIG_SIZE  (600)

typedef struct VCS_PACKED vcsfw_reply_get_configuration_s
{
    vcsUint16_t reserved;
    vcsUint32_t configuration[VCSFW_CONFIG_SIZE];
} vcsfw_reply_get_configuration_t;


/****************************************************************************/
/* VCSFW_CMD_GET_FINGER_STATUS                                              */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Command uses the vcsfw_generic_command_t structure                   */

/* REPLY                                                                    */
/* defines for the finger status/finger state field                         */
#define VCSFW_FINGER_STATUS_UNKNOWN   0 /* firmware has no ideas            */
#define VCSFW_FINGER_STATUS_ABSENT    1 /* finger doesn't appear to be there*/
#define VCSFW_FINGER_STATUS_STILL     2 /* finger is settled, not moving   */
#define VCSFW_FINGER_STATUS_MOVING    3 /* finger is there and moving       */
#define VCSFW_FINGER_STATUS_ERROR     4 /* finger detection error           */
                                        /* e.g. excessive false trigger     */

/* defines for the accumwoe field for Falcon/Raptor                         */
#define VCSFW_WOE_EV_TIMER             0x08 /* WOE Timer event occurred     */
#define VCSFW_WOE_EV_FINGER            0x10 /* Finger was detected          */

typedef struct VCS_PACKED vcsfw_reply_get_finger_status_s
{
    vcsUint8_t      status;             /* Motion Detection status          */
    vcsUint32_t     accumwoe;           /* Accumulated WOE status bits      */
} vcsfw_reply_get_finger_status_t;

/****************************************************************************/
/* VCSFW_CMD_SET_SPIMODE                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/*
 * The following flags affect the operation of the secondary SPI
 *  port only.  That is: they only matter if the MASTER bit is on.
 */

#define VCSFW_SPIFLAGS_SCDIV_MASK  0x00000fff  /* SCDIV value                */
#define VCSFW_SPIFLAGS_MASTER      0x00001000  /* master mode                */
#define VCSFW_SPIFLAGS_16BIT       0x00002000  /* 16 bit mode                */
#define VCSFW_SPIFLAGS_SCM         0x00004000  /* alt. clocking mode         */
#define VCSFW_SPIFLAGS_SCIDL       0x00008000  /* MSK idles 0=low,1=high     */
#define VCSFW_SPIFLAGS_LEMD        0x00010000  /* load enable mode           */
#define VCSFW_SPIFLAGS_LEPL        0x00020000  /* load enable polarity       */
#define VCSFW_SPIFLAGS_FNCLE       0x00040000  /* frame not cont. LE         */
#define VCSFW_SPIFLAGS_MCBSP       0x00080000  /* McBSP mode                 */
#define VCSFW_SPIFLAGS_MCBSP_MSK   0x00100000  /* McBSP clock is ext.        */
#define VCSFW_SPIFLAGS_COMM        0x00200000  /* Setting up for Master comm */

typedef struct VCS_PACKED vcsfw_cmd_set_spimode_s
{
    vcsUint32_t   spiflags;
} vcsfw_cmd_set_spimode_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_SPI_TRANSFER                                                   */
/****************************************************************************/
#define VCSFW_SECURITY_IV_SIZE          16
#define VCSFW_SPI_OP_READ               0
#define VCSFW_SPI_OP_WRITE              1
#define VCSFW_SPI_CRYPTO_OP_DECRYPT     VCSFW_SPI_OP_READ
#define VCSFW_SPI_CRYPTO_OP_ENCRYPT     VCSFW_SPI_OP_WRITE

/* defines for the SPIM port */
#define VCSFW_SPIM_PORT_SPI1   1  /* Set SPI Master port to SPI0 core */
#define VCSFW_SPIM_PORT_SPI2   0  /* Set SPI Master port to SPI1 core */

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_spi_transfer_s
{
    vcsUint8_t  iv[VCSFW_SECURITY_IV_SIZE];
    vcsUint32_t enc_length;
    vcsUint32_t data_length;
    vcsUint16_t enc_offset;
    vcsUint16_t mode;
    vcsUint8_t  port;
    vcsUint8_t  unused[5];
} vcsfw_cmd_spi_transfer_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */


/****************************************************************************/
/* VCSFW_CMD_GET_STARTINFO                                                  */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_startinfo_s
{
    vcsUint8_t start_type;
    vcsUint8_t reset_type;
    vcsUint32_t start_status;
    vcsUint32_t sanity_pc;
    vcsUint32_t sanity_code;
    vcsUint32_t reset_nvinfo[13];
} vcsfw_reply_get_startinfo_t;

/*
 * Some notes about this command:
 *  1) The values for start_type and reset_type are chosen to match
 *     the values defined in the firmware in falcon/src/woe.h.  Make
 *     sure these stay the same.
 *  2) reset_type is only valid if start_type==VCSFW_STARITNFO_START_TYPE_RESET.
 *  3) start_status is a copy of the WOE_STATUS register in the
 *     hardware at startup.  We only define some of the event
 *     bit fields here.
 *  4) start_type values:
 *         VCSFW_STARTINFO_START_TYPE_RESET
 *                          We are starting from a RESET.  A reset
 *                          has subtypes described in the reset_type
 *                          member.
 *         VCSFW_STARTINFO_START_TYPE_SLEEP
 *                          Firmware resumed from a SLEEP.  SLEEP is
 *                          entered when the SLEEP line (a hardware signal)
 *                          is asserted.
 *         VCSFW_STARTINFO_START_TYPE_WOE
 *                          Firmware started as the result of a Wake-on-Event
 *                          event.  The firmware doesn't usually care which
 *                          event caused the wakeup.  However, the wakeup
 *                          information is available in the start_status
 *                          member.
 *  5) reset_type values (only valid if start_type==RESET):
 *         VCSFW_STARTINFO_RESET_TYPE_POWERON
 *                          The firmware started running from a power-on
 *                          reset.  Obviously, this only happens once
 *                          when power is applied to the part.
 *         VCSFW_STARTINFO_RESET_TYPE_WDOG
 *                          The firmware restarted as the result of a
 *                          watchdog timeout.  This usually indicates
 *                          some kind of firmware or hardware error.
 *         VCSFW_STARTINFO_RESET_TYPE_PANIC
 *                          The firmware restarted as the result of an
 *                          internal panic.  This usually indicates
 *                          some kind of firmware or hardware error.
 *         VCSFW_STARTINFO_RESET_TYPE_COMM
 *                          The firmware restarted as the result of a
 *                          communications-port initiated reset (e.g.
 *                          a USB reset).
 *         VCSFW_STARTINFO_RESET_TYPE_CMD
 *                          The firmware restarted as the result of a
 *                          command (i.e. VCSFW_CMD_RESET).
 *         VCSFW_STARTINFO_RESET_TYPE_UNKNOWN
 *                          The firmware restarted for unknown reasons.
 *         VCSFW_STARTINFO_RESET_TYPE_HV_ESD
 *                          (So far, for Eagle only): the firmware reset
 *                          do to an ESD event in the high voltage logic.
 *         VCSFW_STARTINFO_RESET_TYPE_LV_ESD
 *                          (So far, for Eagle only): the firmware reset
 *                          do to an ESD event in the low voltage logic.
 *         VCSFW_STARTINFO_RESET_TYPE_REG_CHECK
 *                          (So far, for Eagle only): the firmware reset
 *                          because the register checksum failed.
 *         VCSFW_STARTINFO_RESET_TYPE_BADEXC
 *                          (So far, for Eagle only): the firmware reset
 *                          because of an unhandled or double exception.
 *         VCSFW_STARTINFO_RESET_TYPE_TLS
 *                          TLS encountered a fatal error, and sent
 *                          an alert to the host.  The part reset after
 *                          the alert was received.
 *  6) sanity_pc is the program counter value for the last sanity panic.
 *  7) sanity_code is the sanity failure code for the last sanity panic.
 *  8) reset_nvinfo contains opaque debugging information.  It may
 *     very be invalid.
 */

/* values for vcsfw_reply_get_startinfo_t::start_type */
#define VCSFW_STARTINFO_START_TYPE_RESET    0
#define VCSFW_STARTINFO_START_TYPE_SLEEP    1
#define VCSFW_STARTINFO_START_TYPE_WOE      2

/* values for vcsfw_reply_get_startinfo_t::reset_type */
#define VCSFW_STARTINFO_RESET_TYPE_POWERON  0
#define VCSFW_STARTINFO_RESET_TYPE_WDOG     1
#define VCSFW_STARTINFO_RESET_TYPE_PANIC    2
#define VCSFW_STARTINFO_RESET_TYPE_COMM     3
#define VCSFW_STARTINFO_RESET_TYPE_CMD      4
#define VCSFW_STARTINFO_RESET_TYPE_UNKNOWN  5
#define VCSFW_STARTINFO_RESET_TYPE_HV_ESD   6
#define VCSFW_STARTINFO_RESET_TYPE_LV_ESD   7
#define VCSFW_STARTINFO_RESET_TYPE_REG_CHECK 8
#define VCSFW_STARTINFO_RESET_TYPE_BADEXC   9
#define VCSFW_STARTINFO_RESET_TYPE_TLS      10

/* Falcon/Raptor values for vcsfw_reply_get_startinfo_t::start_status */
#define VCSFW_STARTINFO_START_STATUS_EV_RESET   0x00000004
#define VCSFW_STARTINFO_START_STATUS_EV_TIMER   0x00000008
#define VCSFW_STARTINFO_START_STATUS_EV_FINGER  0x00000010
#define VCSFW_STARTINFO_START_STATUS_EV_GPIO    0x00000020
#define VCSFW_STARTINFO_START_STATUS_EV_SPI     0x00000040
#define VCSFW_STARTINFO_START_STATUS_EV_USB     0x00000080
#define VCSFW_STARTINFO_START_STATUS_EV_PP      0x00000100
#define VCSFW_STARTINFO_START_STATUS_EV_ABORT   0x00000200

/* Eagle values for vcsfw_reply_get_startinfo_t::start_status */
/* (derived from WOE_EVENT register) */
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RESET           0x00000001
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_POR         0x00000002
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_WDOG        0x00000004
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_FW          0x00000008
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_SLEEP       0x00000010
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_WOE         0x00000020
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_SUSPEND     0x00000040
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_HV_ESD      0x00000080
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_LV_ESD      0x00000100
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_USB_RESET   0x00000200
#define VCSFW_STARTINFO_START_STATUS_EAGLE_RST_REG_CHECK   0x00000400
#define VCSFW_STARTINFO_START_STATUS_EAGLE_INTR            0x00010000
#define VCSFW_STARTINFO_START_STATUS_EAGLE_EV_TIMER        0x00020000
#define VCSFW_STARTINFO_START_STATUS_EAGLE_EV_GPIO         0x00040000
#define VCSFW_STARTINFO_START_STATUS_EAGLE_EV_SPI          0x00080000
#define VCSFW_STARTINFO_START_STATUS_EAGLE_EV_USB_RESUME   0x00100000
#define VCSFW_STARTINFO_START_STATUS_EAGLE_EV_ABORT        0x00200000


#define VCSFW_SECURITY_MAX_PASSWORD_SIZE    64
#define VCSFW_SECURITY_SHARED_SECRET_SIZE   32
#define VCSFW_SHA256_HASH_SIZE              32

/****************************************************************************/
/* We keep VCSFW_CMD_GET_SHARED_SECRET related structures for backward      */
/* compatibility only to support build of patches for previous releases.    */
/****************************************************************************/

typedef struct VCS_PACKED vcsfw_cmd_get_shared_secret_s
{
    vcsUint8_t size;
    vcsUint8_t password[VCSFW_SECURITY_MAX_PASSWORD_SIZE];
    vcsUint8_t signature[VCSFW_SHA256_HASH_SIZE];
} vcsfw_cmd_get_shared_secret_t;

typedef struct VCS_PACKED vcsfw_reply_get_shared_secret_s
{
    vcsUint8_t shared_secret[VCSFW_SECURITY_SHARED_SECRET_SIZE];
} vcsfw_reply_get_shared_secret_t;

/****************************************************************************/
/* VCSFW_CMD_UNLOAD_PATCH                                                   */
/****************************************************************************/
/* COMMAND                                                                  */
/*
 * There are two options for the command.  If the command uses
 *  just the vcsfw_generic_command_t (i.e. the command is a single
 *  byte long) then the command is interpreted to mean "unload
 *  all loaded patches" -- just as it has been in the past.
 *
 * If, instead, it uses the vcsfw_cmd_unload_patch_t structure
 *  then only the requested patch is unloaded.
 */

typedef struct VCS_PACKED vcsfw_cmd_unload_patch_s
{
    vcsUint32_t     patchidx;       /* which patch to unload */
} vcsfw_cmd_unload_patch_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_SENSOR_LOCK                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_MATCH_VERIFY                                                   */
/****************************************************************************/
/* COMMAND                                                                  */
/* Template is sent after the command structure. */
typedef struct VCS_PACKED vcsfw_cmd_match_verify_s
{
    vcsUint16_t size;
    vcsUint16_t reserved;   /* Align to eliminate large allocation */
    vcsUint8_t  cookie[VCSFW_SHA256_HASH_SIZE];
} vcsfw_cmd_match_verify_t;

/* REPLY                                                                    */
/* Payload and error structure are sent after the reply structure. */
typedef struct VCS_PACKED vcsfw_reply_match_verify_s
{
    vcsUint16_t size;
    unsigned char err[16];
} vcsfw_reply_match_verify_t;

/****************************************************************************/
/* VCSFW_CMD_SIGN_ENC_TEMPLATE_DATA                                         */
/****************************************************************************/
/* COMMAND                                                                  */
#define VCSFW_SECURITY_DECRYPT 0
#define VCSFW_SECURITY_ENCRYPT 1

/* Enrollment / Identification Scheme flags */
#define VCSFW_EIS_SIMPLE                0x01
#define VCSFW_EIS_CHALLENGE_RESPONSE    0x02

/* Authentication algorithm IDs (same as Enrollment/Identification Schemes) */
#define VCSFW_AUTH_ALGID_SIMPLE         VCSFW_EIS_SIMPLE
#define VCSFW_AUTH_ALGID_CR             VCSFW_EIS_CHALLENGE_RESPONSE
#define VCSFW_AUTH_ALGID_VIP_TOTP       0x14
#define VCSFW_AUTH_ALGID_VIP_TOTP_TEST  0x15
#define VCSFW_AUTH_ALGID_OCRA           0x03
#define VCSFW_AUTH_ALGID_COPY           0x04
#define VCSFW_AUTH_ALGID_FIDO_TEST      0x32
#define VCSFW_AUTH_ALGID_FIDO           0x33
#define VCSFW_AUTH_ALGID_PKCR           0x40
#define VCSFW_AUTH_ALGID_FIDO_UAF       0x50
#define VCSFW_AUTH_ALGID_IPT            0x60
#define VCSFW_AUTH_ALGID_FIDO_U2F       0x70

/* Signature of EIS in payload block */
#define VCSFW_EIS_SIGN                  0x20

typedef struct VCS_PACKED vcsfw_cmd_sign_enc_template_data_s
{
    vcsUint16_t templateSize;
    vcsUint16_t payloadSize;
} vcsfw_cmd_sign_enc_template_data_t;
/* The command is followed by the "template data"
 * The first part of "template data" is the user's template of
 *  length "templateSize" and the next part is a user's payload
 *  of length "payloadSize".
 */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_sign_enc_template_data_s
{
    vcsUint16_t dataSize;
} vcsfw_reply_sign_enc_template_data_t;
/*  The reply is followed by the reply data of length replySize. */

/****************************************************************************/
/* VCSFW_CMD_DEC_VERIFY_TEMPLATE_DATA                                       */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_dec_verify_template_data_s
{
    vcsUint16_t dataSize;
    vcsUint16_t passwordLength;
    vcsUint8_t  unused[12]; /*  template data should start at  */
                            /*  16 byte aligned address */
    vcsUint8_t  password[VCSFW_SECURITY_MAX_PASSWORD_SIZE];
    vcsUint8_t  externalFile[VCSFW_SHA256_HASH_SIZE];
} vcsfw_cmd_dec_verify_template_data_t;
/* The command is followed by encrypted "template data" blob */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_dec_verify_template_data_s
{
    vcsUint16_t templateSize;
    vcsUint16_t payloadSize;
} vcsfw_reply_dec_verify_template_data_t;
/*
 * The reply is followed by the reply data of length
 * templateSize + payloadSize.
 * if payloadSize==0 than payload is not sent.
 */

/****************************************************************************/
/* VCSFW_CMD_PROVISION                                                      */
/****************************************************************************/
/* COMMAND                                                                  */

#define VCSFW_CMD_PROVISION_SEC_OPTS_ENFORCE_SECCOM                 0x00000001
#define VCSFW_CMD_PROVISION_SEC_OPTS_PKI_SECCOM                     0x00000002
#define VCSFW_CMD_PROVISION_SEC_OPTS_256BIT_SECURITY                0x00000004

/* The command structure.
 * The command data will be ignored by Metallica/Viper.
 */
typedef struct VCS_PACKED vcsfw_cmd_provision_s
{
    vcsUint32_t options;
} vcsfw_cmd_provision_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_TAKE_OWNERSHIP                                                 */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_take_ownership_s
{
    vcsUint8_t size;
    vcsUint8_t password[VCSFW_SECURITY_MAX_PASSWORD_SIZE];
} vcsfw_cmd_take_ownership_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_take_ownership_s
{
    vcsUint8_t shared_secret[VCSFW_SECURITY_SHARED_SECRET_SIZE];
    vcsUint8_t signature[VCSFW_SHA256_HASH_SIZE];
} vcsfw_reply_take_ownership_t;

/****************************************************************************/
/* VCSFW_CMD_RESET_OWNERSHIP                                                */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_reset_ownership_s
{
    vcsUint8_t password_size;
    vcsUint8_t password[VCSFW_SECURITY_MAX_PASSWORD_SIZE];
    vcsUint8_t signature[VCSFW_SHA256_HASH_SIZE];
} vcsfw_cmd_reset_ownership_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_DECOMMISSION                                                   */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_SPISLV_FAST_READ                                               */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_spislv_fast_read_s
{
    vcsUint32_t write_length;
    vcsUint32_t read_length;  /* read_length % 64 = 0  */
    vcsUint8_t  port;
    vcsUint8_t  unused[105];
} vcsfw_cmd_spislv_fast_read_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_LED                                                            */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_led_s
{
    vcsfw_cmd_gpio_t        gpio_reg;       /* VCSFW_CMD_GPIO */
    vcsfw_gpio_reg_mask_t   state_a;
    vcsfw_gpio_reg_mask_t   state_b;
    vcsfw_gpio_reg_mask_t   state_c;
    vcsfw_gpio_reg_mask_t   state_d;
    vcsUint32_t             state_ab_duty_cycle;
    vcsUint32_t             state_cd_duty_cycle;
    vcsUint16_t             state_ab_time;
    vcsUint16_t             state_cd_time;
    vcsUint8_t              finger_down_state;
    vcsUint8_t              timeout;
} vcsfw_cmd_led_t;
/*
 * Some notes about this command:
 *
 *  1) gpio_reg
 *      same like VCSFW_CMD_GPIO
 *
 *  2) state_a
 *      data out register value for state A
 *
 *  3) state_b
 *      data out register value for state B
 *
 *  4) state_c
 *      data out register value for state C
 *
 *  5) state_d
 *      data out register value for state D
 *
 *  6) state_ab_duty_cycle
 *      32-bit value that indicates how to swap between state A and State B.
 *      Every 0 in this value indicates that State A should be set for 1 ms,
 *      and every 1 indicates that state B should be set for 1 ms.
 *
 *  7) state_cd_duty_cycle
 *      32-bit value that indicates how to swap between state C and State D.
 *       Every 0 in this value indicates that State C should be set for 1 ms,
 *       and every 1 indicates that state D should be set for 1 ms.
 *
 *  8) state_ab_time
 *      milliseconds to set in state A/B
 *
 *  9) state_cd_time
 *      milliseconds to set in state C/D
 *
 *  10) finger_down_state
 *          which state to set on finger down A=0, B=1, C=2, D=3
 *
 *  11) timeout
 *          Timeout in seconds, after this number of seconds LED will stop
            blinking. If the value is zero timeout feature is disabled.
 */

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_GET_OWNERSHIP_INFO                                             */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Command uses the vcsfw_generic_command_t structure                   */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_ownership_info_s
{
    vcsUint16_t TotalCycles;            /* how many cycles were possible at */
                                        /* manufacturing time               */
    vcsUint16_t AvailableCycles;        /* how many cycles are still        */
                                        /* available                        */
} vcsfw_reply_get_ownership_info_t;

/****************************************************************************/
/* VCSFW_CMD_GET_UID                                                        */
/****************************************************************************/
#define VCSFW_RAPTOR_UID_SIZE   VCSFW_SECURITY_IV_SIZE    /* AES_BLOCK_SIZE */

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_uid_s
{
    vcsUint16_t vid;
    vcsUint16_t pid;
    vcsUint8_t uid[VCSFW_RAPTOR_UID_SIZE];
} vcsfw_reply_get_uid_t;

/****************************************************************************/
/* VCSFW_CMD_KEY_EXCHANGE_DH                                                */
/****************************************************************************/
/* COMMAND                                                                  */

#define VCSFW_DH_KEY_LENGTH    16 /* Key length for Diffie-Hellman protocol.*/
#define VCSFW_DH_BLOCK_LENGTH  (VCSFW_DH_KEY_LENGTH + 2)

typedef struct VCS_PACKED vcsfw_cmd_key_exchange_dh_s
{
    vcsUint8_t generator[VCSFW_DH_BLOCK_LENGTH];    /* Data should be right     */
    vcsUint8_t host_pub_key[VCSFW_DH_BLOCK_LENGTH]; /* aligned in the buffers,  */
    vcsUint8_t prime[VCSFW_DH_BLOCK_LENGTH];        /* setting unused bytes 0   */
} vcsfw_cmd_key_exchange_dh_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_key_exchange_dh_s
{
    vcsUint8_t sensor_pub_key[VCSFW_DH_BLOCK_LENGTH];
} vcsfw_reply_key_exchange_dh_t;

/****************************************************************************/
/* VCSFW_CMD_GET_CERTIFICATE                                                */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

#define VCSFW_MAX_RSA_KEY_LENGTH (2048 >> 3)

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_certificate_s
{
    vcsUint16_t key_length;     /* in bytes           */
    struct VCS_PACKED
    {
        vcsUint32_t pub_exp;    /* it is always 65537 */
        vcsUint8_t  modulus[VCSFW_MAX_RSA_KEY_LENGTH]; /* little endian */
    } pub_key;
    vcsUint8_t  sign[VCSFW_MAX_RSA_KEY_LENGTH];        /* big endian    */
} vcsfw_reply_get_certificate_t;

/****************************************************************************/
/* VCSFW_CMD_LED_EX                                                         */
/****************************************************************************/
/* COMMAND                                                                  */
#define MAXLEDS   4
#define MAXSTATES 4
typedef struct VCS_PACKED led_state_s {
    vcsUint8_t     onoff;           // Is the LED on during this state.
    vcsUint8_t     startbrightness; // Starting Brightness of the state
    vcsInt8_t      step;            // Signed incremental step
    vcsUint8_t     steptime;        // How often (in ms) to take a step.
    vcsUint8_t     maxbrightness;   // 0-255
    vcsUint16_t    stdwelltime;     // Specifies how long to run this state
} newled_state_t;

typedef struct VCS_PACKED led_control_s {
    newled_state_t    led_state[MAXSTATES]; // The four states that this LED
                                    // will cycle through
} newled_control_t;

typedef struct VCS_PACKED led_cmd_ex_s {
    newled_control_t  led_control[MAXLEDS]; // Describe the behavior of each
                                    // LED individually
    vcsUint32_t    dwelltime;       // Specified how long to run this command
} vcsfw_cmd_led_ex_t;

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */

/****************************************************************************/
/* VCSFW_CMD_GET_AUTH_DATA                                                  */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_get_auth_data_s
{
    vcsUint16_t auth_blob_size;
    vcsUint16_t add_info_size;
} vcsfw_cmd_get_auth_data_t;

/* The command is followed by the 'authentication data blob'
* (first 'auth_blob_size' bytes) and optionally with the
* 'additional info' (next 'add_info_size' bytes).
*
* auth_data_blob = Essek(Epek(payload)iv1)iv2, where the "payload"
* includes the following header: */

/* Definitions for 'flags' field in below structure. */
#define VCSFW_PAYLOAD_HDR_FLAG_COPYING_FORBIDDEN  0x0001

typedef struct VCS_PACKED vcsfw_getauthdata_payload_hdr_s
{
    vcsUint16_t auth_alg_id;    /* Should be equal to SubPhase of
                                ** corresponding authentication patch. */
    vcsUint16_t flags;          /* Flags, indicating different options
                                ** and policies. */
    vcsUint32_t padding_len;    /* The length of the padding data
                                ** following to payload. */
} vcsfw_getauthdata_payload_hdr_t;

/* 'additional info' may be required by particular authentication
* algorithm - e.g. it can be the 'Challenge' buffer for Challenge-Response
* algorithm. The structure of this data will be defined for each
* authentication algorithm separately.
*/

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_auth_data_s
{
    vcsUint16_t auth_data_size;
} vcsfw_reply_get_auth_data_t;
/*  The reply is followed by the reply data of length auth_data_size. */

/****************************************************************************/
/* VCSFW_CMD_TAKE_OWNERSHIP_EX                                              */
/****************************************************************************/
/* COMMAND                                                                  */

#define VCSFW_AES256_KEY_LEN    32

#define VCSFW_TAKEOWNERSHIP_EX_ICIDSIGN     0x44494349  /* "ICID" */
#define VCSFW_TAKEOWNERSHIP_EX_DEF_PM_SIZE  4096        /* 4 KB   */

/* The values of "flags" field of vcsfw_cmd_take_ownership_ex_s structure   */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_CIOS   0x0001 /* CIOS is provided.     */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_CIK    0x0002 /* CIK is provided.      */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_CISK   0x0004 /* SPrivK(mod, priv_exp) */
                                                   /* are provided.         */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_HAPUBK 0x0008 /* HAPubK is provided.   */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_CISPEK 0x0010 /* Set SPEK = CISPEK.    */
#define VCSFW_TAKEOWNERSHIP_EX_FLAGS_SK_RND 0x0020 /* Randomize the sensor's*/
                                                   /* key pair.             */

typedef struct VCS_PACKED vcsfw_cmd_take_ownership_ex_s
{
    vcsUint16_t flags;                      /* Bit-field parameter indicating*/
    vcsUint16_t unused;                     /* Unused word for alignment     */
    vcsUint8_t  hapubk_mod[VCSFW_MAX_RSA_KEY_LENGTH]; /* Modulus of HAPubK.  */
    vcsUint32_t flash_size;                 /* SPI flash size                */
    vcsUint32_t flash_sec_size;             /* SPI flash sector size         */
                                            /* availability of following-on  */
                                            /* parameters.                   */
    vcsUint8_t  cios[VCSFW_AES256_KEY_LEN]; /* Customer Injected Seed        */
    vcsUint8_t  cik[VCSFW_AES256_KEY_LEN];  /* Customer Injected Key.        */
    vcsUint8_t  ci_priv_exp[VCSFW_MAX_RSA_KEY_LENGTH];/* Customer injected   */
                                                      /* exponent of SPrivK. */
    vcsUint8_t  ci_mod[VCSFW_MAX_RSA_KEY_LENGTH];     /* Customer Injected   */
                                                      /* modulus of SPrivK.  */
} vcsfw_cmd_take_ownership_ex_t;

/* REPLY                                                                     */
typedef struct VCS_PACKED vcsfw_reply_take_ownership_ex_s
{
    vcsUint16_t unused;
    vcsUint8_t  hapubk_mod_enc[VCSFW_MAX_RSA_KEY_LENGTH]; /* Encrypted modulus*/
                                                         /* of HAPubK.       */
} vcsfw_reply_take_ownership_ex_t;

/****************************************************************************/
/* VCSFW_CMD_REWRITE_PM_SECTOR                                              */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_GEN_VCK                                                        */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

#define VCSFW_ENC_VCK_SIZE  16

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_gen_vck_s
{
    vcsUint8_t vck_iv[VCSFW_ENC_VCK_SIZE];       /* Encrypted VCK_IV seed   */
} vcsfw_reply_gen_vck_t;

/****************************************************************************/
/* VCSFW_CMD_POKE32 */
/****************************************************************************/
/* COMMAND                                                                  */
/* Unconditionally set any 32-bit register in the sensor. */
/* Aligned to 4-byte boundary, for use beginning with Eagle */
typedef struct VCS_PACKED vcsfw_cmd_poke32_s
{
        vcsUint32_t   address;
        vcsUint32_t   value;
} vcsfw_cmd_poke32_t;

/****************************************************************************/
/* VCSFW_CMD_INPLACE_PATCH */
/****************************************************************************/
/* COMMAND                                                                  */

/*
 * This command is designed to allow patches situated directly
 *  in the command buffer into which they are received.
 *  That is: the patch is never relocated once it is accepted by
 *  the firmware.
 * The patch begins with the VCSFW_CMD_INPLACE_PATCH byte, and then
 *  is followed by some number of bytes.  The last 8 bytes contain
 *  the following structure.
 * Note that this trailing structure is not necessarily aligned.
 */

/* This structure appears at the END of an in-place patch */
typedef struct VCS_PACKED vcsfw_cmd_inplace_patch_s
{
    vcsUint32_t      loadaddr;      /* expected address of first word */
    vcsUint32_t      startaddr;     /* jump here to start the patch */
} vcsfw_cmd_inplace_patch_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_GEN_SEC_KEY                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_gen_sec_key_s
{
    vcsUint32_t ssek_seed;                 /* Seed for generation SSEK      */
} vcsfw_cmd_gen_sec_key_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_GET_CFGTSBL                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* REPLY                                                                    */
/*
 * The reply is very tricky.
 *
 * It is formatted as follows:
 *  +0    status        16-bit reply status (usually VCSFW_STATUS_OKAY)
 *
 *  +2    tsmarker      32-bit timeslot marker.  For Eagle, it is equal
 *                      to the address of the BC_CB_TS_SCM_STRT_ADDR
 *                      register (0x30000288)
 *
 *  +6    tsnwords      32-bit value indicating number of *32-bit words*
 *                      of timeslot data that follow.  For the
 *                      VCSFW_CMD_GET_CFGTSBL command, this value is
 *                      always zero.
 *
 *  +10...+((tsnwords*4)+6)
 *                      tsnwords of 32-bit timeslot data
 *
 *  +((tsnwords*4)+10)
 *        blmarker      32-bit baseline marker.  For Eagle, it is equal
 *                      to the address of the BC_CB_OFFSET_SCM_STRT_ADDR
 *                      register (0x30000290)
 *
 *  +((tsnwords*4)+14)
 *        blnwords      32-bit value indicating number of *32-bit words*
 *                      of baseline data that follow.  For the
 *                      VCSFW_CMD_GET_CFGTSBL command, this value is
 *                      always zero.
 *
 *  +((tsnwords*4)+18).. +(((tsnwords+blnwords)*4)+14)
 *                      blnwords of 32-bit baseline data.
 *
 *  +(((tsnwords+blnwords)*4)+18)
 *        regdata       VCSFW_CFGTSBL_NREGS_EAGLE of
 *                      32-bit words of register data.
 *
 * Total size:
 *  +(((tsnwords+blnwords+VCSFW_CFGTSBL_NREGS_EAGLE)*4)+18)
 */

/* timeslot and baseline markers */
#define VCSFW_CFGTSBL_TS_MARKER         0x30000288
#define VCSFW_CFGTSBL_BL_MARKER         0x30000290

/* number of registers returned */
#define VCSFW_CFGTSBL_NREGS_EAGLE       207
#define VCSFW_CFGTSBL_NREGS_WINDSOR     246
#define VCSFW_CFGTSBL_NREGS_COSWORTH    237
#define VCSFW_CFGTSBL_NREGS_OSPREY2     383
#define VCSFW_CFGTSBL_NREGS_METALLICA   393
#define VCSFW_CFGTSBL_NREGS_VIPER       400

/****************************************************************************/
/* VCSFW_CMD_LED_EX2                                                        */
/****************************************************************************/
/* COMMAND                                                                  */
/*
 * This command allows blinking/dimming/ramping of LEDs on Eagle-based hardware
 * This differs from VCSFW_CMD_LED_EX in that it is organized by state (all
 * LEDs change state at the same time) as opposed to LED_EX which is organized
 * by LED (each LED can change states at different times).  This matches the
 * hardware implementations in Eagle and follow-on devices
 * Note:  For Eagle, LED0-2 are used to specify LED behavior during normal
 * operation.  LED3 of State 0 is used to specify LED behavior during suspend -
 *
 */

/* COMMAND                                                                    */
/* Size the arrays in the command structure                                   */
#define VCSFW_LED_EX2_LEDS   3
#define VCSFW_LED_EX2_STATES 6

/* Definitions for the active field of led_ex2_led_t and led_ex2_state_t      */
#define VCSFW_LED_EX2_INACTIVE    0
#define VCSFW_LED_EX2_ACTIVE      0x01
#define VCSFW_LED_EX2_WOE_ACTIVE  0x02

typedef struct VCS_PACKED vcsfw_cmd_led_ex2_led_s {
    vcsUint8_t  maxbrightness;   /* 0-255, current limit for the LED (WOE_LED)*/
    vcsUint8_t  startbrightness; /* Starting PWM Brightness          (PWM_LED)*/
    vcsInt8_t   reserved1;
    vcsUint8_t  reserved2;
} vcsfw_cmd_led_ex2_led_t;

typedef struct VCS_PACKED vcsfw_cmd_led_ex2_state_s {
    vcsUint16_t dwelltime;      /* Specifies how long to run this state, in ms */
    vcsUint16_t reserved;
    vcsUint8_t  active;         /* When is this state in use?                  */
    vcsUint8_t  startbrightness; /* Start Brightness of the state (PWM_BRIGHT) */
    vcsInt8_t   step;           /* Signed incremental step for startbrightness */
    vcsUint8_t  steptime;       /* How often (in ms) to step startbrightness   */
    vcsfw_cmd_led_ex2_led_t  led[VCSFW_LED_EX2_LEDS];
                                /* Settings for the three LEDs in this state   */
} vcsfw_cmd_led_ex2_state_t;

typedef struct VCS_PACKED vcsfw_cmd_led_ex2_s
{
    vcsUint32_t dwelltime;          /* How long to run this command (in ms )   */
    vcsfw_cmd_led_ex2_state_t state[VCSFW_LED_EX2_STATES]; /* states           */
} vcsfw_cmd_led_ex2_t;

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_SPI_FLASH                                                      */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_spi_flash_s
{
    vcsUint32_t addr;        /* External SPI flash address.                 */
                             /* 0xFFFFFFFF means that add is not specified  */
    vcsUint32_t read_length; /* Read length from SPI flash (FLASH to EP2).  */
                             /* Will be zero for write/erase operations.    */
    vcsUint8_t  dummy_bytes; /* No of Dummy Bytes in the SPI flash command. */
                             /* For example: dummy_length = 1 for FAST_READ */
    vcsUint8_t  cmdid;       /* external SPI flash instruction              */
} vcsfw_cmd_spi_flash_t;

/*
  The command is followed by payload data to write into the
  external SPI flash (CPU to FLASH)
*/

/* REPLY                                                                    */
/*   - Reply uses the vcsfw_generic_reply_t structure                       */
/*     followed by vcsfw_cmd_spi_flash_t::read_length bytes of data on EP2  */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_INFO_GET                                               */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* This command request storage related information from the sensor. */

/* REPLY                                                                    */
/* Partition access attributes */
#define VCSFW_STORAGE_ATTRB_READ        0x0001
#define VCSFW_STORAGE_ATTRB_WRITE       0x0002
#define VCSFW_STORAGE_ATTRB_NO_SESSION  0x0004
#define VCSFW_STORAGE_ATTRB_EXECUTE     0x0008
#define VCSFW_STORAGE_ATTRB_ENCRYPT     0x0010

/* partition types */
typedef enum vcsfw_storage_part_type_s {
    VCSFW_STORAGE_PART_FWEXT = 1,
    VCSFW_STORAGE_PART_EFI = 2,
    VCSFW_STORAGE_PART_DB = 3,
    VCSFW_STORAGE_PART_HOST = 4,
    VCSFW_STORAGE_PART_PRINTCFG = 5,
    VCSFW_STORAGE_PART_BASELINECFG = 6,
    VCSFW_STORAGE_PART_GENERICCFG = 7,
    VCSFW_STORAGE_PART_SYSTEMCFG = 8,
} vcsfw_storage_part_type_t;

/* structure of partition entry */
typedef struct VCS_PACKED vcsfw_storage_part_entry_s {
    vcsUint8_t  id;         /* Partition ID */
    vcsUint8_t  type;       /* Partition Type */
    vcsUint16_t attrb;      /* Partition attributes */
    vcsUint32_t offset;     /* Beginning offset of the partition in bytes */
    vcsUint32_t size;       /* Size of the partition in bytes */
} vcsfw_storage_part_entry_t;

typedef struct VCS_PACKED vcsfw_reply_storage_info_get_s
{
    vcsUint16_t mfgid;          /* Manufacture ID of the Flash */
    vcsUint16_t deviceid;       /* Device ID of the Flash */
    vcsUint16_t blocksize;      /* Block size in bytes */
    vcsUint16_t sectorsize;     /* Erase sector size in blocks */
    vcsUint16_t capacity;       /* Capacity of the flash in blocks */
    vcsUint16_t reservedsize;   /* Reserved space in blocks, including the
                                 sensor security context and partition table */
    vcsUint16_t partitions;     /* Number of partitions */
} vcsfw_reply_storage_info_get_t;
/* The reply is followed by the array of partition entries. */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_PART_FORMAT                                            */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_storage_part_format_s
{
    vcsUint8_t partid;            /* Partition ID of the partition to format */
} vcsfw_cmd_storage_part_format_t;

/* This command erases the flash region occupied by the partition. */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_PART_READ                                              */
/****************************************************************************/
/* COMMAND                                                                  */
/* partition read/write mode */
typedef enum vcsfw_storage_part_rwmode_s {
    VCSFW_STORAGE_PART_DEFAULT = 0, /* depends on the type and attribute
                                       of the partition */
    VCSFW_STORAGE_PART_RAW = 1      /* read/write raw data */
} vcsfw_storage_part_rwmode_t;

typedef struct VCS_PACKED vcsfw_cmd_storage_part_read_s
{
    vcsUint8_t  partid;         /* Partition ID of the partition to format */
    vcsUint8_t  mode;           /* Read mode: 0 - Default, 1 - Raw */
    vcsUint16_t reserved;       /* Unused */
    vcsUint32_t offset;         /* Offset from the beginning of the partition */
    vcsUint32_t size;           /* Number of bytes to read */
} vcsfw_cmd_storage_part_read_t;

/* This command reads data from the specified partition. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_storage_part_read_s
{
    vcsUint32_t datasize;       /* Number of bytes returned */
    vcsUint16_t reserved;       /* reserved bytes for alignment */
} vcsfw_reply_storage_part_read_t;
/*  The reply is followed by the flash data of datasize length. */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_PART_WRITE                                             */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_storage_part_write_s
{
    vcsUint8_t  partid;         /* Partition ID of the partition to format */
    vcsUint8_t  mode;           /* Read mode: 0 - Default, 1 - Raw */
    vcsUint16_t reserved;       /* Unused */
    vcsUint32_t offset;         /* Offset from the beginning of the partition */
    vcsUint32_t size;           /* Number of bytes to write */
} vcsfw_cmd_storage_part_write_t;

/* This command reads data from the specified partition. The command
is followed by the flash writing data. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_storage_part_write_s
{
    vcsUint32_t datasize;     /* Number of bytes written */
} vcsfw_reply_storage_part_write_t;

/****************************************************************************/
/* VCSFW_CMD_STORAGE_FWPART_VALIDATE                                        */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_storage_fwpart_validate_s
{
    vcsUint8_t  partid;     /* Partition ID of the FW Extension partition */
    vcsUint8_t  signtype;   /* Type of signature */
    vcsUint16_t signsize;   /* Size of the signature */
} vcsfw_cmd_storage_fwpart_validate_t;

/* This command validates the data in the FW Extension partition against
the specified RSA signature. The command is followed by the signature
of the FW Extension data. */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_FWPART_INFO_GET                                        */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_storage_fwpart_info_get_s
{
    vcsUint8_t partid;          /* Partition ID of the FW Extension partition */
} vcsfw_cmd_storage_fwpart_info_get_t;

/* This command retrieves the FW Extension partition information. */

/* REPLY                                                                    */
typedef enum vcsfw_storage_module_type_s {
    VCSFW_STORAGE_MODULE_STATIC_FWPATCH = 1,
    VCSFW_STORAGE_MODULE_DYNAMIC_FWPATCH = 2,
    VCSFW_STORAGE_MODULE_FW_EXTENSION = 3
} vcsfw_storage_module_type_t;

typedef struct VCS_PACKED vcsfw_storage_fwpart_module_s
{
    vcsUint16_t type;           /* Type of module */
    vcsUint16_t subtype;        /* Subtype of module
                                For static and dynamic FW patch - patch phase
                                For FW extension - type of extension*/
    vcsUint16_t majorver;       /* Major version of the FW module */
    vcsUint16_t minorver;       /* Minor version of the FW module */
    vcsUint32_t size;           /* Size of the module */
}vcsfw_storage_fwpart_module_t;

typedef struct VCS_PACKED vcsfw_reply_storage_fwpart_info_get_s
{
    vcsUint16_t vmajor;     /* Major version of the FW extension */
    vcsUint16_t vminor;     /* Minor version of the FW extension */
    vcsUint16_t modules;    /* Number of FW modules in the module list */
    vcsUint32_t buildtime;  /* Build time of the FW extension in seconds
                               from 1/1/1970 12:00 AM GMT */
} vcsfw_reply_storage_fwpart_info_get_t;
/*  The reply is followed by the List of FW modules in the extension partition. */

/****************************************************************************/
/* VCSFW_CMD_TLS_HANDSHAKE                                                  */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_tls_handshake_s
{
    vcsUint8_t dummy[3];        /* Added for data alignment. TLS record header
                                *  followed to the command structure has 5 byte
                                *  length. These 3 bytes assure alignment of
                                *  TLS handshake message data followed by record
                                *  header */
} vcsfw_cmd_tls_handshake_t;
/* The command is followed by a packet of TLS messages. */

/* REPLY                                                                    */
/* The replay is a packet of TLS handshake messages with specific format.
* The reply doesn't start with status bytes (vcsfw_generic_reply_t structure).*/


/****************************************************************************/
/* VCSFW_CMD_DB_INFO_GET                                                    */
/****************************************************************************/
/* COMMAND                                                                  */
/* Command uses the vcsfw_generic_command_t structure */

/* This command request template database related information from the sensor. */

/* REPLY                                                                    */
/* structure of user container entry */
typedef struct VCS_PACKED vcsfw_db_user_container_entry_s {
    vcsUint16_t objectid;     /* Object id of the user container */
} vcsfw_db_user_container_entry_t;

typedef struct VCS_PACKED vcsfw_reply_db_info_get_s
{
    vcsUint16_t majorversion; /* Major version of the database */
    vcsUint16_t minorversion; /* Minor version of the database */
    vcsUint32_t attrib;       /* Attribute of the database */
    vcsUint32_t capacity;     /* Capacity of the database in bytes */
    vcsUint32_t usedspace;    /* Space consumed by valid data in bytes */
    vcsUint32_t freespace;    /* Available free space in bytes */
    vcsUint16_t revision;     /* Revision of the database */
                              /* Incremented on every database update */
    vcsUint16_t usercontainers;/* Number of user containers in the database */
} vcsfw_reply_db_info_get_t;
/* The reply is followed by the array of user container entries. */

/****************************************************************************/
/* VCSFW_CMD_DB_OBJECT_INFO_GET                                             */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_object_info_get_s
{
    vcsUint16_t objectid;     /* Object id of the object to retrieve */
} vcsfw_cmd_db_object_info_get_t;

/* This command requests the information of the specifid object. */

/* REPLY                                                                    */
/* dbstorage object attributes */
#define VCSFW_DBSTORAGE_ATTRB_READ      0x0001
#define VCSFW_DBSTORAGE_ATTRB_WRITE     0x0002
#define VCSFW_DBSTORAGE_ATTRB_NO_SECURE 0x0004
#define VCSFW_DBSTORAGE_ATTRB_ENCRYPT   0x0008

/* db object types */
typedef enum vcsfw_db_object_type_s {
    VCSFW_DB_OBJECT_ROOT = 1,
    VCSFW_DB_OBJECT_SYSTEM = 2,
    VCSFW_DB_OBJECT_SYSTEM_PARAM = 3,
    VCSFW_DB_OBJECT_USER_CONTAINER = 4,
    VCSFW_DB_OBJECT_USER = 5,
    VCSFW_DB_OBJECT_TEMPLATE = 6,
    VCSFW_DB_OBJECT_AUTH_DATA = 7,
    VCSFW_DB_OBJECT_GENERIC_DATA = 8,
    VCSFW_DB_OBJECT_GETPRINT_CONFIG = 9,
    VCSFW_DB_OBJECT_FLEX_PARAM = 10,
    VCSFW_DB_OBJECT_EOC_TEMPLATE = 11
} vcsfw_db_object_type_t;

/* structure of object entry */
typedef struct VCS_PACKED vcsfw_db_object_entry_s {
    vcsUint16_t id;     /* object id */
    vcsUint16_t type;   /* object type */
} vcsfw_db_object_entry_t;

/* structure of template object data */
typedef struct VCS_PACKED vcsfw_db_template_object_s {
    vcsUint16_t fingerindex;    /* finger index */
    vcsUint16_t attrib;         /* attribute of the template */
    vcsUint16_t templatesize;   /* size of the template data */
    vcsUint16_t peksize;        /* size of the payload encryption key (PEK) */
} vcsfw_db_template_object_t;
/* The structure is followed by the template data and pek data */

/* tag definition for template data, which contains a list of TLVs */
#define VCSFW_DB_TEMPLATE_OBJECT_TAGID_TEMPLATE 0x0001 /* Template  */
#define VCSFW_DB_TEMPLATE_OBJECT_TAGID_TUID     0x0002 /* Template UID */

/* authentication data types */
typedef enum vcsfw_auth_data_type_e {
    VCSFW_AUTH_DATA_TYPE_PLAIN = 0,
} vcsfw_auth_data_type_t;

/* structure of authentication data object data */
typedef struct VCS_PACKED vcsfw_db_auth_data_object_s {
    vcsUint16_t datatype;   /* type of authentication data */
    vcsUint16_t datasize;   /* size of the authentication data blob */
} vcsfw_db_auth_data_object_t;
/* The structure is followed by the authentication data blob */

/* header of payload data blob inside the auth data. */
typedef struct VCS_PACKED vcsfw_db_auth_data_payload_header_s {
    vcsUint16_t datatype;    /* type of authentication data */
    vcsUint16_t payloadsize;
    vcsUint16_t flags;       /* Various flags. User to control the use of
                              * the payload. */
    vcsUint8_t  usused[2];   /* For making data 4-byte aligned. */
} vcsfw_db_auth_data_payload_header_t;
/* followed by the payload, padding optionally and encryption IV */

/* The extended version of the same structure with a binder to UUID. */
typedef struct VCS_PACKED vcsfw_db_auth_data_payload_header_ex_s {
    vcsUint16_t datatype;    /* type of authentication data */
    vcsUint16_t uuidsize;    /* The UUID size. */
    vcsUint16_t payloadsize; /* The payload size. */
    vcsUint16_t paddingsize; /* Various flags. User to control the use of
                              * the payload. */
} vcsfw_db_auth_data_payload_header_ex_t;
/* Followed by "uuidsize" bytes of UUID data. */
/* Followed by "payloadsize" bytes of payload data. */
/* Followed by "paddingsize" bytes of padding bytes. */

/* structure of generic data object data */
typedef struct VCS_PACKED vcsfw_db_generic_data_object_s {
    vcsUint16_t datatype;   /* type of generic data */
    vcsUint16_t datasize;   /* size of the generic data blob */
} vcsfw_db_generic_data_object_t;
/* The structure is followed by the generic data blob */

typedef struct VCS_PACKED vcsfw_reply_db_object_info_get_s
{
    vcsUint16_t id;     /* object id */
    vcsUint16_t type;   /* object type */
    vcsUint16_t attrib; /* object attributes */
    vcsUint16_t size;   /* size of the object data in bytes */
    vcsUint32_t nchild; /* number of child object */
} vcsfw_reply_db_object_info_get_t;
/* The reply is followed by the array of object entries of each child. */

/****************************************************************************/
/* VCSFW_CMD_DB_OBJECT_CREATE                                               */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_object_create_s
{
    vcsUint16_t parentid;   /* Object id of the parent object */
    vcsUint16_t type;       /* object type */
    vcsUint16_t attrib;     /* attribute of the object */
    vcsUint16_t size;       /* size of the object data in bytes */
} vcsfw_cmd_db_object_create_t;
/* The command is followed by the object data */

/* This command creates a new object in the template database. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_db_object_create_s
{
    vcsUint16_t objectid;   /* object id assigned */
} vcsfw_reply_db_object_create_t;

/****************************************************************************/
/* VCSFW_CMD_DB_OBJECT_DELETE                                               */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_object_delete_s
{
    vcsUint16_t objectid;   /* Object id of the object */
} vcsfw_cmd_db_object_delete_t;

/* This command deletes the specified object from the template database. */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_DB_OBJECT_DATA_GET                                             */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_object_data_get_s
{
    vcsUint16_t objectid;   /* Object id of the object */
} vcsfw_cmd_db_object_data_get_t;

/* This command retrieve the object data of the specified object. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_db_object_data_get_s
{
    vcsUint16_t objectid;   /* object id */
    vcsUint16_t type;       /* object type */
    vcsUint16_t attrib;     /* object attributes */
    vcsUint16_t size;       /* size of the object in bytes */
    vcsUint16_t reserved;   /* reserved bytes for alignment */
} vcsfw_reply_db_object_data_get_t;
/* The reply is followed by the object data.
 * See the structures under VCSFW_CMD_DB_OBJECT_INFO_GET for object types. */

/****************************************************************************/
/* VCSFW_CMD_DB_USER_INFO_GET                                               */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_user_info_get_s
{
    vcsUint16_t objectid;   /* Object id of the user object */
    vcsUint16_t usercontid; /* Object id of the user container object */
    vcsUint16_t uuidsize;   /* size of the UUID data follow */
} vcsfw_cmd_db_user_info_get_t;
/* The command is followed by the UUID data */

/* This command retrieve the user infor of the specified user.
   If objectid is not specified, user will be located using the UUID. */

/* REPLY                                                                    */
/* structure of template entry */
typedef struct VCS_PACKED vcsfw_db_template_entry_s {
    vcsUint16_t objectid;    /* object id */
    vcsUint16_t fingerindex; /* finger index */
    vcsUint16_t attrib;      /* attribute */
    vcsUint16_t size;        /* size of the template data */
} vcsfw_db_template_entry_t;

/* structure of user data entry */
typedef struct VCS_PACKED vcsfw_db_user_data_entry_s {
    vcsUint16_t objectid;    /* object id */
    vcsUint16_t datatype;    /* type of user data */
    vcsUint16_t size;        /* size of the data blob */
    vcsUint16_t reserved;    /* reserved */
} vcsfw_db_user_data_entry_t;

typedef struct VCS_PACKED vcsfw_reply_db_user_info_get_s
{
    vcsUint16_t objectid;   /* object id */
    vcsUint16_t templates;  /* number of templates enrolled by the user */
    vcsUint16_t objects;    /* number of data objects owned by the user */
    vcsUint16_t uuidsize;   /* size of UUID in bytes */
} vcsfw_reply_db_user_info_get_t;
/* The reply is followed by the array of template entries followed by
   the array of data object entries, and followed by the UUID data */

/****************************************************************************/
/* VCSFW_CMD_DB_USER_CONTAINER_INFO_GET                                     */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_user_container_info_get_s
{
    vcsUint16_t objectid;   /* Object id of the user container object */
    vcsUint16_t ucuidsize; /* size of the UCUID data follow */
} vcsfw_cmd_db_user_container_info_get_t;
/* The command is followed by the UCUID data */

/* This command retrieve the user container info of the specified user container.
If objectid is not specified, user will be located using the UCUID. */

/* REPLY                                                                    */
/* structure of template entry */
typedef struct VCS_PACKED vcsfw_db_user_entry_s {
    vcsUint16_t objectid;    /* object id */
    vcsUint16_t size;        /* size of the user data */
} vcsfw_db_user_entry_t;

typedef struct VCS_PACKED vcsfw_reply_db_user_container_info_get_s
{
    vcsUint16_t objectid;   /* object id */
    vcsUint16_t users;      /* number of users */
    vcsUint16_t ucuidsize;  /* size of UCUID in bytes */
    vcsUint16_t reserved;   /* for data alignment */
} vcsfw_reply_db_user_container_info_get_t;
/* The reply is followed by the array of user entries
and followed by the UCUID data */

/****************************************************************************/
/* VCSFW_CMD_DB_OBJECT_RESTORE                                              */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_object_restore_s
{
    vcsUint32_t size;       /* size of data to restore */
    vcsUint16_t parentid;   /* Object id of the parent object */
    vcsUint16_t reserved;   /* reserved */
} vcsfw_cmd_db_object_restore_t;
/* The command is followed by the data to restore */

/* This command restores the object and all its children under the parent object specified. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_db_object_restore_s
{
    vcsUint16_t objectid;   /* object id assigned */
} vcsfw_reply_db_object_restore_t;

/****************************************************************************/
/* VCSFW_CMD_DB_SYSTEM_PARAM_GET                                            */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_system_param_get_s
{
    vcsUint16_t namesize;   /* size of the parameter name in bytes */
} vcsfw_cmd_db_system_param_get_t;
/* The command is followed by the parameter name string. */

/* This command retrieves the specified system parameter from the system
** parameter object. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_db_system_param_get_s
{
    vcsUint16_t datasize;   /* size of the parameter value in bytes */
} vcsfw_reply_db_system_param_get_t;
/* The reply is followed by the parameter value string */

/****************************************************************************/
/* VCSFW_CMD_DB_SYSTEM_PARAM_SET                                            */
/****************************************************************************/
/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_db_system_param_set_s
{
    vcsUint16_t namesize;   /* size of the parameter name in bytes */
    vcsUint16_t valuesize;  /* size of the parameter value in bytes */
} vcsfw_cmd_db_system_param_set_t;
/* The command is followed by the parameter name and value string. */

/* This command set the specified system parameter to the new value. If the
   parameter already exists, the current value will be deleted. */

/* REPLY                                                                    */
/* Reply uses the vcsfw_generic_reply_t structure   */

/****************************************************************************/
/* VCSFW_CMD_TAKE_OWNERSHIP_EX2                                             */
/****************************************************************************/
/* COMMAND                                                                  */

/*
 * The command consists of a set of sections in the form
 *  {tag, length, data} blobs.
 */
typedef struct VCS_PACKED vcsfw_cmd_takeownex2_section_s
{
    vcsUint16_t tag;
    vcsUint16_t length;
} vcsfw_cmd_takeownex2_section_t;

/* Definitions for "flags" field in below structure. */
#define VCSFW_TAKEOWNEX2_FLAGS_ECC      0x01  /* ECC-based ownership.
                                              ** RSA-based, if not set. */
#define VCSFW_TAKEOWNEX2_FLAGS_CISSCEK  0x02  /* SSCEK should be taken from
                                              ** OTPROM in final form. */
#define VCSFW_TAKEOWNEX2_FLAGS_CIOS     0x04  /* Customer-injected seed is
                                              ** provided. */

/* The command structure. */
typedef struct VCS_PACKED vcsfw_cmd_take_ownership_ex2_s
{
    vcsUint8_t                      flags;         /* Flags, options.     */
    vcsUint8_t                      reserved[3];   /* For data alignment. */
} vcsfw_cmd_take_ownership_ex2_t;
/* Followed by the set of vcsfw_cmd_takeownex2_section_t sections. */

/* Some definitions and types regarding command. */

/* Section tags: */
#define VCSFW_TAKEOWN_TAG_FLASHINFO  0x0000 /* General flash information.     */
#define VCSFW_TAKEOWN_TAG_PART_TABLE 0x0001 /* Flash partition table image.   */
#define VCSFW_TAKEOWN_TAG_CI_SYMK    0x0002 /* CI symmetric key/key material. */
#define VCSFW_TAKEOWN_TAG_EC         0x0003 /* Elliptic Curve parameters.     */
#define VCSFW_TAKEOWN_TAG_CI_PK      0x0004 /* CI public key (RSA or ECC)     */
#define VCSFW_TAKEOWN_TAG_HAPUBK     0x0005 /* HAPubK - RSA or ECC            */

/* Common definitions */

/* Maximal length of ECC parameter, multiple to 4 bytes.
** For 521bit ECC it will be 68 bytes. */
#define VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN     68

/* Structures defining data structure of each section. The length of all
** structures are multiple to 4. NOTE: All arrays presenting large integers,
** e.g. RSA private exponent, modulus, coordinates of Elliptic Curve points
** are in little endian byte order.
** RSA key length is fixed to 2048 bit. Public exponent is fixed to 0x10001.  */

/* VCSFW_TAKEOWN_TAG_FLASHINFO: General flash information. */
typedef struct VCS_PACKED vcsfw_takeown_data_flashinfo_s {
    vcsUint32_t flash_size;
    vcsUint32_t erasable_unit_size;
    vcsUint16_t dummy;
    vcsUint8_t  erase_cmd_id;
    vcsUint8_t  read_mode;
} vcsfw_takeown_data_flashinfo_t;

/* VCSFW_TAKEOWN_TAG_PART_TABLE: Flash partition table image. */
/* Continuous data blob of multiple to 48 byte length, where
** 48 is the length of partition table entry.              */

/* VCSFW_TAKEOWN_TAG_CI_SYMK: Customer-Injected Key / Seed */
typedef struct VCS_PACKED vcsfw_takeown_data_symk_s {
    vcsUint8_t cios[VCSFW_SHA256_HASH_SIZE];
    vcsUint8_t cik[VCSFW_SHA256_HASH_SIZE];
} vcsfw_takeown_data_symk_t;

/* VCSFW_TAKEOWN_TAG_EC: Elliptic Curve parameters. */
typedef struct VCS_PACKED vcsfw_takeown_data_ec_s {
    vcsUint32_t iana_id;                              /* Curve IANA ID        */
    vcsUint32_t strength;                             /* Strength in bits     */
    vcsUint32_t h;                                    /* Cofactor             */
    vcsUint8_t  a[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];   /* Coefficient 'a'      */
    vcsUint8_t  b[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];   /* Coefficient 'b'      */
    vcsUint8_t  g_x[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN]; /* X coordinate of BP   */
    vcsUint8_t  g_y[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN]; /* Y coordinate of BP   */
    vcsUint8_t  n[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];   /* Order                */
    vcsUint8_t  p[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];   /* Prime 'P'            */
} vcsfw_takeown_data_ec_t;

/* VCSFW_TAKEOWN_TAG_HAPUBK: RSA */
typedef struct VCS_PACKED vcsfw_takeown_data_pubk_rsa_s {
    vcsUint32_t keylen;
    vcsUint8_t  modulus[VCSFW_MAX_RSA_KEY_LENGTH];
    vcsUint8_t  signature[VCSFW_SHA256_HASH_SIZE];
} vcsfw_takeown_data_pubk_rsa_t;
typedef vcsfw_takeown_data_pubk_rsa_t vcsfw_tls_rsa_pubk_t;

/* VCSFW_TAKEOWN_TAG_HAPUBK: ECC */
/* Affine point in unpacked form. */
typedef struct VCS_PACKED vcsfw_takeown_data_pubk_ecc_s {
    vcsUint32_t iana_id;
    vcsUint32_t keylen;
    vcsUint8_t  x[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
    vcsUint8_t  y[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
    vcsUint8_t  padding[8];
    vcsUint8_t  signature[VCSFW_SHA256_HASH_SIZE];
} vcsfw_takeown_data_pubk_ecc_t;
typedef vcsfw_takeown_data_pubk_ecc_t vcsfw_tls_ecc_pubk_t;

/* ECC Signature block coming after. It can hold an RSA or ECC signature. */
typedef struct VCS_PACKED vcsfw_takeown_data_pubk_signature_s {
    vcsUint32_t sign_len;
    vcsUint8_t  signature[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_takeown_data_pubk_signature_t;

/* VCSFW_TAKEOWN_TAG_CI_PK: PrivK/SPubK - RSA */
typedef struct VCS_PACKED vcsfw_takeown_data_ci_pk_rsa_s {
    vcsfw_takeown_data_pubk_rsa_t pubk;
    vcsUint8_t                    priv_exp[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_takeown_data_ci_pk_rsa_t;

/* SEPrivK/SEPubK - ECC */
typedef struct VCS_PACKED vcsfw_takeown_data_ci_pk_ecc_s {
    vcsfw_takeown_data_pubk_ecc_t pubk;
    vcsUint8_t                    privk[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
} vcsfw_takeown_data_ci_pk_ecc_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_take_ownership_ex2_s
{
    vcsUint32_t    length;
    union _hapubk_signed {
        vcsfw_takeown_data_pubk_rsa_t  rsa_pk; /* 256 bytes - 2048 bit key */
        vcsfw_takeown_data_pubk_ecc_t  ecc_pk; /* 140 bytes - 521  bit key  */
    } hapubk_signed;  /* Signed with SSSK */
} vcsfw_reply_take_ownership_ex2_t;

/****************************************************************************/
/* VCSFW_CMD_GET_CERTIFICATE_EX                                             */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */

/* Certificate structures. */
typedef struct VCS_PACKED vcsfw_rsa_certificate_s
{
    vcsUint32_t keylen;                                       /* In bytes   */
    vcsUint32_t pub_exp;
    vcsUint8_t  modulus[VCSFW_MAX_RSA_KEY_LENGTH];            /* Public key */
    vcsUint8_t  sign[VCSFW_MAX_RSA_KEY_LENGTH];               /* RSA sign   */
} vcsfw_rsa_certificate_t;

typedef struct VCS_PACKED vcsfw_ecc_certificate_s
{
    vcsUint32_t keylen;                                        /* In bytes.  */
    vcsUint32_t curve_iana_id;                                 /* Curve ID   */
    vcsUint8_t  x[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];            /* Public key */
    vcsUint8_t  y[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
    vcsUint8_t  sign[VCSFW_MAX_RSA_KEY_LENGTH];                /* RSA sign */
} vcsfw_ecc_certificate_t;

/* The reply structure. */
typedef struct VCS_PACKED vcsfw_reply_get_certificate_ex_s
{
    vcsUint32_t             reply_length;
    vcsfw_rsa_certificate_t rsa_cert;
    vcsfw_ecc_certificate_t ecc_cert;
} vcsfw_reply_get_certificate_ex_t;


/****************************************************************************/
/* VCSFW_CMD_READ_FPDATA                                                    */
/****************************************************************************/

/* header of the fpdata returned */
typedef struct vcsfw_fpdata_header_s
{
    vcsUint16_t rows;       /* number of rows in the fingerprint */
    vcsUint16_t cols;       /* number of columns in the fingerprint */
    vcsUint16_t dpi;        /* resolution in dpi */
    vcsUint8_t  bitdepth;   /* bits per pixel */
    vcsUint8_t  reserved;
    vcsUint32_t quality;    /* quality flags */
} vcsfw_fpdata_header_t;

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_read_fpdata_s
{
    vcsUint32_t bufsize;    /* host buffer size */
} vcsfw_cmd_read_fpdata_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_read_fpdata_s
{
    vcsUint32_t datasize;   /* amount of data returned */
} vcsfw_reply_read_fpdata_t;
/* The reply is followed by the fingerprint data */

/****************************************************************************/
/* VCSFW_CMD_FLUSH_FPDATA                                                   */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_SSL_FAST_RECOVERY                                              */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_ssl_frec_s
{
    vcsUint8_t randoms[32];
    vcsUint8_t iv[16];
    vcsUint8_t master_secret[48];
    vcsUint8_t write_seq_num[8];
    vcsUint8_t read_seq_num[8];
    vcsUint8_t key_block[136];
    vcsUint16_t cipher_id;
    vcsUint8_t pad[6];
} vcsfw_cmd_ssl_frec_t;

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_TIDLE_SET                                                      */
/****************************************************************************/
/* COMMAND                                                                  */

typedef struct VCS_PACKED vcsfw_cmd_tidle_set_s
{
    /* time (in units of 80 us) to wait without seeing a command before it
     * drops into sleep mode. If idletime is 0, sensor never goes to sleep */
    vcsUint16_t  idletime;
    /*
     * The following 16-bit word is *optional*, and it represents
     *  the high 16-bits of a 32-bit idle time (in units of 80 us).
     * If it is not present then it is effectively assumed to have
     *  a zero value.
     */
    vcsUint16_t  idletime_msw;
} vcsfw_cmd_tidle_set_t;

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_SLEEP                                                          */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */


/****************************************************************************/
/* VCSFW_CMD_GET_PATCHINFO                                                  */
/****************************************************************************/
/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
/*
 * The reply consists of the standard 16-bit status code followed by
 *  an array of 0 or more of the following structures.
 */

typedef struct VCS_PACKED vcsfw_reply_get_patchinfo_item_s
{
    vcsUint32_t          basep;
    vcsUint32_t          size;
    vcsUint32_t          flags;
    vcsUint32_t          buildtime;
    vcsUint32_t          sig;        /* signature */
    vcsUint16_t          buildnum;
    vcsUint8_t           majorver;
    vcsUint8_t           minorver;
} vcsfw_reply_get_patchinfo_item_t;

/*
 * vcsfw_reply_get_patchinfo_item_t::flags is a bitfield
 *  with the following:
 */

#define VCSFW_REPLY_GET_PATCHINFO_ITEM_FLAGS_UNLOADABLE     0x00000001

/****************************************************************************/
/* VCSFW_CMD_GLOBAL_KEY_GEN                                                 */
/****************************************************************************/

/* Key generation operation IDs */
#define VCSFW_CMD_GLOBAL_KEYGEN_VCEKIV_SSPRIVK      0
#define VCSFW_CMD_GLOBAL_KEYGEN_SYM                 1
#define VCSFW_CMD_GLOBAL_KEYGEN_RSA                 2
#define VCSFW_CMD_GLOBAL_KEYGEN_ECC                 3

/* Operation parameters/reply for VCSFW_CMD_GLOBAL_KEYGEN_VCEKIV_SSPRIVK. */
typedef struct VCS_PACKED vcsfw_cmd_global_key_gen_vcekiv_s
{
    vcsUint8_t vpubk[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_cmd_global_key_gen_vcekiv_t;

typedef struct VCS_PACKED vcsfw_reply_global_key_gen_vcekiv_s
{
    vcsUint8_t unused[2];
    vcsUint8_t vcekiv_vcekiv0[VCSFW_SHA256_HASH_SIZE*2+16];
                                      /* AES256 key + AES_BLOCK_SIZE + SHA256 */
    vcsUint8_t vcekiv_vpubk[VCSFW_MAX_RSA_KEY_LENGTH];
    vcsUint8_t ssprivk_vcekiv[VCSFW_MAX_RSA_KEY_LENGTH];
    vcsUint8_t sspubk_plain[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_reply_global_key_gen_vcekiv_t;

/* Operation parameters/reply for VCSFW_CMD_GLOBAL_KEYGEN_SYM. */
typedef struct VCS_PACKED vcsfw_cmd_global_key_gen_sym_s
{
    vcsUint32_t keylen;
    vcsUint8_t  vpubk[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_cmd_global_key_gen_sym_t;

typedef struct VCS_PACKED vcsfw_reply_global_key_gen_sym_s
{
    vcsUint16_t datalen;               /* Length of data in symk_vcekiv. */
    vcsUint8_t  symk_vcekiv[VCSFW_SHA256_HASH_SIZE*3];
                                         /* Max 64 byte key + SHA256 */
    vcsUint8_t symk_vpubk[VCSFW_MAX_RSA_KEY_LENGTH];
} vcsfw_reply_global_key_gen_sym_t;

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_global_key_gen_s
{
    vcsUint16_t  opid;   /* The operation ID. */
    vcsUint16_t  unused; /* To make 'operation' 4-byte aligned for Metallica. */
    union
    {
        vcsfw_cmd_global_key_gen_vcekiv_t   vcekiv_ssprivk;
        vcsfw_cmd_global_key_gen_sym_t      sym;
    } operation;
} vcsfw_cmd_global_key_gen_t;

/* REPLY                                                                  */
typedef union VCS_PACKED vcsfw_reply_global_key_gen_s
{
    vcsfw_reply_global_key_gen_vcekiv_t   vcekiv_ssprivk;
    vcsfw_reply_global_key_gen_sym_t      sym;
} vcsfw_reply_global_key_gen_t;

/****************************************************************************/
/* VCSFW_CMD_GET_NAV_STATUS                                                 */
/****************************************************************************/

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_nav_status_s
{
    vcsUint8_t      status; /* finger status */
    vcsInt16_t      delta_x;
    vcsInt16_t      delta_y;
    vcsUint16_t     timestamp;
} vcsfw_reply_get_nav_status_t;

/****************************************************************************/
/* VCSFW_CMD_AUTH_SESSION_START                                             */
/****************************************************************************/

/* Definitions for auth_type field. */
#define VCSFW_AUTH_SESSION_TYPE_NOOP    0x00 /* Only load the auth module.  */
#define VCSFW_AUTH_SESSION_TYPE_SM      0x01 /* Secure Match.               */
#define VCSFW_AUTH_SESSION_TYPE_MOC     0x02 /* Match On Chip.              */
#define VCSFW_AUTH_SESSION_TYPE_POA     0x03 /* Power-On Authentication.    */
#define VCSFW_AUTH_SESSION_TYPE_WOFC    0x04 /* Low power WOF capture       */

/* Additional data in command strcture is in TLV format.
 * 2-byte tagid, 2 byte len, data.
 * Data has specific format for each tag. */
#define VCSFW_AUTH_ADDDATA_TAGID_MATCH_THRESHOLD                         0x0000
#define VCSFW_AUTH_ADDDATA_TAGID_WOFCFG                                  0x0001
#define VCSFW_AUTH_ADDDATA_TAGID_TEMPLATE_OBJIDS                         0x0002

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_auth_session_start_s
{
    vcsUint8_t  auth_type;     /* Authentication type: SM, MOC, POA, etc.   */
    vcsUint8_t  timeout;       /* Session timeout in seconds.               */
    vcsUint16_t uc_objid;      /* User object container ID.                 */
    vcsUint16_t usr_objid;     /* User object ID.                           */
    vcsUint16_t auth_datatype; /* Aka Authentication algorithm ID - AlgID.  */
    vcsUint32_t add_datalen;   /* Additional data length. This may be required
                                * for POA mode. Data will be appended to the
                                * command structure.                        */
} vcsfw_cmd_auth_session_start_t;
/* Optionally followed by {additional data}. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_auth_session_start_s
{
    vcsUint32_t sessionid;     /* Session ID. */
} vcsfw_reply_auth_session_start_t;

/****************************************************************************/
/* VCSFW_CMD_AUTH_SESSION_STATUS_GET                                        */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_auth_session_status_get_s
{
    vcsUint32_t  sessionid;     /* Session ID. */
} vcsfw_cmd_auth_session_status_get_t;

/* Session statuses, returned by the sensor through the reply of current
 * command or EP3. */
#define VCSFW_AUTH_SESSION_STATE_IDLE            0 /* Nothing is going on.    */
#define VCSFW_AUTH_SESSION_STATE_IMG_PROCESSING  1 /* Feature Extraction from
                                                    * the swipe image.        */
#define VCSFW_AUTH_SESSION_STATE_MATCHING        2 /* Matching with DB
                                                    * templates               */
                       /* Will be followed by the count of matched templates. */
#define VCSFW_AUTH_SESSION_STATE_IDENTIFIED      3 /* Identified.             */
#define VCSFW_AUTH_SESSION_STATE_NOT_IDENTIFIED  4 /* Not identified.         */
#define VCSFW_AUTH_SESSION_STATE_FAILED          5 /* Unexpected error.       */
                              /* Will be followed by the VCSFW V4 error code. */
#define VCSFW_AUTH_SESSION_STATE_TIMED_OUT       6 /* Session timed out.      */
#define VCSFW_AUTH_SESSION_STATE_IMAGE_CAPTURED  7 /* Image captured successfully */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_auth_session_status_get_s
{
    vcsUint16_t session_status; /* Current status. */
    vcsUint16_t param;          /* Additional information - e.g.
                                 * + count of matched templates in
                                 *   VCSFW_AUTH_SESSION_STATE_MATCHING state.
                                 * + VCSFW V4 error code in
                                 *   VCSFW_AUTH_SESSION_STATE_FAILED state.   */
    vcsUint8_t  reserved;       /* Reserved byte, to make the reply size
                                 * equal to EP3 message size, because the same
                                 * reply is communicated through the EP3 too. */
} vcsfw_reply_auth_session_status_get_t;

/* Optionally it may be followed by the statistical informaiton collected
 * during POA. vcsfw_reply_auth_session_status_get_t::reserved will contain
 * data size in that case, instead of 0xdb */
typedef struct VCS_PACKED vcsfw_moc_stat_info_s
{
    vcsUint16_t truly_triggered;             /* Truely triggered.             */
    vcsUint16_t false_triggered;             /* False triggered.              */
    vcsUint16_t bad_images;                  /* Bad image and other problems. */
    vcsUint16_t min_capture_time;            /* Min capture time (ms)         */
    vcsUint16_t max_capture_time;            /* Max capture time (ms)         */
    vcsUint16_t min_auth_time;               /* Min auth time (ms)            */
    vcsUint16_t max_auth_time;               /* Max auth time (ms)            */
    vcsUint16_t reserved;                    /* Reserved                      */
} vcsfw_moc_stat_info_t;


/****************************************************************************/
/* VCSFW_CMD_AUTH_SESSION_RESULT_GET                                        */
/****************************************************************************/

#define VCSFW_TUID_SIZE                         32

/* TLV header structure. */
typedef struct VCS_PACKED vcsfw_tlv_hdr_s
{
    vcsUint16_t  tagid;     /* Tag ID                                    */
    vcsUint16_t  length;    /* Data length coming after the header.      */
} vcsfw_tlv_hdr_t;

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_auth_session_result_get_s
{
    vcsUint32_t sessionid;     /* Session ID. */
} vcsfw_cmd_auth_session_result_get_t;

/* REPLY (obsolete)                                                         */
typedef struct VCS_PACKED vcsfw_reply_auth_session_result_get_s
{
    vcsUint32_t usr_objid;       /* Identified user object ID.    */
    vcsUint32_t score;           /* Match score.                  */
    vcsUint32_t matcher_retcode; /* Matcher return code.          */
    vcsUint32_t pek_size;        /* PEK is appended to the reply. */
    vcsUint16_t template_index;  /* Matched template index.       */
    vcsUint16_t finger_index;    /* Matched finger index.         */
} vcsfw_reply_auth_session_result_get_t;
/* Followed by {PEK} data. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_auth_session_result_get_ex_s
{
    vcsUint16_t data_size;       /* Size of data to follow   */
} vcsfw_reply_auth_session_result_get_ex_t;
/* The structure is followed by data in a TLV list */

/* Tag IDs for reply data following vcsfw_reply_auth_session_result_get_ex_t */
#define VCSFW_AUTH_SESSION_RESULT_TAGID_USER_OBJID          0x0001
    /* Identified user object ID of type vcsUint32_t              */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_SCORE               0x0002
    /* Match score of type vcsUint32_t                            */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_FINGER_INDEX        0x0003
    /* Matched finger index of type vcsUint16_t                   */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_TUID                0x0004
    /* Matched template UID of size VCSFW_TUID_SIZE               */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_PEK                 0x0005
    /* PEK of type vcsUint32_t                                    */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_DBG_INFO            0x0006
    /* Debug info of type vcsfw_session_status_dbg_info_t         */

#define VCSFW_AUTH_SESSION_RESULT_TAGID_TIME_INFO           0x0007
    /* Time Statistics of type vcsfw_session_status_timing_info_s */
typedef struct VCS_PACKED vcsfw_session_status_timing_info_s
{
    vcsUint32_t  feature_extraction;
    vcsUint32_t  template_import;
    vcsUint32_t  matching;
    vcsUint32_t  selected_operation;
} vcsfw_session_status_timing_info_t;

#define VCSFW_AUTH_SESSION_RESULT_TAGID_TEMPLATE_OBJID      0x0008
    /* Identified template object ID of type vcsUint16_t          */

/****************************************************************************/
/* VCSFW_CMD_AUTH_SESSION_DATA_GET                                          */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_auth_session_data_get_s
{
    vcsUint32_t sessionid;      /* Session ID. */
    vcsUint16_t auth_datatype;  /* aka Authentication algorithm ID - AlgID.  */
    vcsUint16_t param_datasize; /* Param data is appended to the command. This
                                 * can be a "Challange" data in case of
                                 * Challenge-Response authentication. */
} vcsfw_cmd_auth_session_data_get_t;
/* Folowed by {param_data}. */

/* REPLY                                                                  */
typedef struct VCS_PACKED vcsfw_reply_auth_session_data_get_s
{
    vcsUint16_t auth_datasize;  /* Authentication data size (payload/token).
                                 * The data is  appended to the reply. */
} vcsfw_reply_auth_session_data_get_t;
/* Followed by the {auth_data}. */

/* Data structures for authentication results. */

/* Fingerprint ID. The identifier returned after successful identification. */
typedef struct VCS_PACKED vcsfw_auth_session_data_fid_s
{
    vcsUint8_t userid[16];       /* Unique identifier for the group of templates
                                  * (user ID). */
    vcsUint8_t enrollid[15];     /* Unique identifier for matched enrollment
                                  * (template). */
    vcsUint8_t finger_index;     /* Index of matched finger. */
} vcsfw_auth_session_data_fid_t;

/* Auth data in case of VCSFW_AUTH_ALGID_PKCR algid. */
typedef struct VCS_PACKED vcsfw_auth_session_data_alg_pkcr_s
{
    vcsfw_auth_session_data_fid_t       id;
    vcsUint32_t                         signature_size;
} vcsfw_auth_session_data_alg_pkcr_t;
/* Folowed by "signature_size" bytes of signature data.
 * ECDSA signature in DER, ASN.1 format or
 * RSA signature. Data is always in little endian byte format.
 */

/****************************************************************************/
/* VCSFW_CMD_AUTH_SESSION_FINISH                                            */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_auth_session_finish_s
{
    vcsUint32_t sessionid;      /* Session ID. */
} vcsfw_cmd_auth_session_finish_t;

/* REPLY                                                                    */
/* vcsfw_generic_reply_t structure is used. */

/****************************************************************************/
/* VCSFW_CMD_CAL_WOF2 Calibration of WOE_WOF2 */
/****************************************************************************/
/* VCSFW_CMD_CAL_WOF2 structure */
typedef struct VCS_PACKED vcsfw_cmd_cal_wof2_s
{
    vcsUint16_t max_replysize; /* Maximum bytes in reply, based on params */
    vcsUint8_t  max_gain;      /* Highest gain allowed */
    vcsUint8_t  min_gain;      /* Lowest gain allowed */
    vcsUint8_t  start_gain;    /* Starting gain */
    vcsUint8_t  step_gain;     /* Step size for gain */
    vcsUint8_t  max_thresh;    /* Highest threshold allowed */
    vcsUint8_t  min_thresh;    /* Lowest threshold allowed (> 0) */
    vcsUint8_t  polltime;      /* Wake-on-Timer definition (ms) */
    vcsUint8_t  debug;         /* Verbose reply with debug data */
    vcsUint8_t  reserved[2];   /* Padding */
    /*-------- NOTE: equivalent to vcsfw_param_wof2_t -------------- */
    vcsUint32_t wof2_ctrl2;    /* WOE_WOF2_CTRL2 register  */
    vcsUint32_t wof2_thresh;   /* WOE_WOF2_THRESH register */
    vcsUint16_t wof2_ctrl1;    /* WOE_WOF2_CTRL1 register  */
    vcsUint16_t wof2_cfg_size; /* Number of bytes of cfg data follow */
} vcsfw_cmd_cal_wof2_t;
    /* (followed by vcsfw_param_wof2_config_t + binary data) */
    /*-------- NOTE: Maintain equivalence to vcsfw_param_wof2_t ---- */

/* VCSFW_CMD_CAL_WOF2 Reply data format:
   Bytecount is divisible by 4.
   Byte  Description
   ----  -----------
   0:3   WOE_EVENT Register value
   4:7   WOE_WOF2_STATUS Register value
   8     Current calibration state (start of sweep or end of cal)
   9     Current gain
   10    Current threshold
   11    Reserved
   12:X  Repeat values as in bytes 0:11, for each sweep iteration
   X+1   Final WOE_EVENT Register value
   X+2   Final calibration state
   X+3   Gain result, or current gain if status is non-zero
   X+4   Threshold result, or current threshold if status is non-zero */

/* VCSFW_CMD_CAL_WOF2_V3 Reply data format:
Debug mode: Same as VCSFW_CMD_CAL_WOF2 reply, but use with 1 zone only.
Non-debug mode:
   Bytecount is divisible by 4.
   Byte  Description
   ----  -----------
   0:3   WOE_EVENT Register value, zone 0
   4:7   WOE_WOF2_STATUS Register value, zone 0
   8     Current calibration state (start of sweep or end of cal), zone 0
   9     Current gain, zone 0
   10    Current threshold, zone 0
   11    Reserved
   12:15 WOE_EVENT Register value, zone 1
   16:19 WOE_WOF2_STATUS Register value, zone 1
   20    Current calibration state (start of sweep or end of cal), zone 1
   21    Current gain, zone 1
   22    Current threshold, zone 1
   23    Reserved
NOTE: If only 1 zone is calibrated, the other zone's data will be 0. */
typedef struct vcsfw_cal_wof2_status_s {
    vcsUint32_t event_status;  /* WOE_EVENT register value */
    vcsUint32_t wof2_status;   /* WOE_WOF2_STATUS register value */
    vcsUint8_t current_state;  /* Calibration current state */
    vcsUint8_t current_gain;   /* Gain register field value */
    vcsUint8_t current_thresh; /* Threshold register field value */
    vcsUint8_t count;          /* Calibration iteration count */
} vcsfw_cal_wof2_status_t;

/* Reply data format: */
typedef struct vcsfw_reply_cal_wof2_s
{
    vcsUint32_t   bytes;   /* Number of status bytes returned */
    /* This is followed by the calibration status data. */
} vcsfw_reply_cal_wof2_t;

/****************************************************************************/
/* VCSFW_CMD_CAL_STATUS_GET Retrieve calibration status */
/****************************************************************************/
typedef struct vcsfw_reply_cal_status_s
{
    vcsUint32_t   bytes;   /* Number of status bytes returned */
    /* This is followed by the calibration status data. */
    /* Instance of vcsfw_cal_wof2_status_t for finger-down calibration */
    /* (Optional) Instance of vcsfw_cal_wof2_status_t for finger-up calibration */
} vcsfw_reply_cal_status_t;

/****************************************************************************/
/* VCSFW_CMD_ENROLL_SESSION_START                                           */
/****************************************************************************/

/* Definitions for 'flags' field. */
#define VCSFW_CMD_ENROLL_SESSION_ASP       0x01             /* Enable ASP. */

/* COMMAND                                                                 */
typedef struct VCS_PACKED vcsfw_cmd_enroll_session_start_s
{
    vcsUint32_t    sessionid;             /* 0 for new session, session ID
                                            * for session restore.         */
    vcsUint8_t     flags;
    vcsUint8_t     reserved[3];
} vcsfw_cmd_enroll_session_start_t;

/* REPLY                                                                   */
typedef struct VCS_PACKED vcsfw_reply_enroll_session_start_s
{
    vcsUint32_t sessionid;                 /* Session ID.                  */
} vcsfw_reply_enroll_session_start_t;

/****************************************************************************/
/* VCSFW_CMD_ENROLL_SESSION_FINISH                                          */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_enroll_session_finish_s
{
    vcsBool_t session_ctx_erase;
} vcsfw_cmd_enroll_session_finish_t;

/* REPLY                                                                    */
/* Generic reply. */

/****************************************************************************/
/* VCSFW_CMD_ENROLL_SESSION_STATUS_GET                                      */
/****************************************************************************/

/* COMMAND                                                                  */
/* Generic command. */

/* Session statuses, returned by the sensor through the reply of current
 * command or EP3. */
#define VCSFW_ENROLL_STATE_IDLE            0  /* Nothing is going on        */
#define VCSFW_ENROLL_STATE_SCAN            1  /* Capture/IR-FS              */
#define VCSFW_ENROLL_STATE_IMGPROCESS      2  /* Feature extraction         */
#define VCSFW_ENROLL_STATE_VIEW_READY      3  /* View/template is ready     */
#define VCSFW_ENROLL_STATE_VIEW_ENROLL     4  /* Enrolling captured view    */
#define VCSFW_ENROLL_STATE_READY_NEXT      5  /* Ready to enroll next view  */
#define VCSFW_ENROLL_STATE_ENROLMENT_DONE  6  /* Enrollment is complete     */
#define VCSFW_ENROLL_SESSION_FAILURE     255  /* Any kind of failure        */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_enroll_session_status_get_s
{
    vcsUint16_t session_status; /* Current status                            */
    vcsUint16_t param;          /* Additional information (last error code
                                 * in case of VCSFW_ENROLL_SESSION_FAILURE)  */
    vcsUint8_t  reserved;       /* Reserved byte, to make the reply size
                                 * equal to EP3 message size, because the
                                 * same reply is communicated through the
                                 * EP3 too.                                  */
} vcsfw_reply_enroll_session_status_get_t;

/* Debug info comming with session status. */
#define VCSFW_ENROLL_SESSION_STATUS_DBG_INFO_DATA_SIZE      32
typedef struct VCS_PACKED vcsfw_session_status_dbg_info_s
{
    vcsUint32_t  wrapper_code;
    vcsUint32_t  matcher_code;
    vcsUint8_t   dbg_info[VCSFW_ENROLL_SESSION_STATUS_DBG_INFO_DATA_SIZE];
} vcsfw_session_status_dbg_info_t;


/****************************************************************************/
/* VCSFW_CMD_TEMPLATE_UPDATE                                                */
/****************************************************************************/

/* Tag ID-s for different information sent to the sensor and read from
 * sensor back. */

#define VCSFW_TEMPLATE_UPDATE_DATA_TAGID_TEMPLATE                        0x0000
#define VCSFW_TEMPLATE_UPDATE_DATA_TAGID_ENROLLMENT_STATUS               0x0001
#define VCSFW_TEMPLATE_UPDATE_DATA_TAGID_DEBUGINFO                       0x0002
#define VCSFW_TEMPLATE_UPDATE_DATA_TAGID_TUID                            0x0003

/* TLV header structure. */
typedef struct VCS_PACKED vcsfw_template_update_tlv_hdr_s
{
    vcsUint16_t  tagid;         /* Tag ID                                    */
    vcsUint16_t  length;        /* Data length coming after the header.      */
    vcsUint16_t  flags;         /* Flags, for FW internal use.               */
    vcsUint16_t  reserved;      /* For alignment.                            */
    vcsUint8_t   iv[VCSFW_SECURITY_IV_SIZE];     /* Encryption IV.           */
    vcsUint8_t   hash[VCSFW_SHA256_HASH_SIZE];   /* Data hash.               */
} vcsfw_template_update_tlv_hdr_t;
/* <DATA> of length "length" comes after */

/* COMMAND                                                                  */
/* Generic command, followed by the template blob. It is in TLV format.
 * same data received from the host.
 * <TLV_HDR=VCSFW_TEMPLATE_UPDATE_DATA_TAGID_TEMPLATE><DATA>. */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_template_update_s
{
    vcsUint16_t reply_len;           /* Reply data length.                  */
} vcsfw_reply_template_update_t;
/* Followed by the reply data blob in TLV format. */
/* <TLV_HDR><DATA>-<TLV_HDR><DATA>-... */

/****************************************************************************/
/* VCSFW_CMD_CAL_WOF2_V3 Calibration of WOE_WOF2 */
/****************************************************************************/
#if !defined(VCSFW_WOF2_CAL_Z0)
#define VCSFW_WOF2_CAL_Z0 0x1  /* Calibrate zone 0 */
#endif
#if !defined(VCSFW_WOF2_CAL_Z1)
#define VCSFW_WOF2_CAL_Z1 0x2  /* Calibrate zone 1 */
#endif
/* VCSFW_CMD_CAL_WOF2_V3 structure */
typedef struct VCS_PACKED vcsfw_cmd_cal_wof2_v3_s
{
    vcsUint16_t max_replysize; /* Maximum bytes in reply, based on params */
    vcsUint8_t  max_gain;      /* Highest gain allowed */
    vcsUint8_t  min_gain;      /* Lowest gain allowed */
    vcsUint8_t  start_gain;    /* Starting gain */
    vcsUint8_t  step_gain;     /* Step size for gain */
    vcsUint8_t  max_thresh;    /* Highest threshold allowed */
    vcsUint8_t  min_thresh;    /* Lowest threshold allowed (> 0) */
    vcsUint8_t  polltime;      /* Wake-on-Timer definition (ms) */
    vcsUint8_t  debug;         /* Verbose reply with debug data (1 zone only) */
    vcsUint8_t  reserved[2];   /* Padding */
    /*-------- NOTE: equivalent to vcsfw_param_wof2_v3_t -------------- */
    vcsUint32_t wof2_ctrl2;     /* WOE_WOF2_CTRL2 register  */
    vcsUint32_t wof2_thresh;    /* WOE_WOF2_THRESH register, zone 0 */
    vcsUint32_t wof2_threshz1;  /* WOE_WOF2_THRESH register, zone 1 */
    vcsUint16_t wof2_ctrl1;     /* WOE_WOF2_CTRL1 register  */
    vcsUint16_t wof2_cfg_size;  /* Number of bytes of cfg data follow */
    vcsUint8_t  wof2_flags;     /* Calibration directives */
    vcsUint8_t  reserved1[3];
} vcsfw_cmd_cal_wof2_v3_t;
    /* (followed by vcsfw_param_wof2_config_t + binary data) */
    /*-------- NOTE: Maintain equivalence to vcsfw_param_wof2_v3_t ---- */

/****************************************************************************/
/* VCSFW_CMD_TSCONFIG_SSC_PROGRAM Program TS data in the SSC */
/****************************************************************************/

/* COMMAND                                                                  */
/* Generic command, followed by TSCONFIG */

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */

/****************************************************************************/
/* VCSFW_CMD_SECURE_WRAP                                                    */
/****************************************************************************/

/* Values for flags field. */
#define VCSFW_CMD_SECURE_WRAP_FLAGS_WRAP        0
#define VCSFW_CMD_SECURE_WRAP_FLAGS_UNWRAP      1

/* Max data length to wrap. */
#define VCSFW_CMD_SECURE_WRAP_MAX_DATA_LEN      1024 /* 1 KB */

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_secure_wrap_s
{
    vcsUint16_t flags;
    vcsUint16_t data_len;
} vcsfw_cmd_secure_wrap_t;
/* Folowed with the data block to wrap/unwrap. */

/* REPLY                                                                  */
typedef struct VCS_PACKED vcsfw_reply_secure_wrap_s
{
    vcsUint16_t data_len;
} vcsfw_reply_secure_wrap_t;
/* Followed with the wrapped/unwrapped data. */


/****************************************************************************/
/* VCSFW_CMD_OTPROM_TAG_FIND                                                */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_otprom_tag_find_s
{
    vcsUint8_t      flags;          /* flags, see below */
    vcsUint8_t      tag;            /* (OTPROM_TAGTYPE_REG_INIT_INITIAL >> 12),
                                       etc.  Special case: 0 = match all tags */
    vcsUint8_t      maxntags;       /* maximum number of tags to return.
                                      0 = unlimited */
    vcsUint8_t      firstidx;       /* first index of tags to return */
    vcsUint32_t     extended_tag;   /* extended tag value.  Used if
                                    .tag == (OTPROM_TAGTYPE_EXTENDED >> 12) */
} vcsfw_cmd_otprom_tag_find_t;

#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS      0x03
#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_B        0
#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_N        2
#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_BOTH     0
#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYLOW  1
#define VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYHIGH 2

/*
 * Tag types for "Windsor" firmware (Metallica/Viper)
 *  NOTE: the values mirror the values of OTPROM_TAGTYPE_*
 *  defined in engineering/private/impl/micro/windsor/fwrom/src/otprom.h.
 */
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_INITIAL     0x1
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_FINAL       0x2
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_BCH_PARITY           0x3
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_INITIAL 0x4
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_FINAL   0x5
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_INITIAL    0x6
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_FINAL      0x7
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_VCEK_IV              0x8
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_RSA_KEYINFO          0x9
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_RXMAP                0xa
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_WOF2_CONFIG          0xb
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_TSLOT_DATA           0xc
#define VCSFW_OTPROM_TAGTYPE_WINDSOR_EXTENDED             0xe

/*
 * Extended tag types for "Windsor" firmware (Metallica/Viper)
 *  NOTE: the values mirror the values of OTPROM_EXTAGTYPE_*
 *  defined in engineering/private/impl/micro/windsor/fwrom/src/otprom.h.
 */
/* Used by firmware: */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_ELLIPTIC_CURVE     0x00000001
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CUSTID             0x00000002

/* Used only by the host: */
/* Note that these do *not* have mirrored values in the firmware. */

/* Used for storing and reading calibration data from OTPROM                */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_COMMDET_CF1     0x80000001
/* Legacy value: */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA                              \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_COMMDET_CF1
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGAGAIN         0x80000002
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_OFFSET      0x80000003
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_GAIN        0x80000004
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_SNR                          0x80000005
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGA_OFFSET      0x80000007
/* Used to store calibration config info */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALCONFIG_INFO               0x80000008
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF             0x80000009
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_ZONE0                \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_BOTTOM               \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_ZONE0
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_REV1_TEMP                    0x8000000A
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_ZONE1       0x8000000B
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_TOP                  \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_ZONE1
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_HPFBASELINE     0x8000000C
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF         0x8000000D
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_ZONE0            \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_BOTTOM           \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_ZONE0
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_ZONE1   0x8000000E
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_TOP              \
    VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_SCM_WOF_ZONE1
/* Used to store MT config info */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_MT_INFO                      0x8000000F
/* Used to store MT calculated HPFBASELINE score against the 5-line data */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_HPFBASELINE_SCORE            0x80000010
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV2_HPFBASELINE     0x80000011

/* Tag to store LNA and PGA gain in OTPROM */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_LNA_PGA_GAINS        0x80000012

/* Tags to store WOF FU thresholds */
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_FU_ZONE0    0x80000013
#define VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_FU_ZONE1    0x80000014


typedef struct VCS_PACKED vcsfw_reply_otprom_tag_find_s
{
    vcsUint32_t     freespace;      /* number of bytes between chains */
    vcsUint32_t     ntags;          /* number of tags to follow */
} vcsfw_reply_otprom_tag_find_t;

typedef struct VCS_PACKED vcsfw_reply_otprom_tag_find_header_s
{
    vcsUint32_t     offset;         /* offset into the OTPROM of *data* */
    vcsUint16_t     length;         /* length (in bytes) of *data* */
    vcsUint8_t      tag;            /* tag type */
    vcsUint8_t      unused;
    vcsUint32_t     extended_tag;   /* extended tag value.  Used if
                               .tag == VCSFW_OTPROM_TAGTYPE_WINDSOR_EXTENDED) */
} vcsfw_reply_otprom_tag_find_header_t;


/*
 * What follows is an concatenation of elements like this:
 * [+0]  vcsfw_reply_otprom_tag_find_header_t::offset (32 bits)
 * [+4]  vcsfw_reply_otprom_tag_find_header_t::length (16 bits)
 * [+6]  vcsfw_reply_otprom_tag_find_header_t::tag (8 bits)
 * [+7]  vcsfw_reply_otprom_tag_find_header_t::unused (8 bits)
 * [+8]  vcsfw_reply_otprom_tag_find_header_t::extended_tag (32 bits)
 * [+12] first byte of the data.  Note that this is *not*
 *       the "OTPROM header" nor is it ever the extended tag
 *       type.  It's always just the data.
 * [+12+::length-1] the last byte of the data
 *[[+12+::length]   optional padding to make up to n*4 byte boundary]
 *[[+12+::length+1] optional padding to make up to n*4 byte boundary]
 *[[+12+::length+2] optional padding to make up to n*4 byte boundary]
 * ------
 * [+12+((::length+3)&~3)] vcsfw_reply_otprom_tag_find_header_t::offset
 * [+16+((::length+3)&~3)] vcsfw_reply_otprom_tag_find_header_t::length
 * ...
 *
 * NOTE: The vcsfw_reply_otprom_tag_find_header_t::offset value
 *  refers to the offset of the first byte of the *data*, not the
 *  header.  For non-extended tag items on the low chain,
 *  vcsfw_reply_otprom_tag_find_header_t::offset refers to the
 *  address of the header + 4.  For non-extended tag items on the
 *  high chain, vcsfw_reply_otprom_tag_find_header_t::offset refers
 *  to the beginning of the value because the tag appears at the end.
 *  Note that for extended tag types we skip over the extended tag
 *  type (which is always the first 32-bit word of an extended tag).
 */


typedef struct otp_gain_info_s
{
    vcsUint8_t     lna_gain;         /* LNA Gain  */
    vcsUint8_t     pga_gain;         /* PGA Gain  */
    vcsUint16_t    pga_ratio_x100;   /* PGA Ratio x100*/
} otp_gain_info_t;

typedef struct otp_im_nav_info_s
{
    otp_gain_info_t  image;
    otp_gain_info_t  nav;
}otp_im_nav_info_t;


/****************************************************************************/
/* VCSFW_CMD_IFS_STATS_GET                                                  */
/****************************************************************************/

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_framevarstats_s
{
    vcsUint16_t thresh;         /* threshold used */
    vcsUint16_t margin;         /* margin around the threshold */
    vcsUint16_t totalLines;     /* total number of lines */
    vcsUint16_t aboveAvgCount;  /* number of lines above the threshold */
    vcsUint16_t belowAvgCount;  /* number of lines below the threshold */
    vcsUint16_t avgVariance;    /* average line variance */
    vcsUint16_t lineVariance[64];   /* line variance data */
} vcsfw_reply_framevarstats_t;


typedef struct VCS_PACKED vcsfw_reply_ifs_stats_get_s
{
    vcsUint16_t             framesCaptured;         /* number of frames captured */
    vcsUint16_t             frameWhenFirstSettled;  /* number of frames captured when finger first seems settled */
    vcsUint16_t             framesSelectedCount;    /* number of frames captured */
    vcsUint16_t             framesBestCount;        /* number of frames captured when found best quality one found */
    vcsUint16_t             frameRows;              /* number of rows in each frame */
    vcsUint16_t             frameCols;              /* number of cols in each frame */
    vcsUint8_t              headerLen;              /* size of the line header */
    vcsUint8_t              frameSelectStatus;      /* status of frame selection */
    vcsUint8_t              lastSettledFrame;       /* frame number of last one that was settled */
    vcsUint8_t              empty;

    vcsfw_reply_framevarstats_t   previousFrameVarStats;  /* line variance stats for the previous frame */
    vcsfw_reply_framevarstats_t   lastSelectedFrameVarStats;
    vcsUint32_t             lastAvgLineDelta;       /* average line delta of the previous frame */
    vcsUint32_t             bestFrameAvgVariance;   /* average variance of the best frame stored */
} vcsfw_reply_ifs_stats_get_t;

/****************************************************************************/
/* VCSFW_CMD_APPLICATION_REQUEST                                            */
/****************************************************************************/

/* Application ID-s. */
#define VCSFW_CMD_APP_REQUEST_FIDO        0
#define VCSFW_CMD_APP_REQUEST_IPT         1
#define VCSFW_CMD_APP_REQUEST_U2F         2

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_application_request_s
{
    vcsUint16_t app_id;
    vcsUint16_t request_len;
} vcsfw_cmd_application_request_t;
/* Folowed with the incoming request data. */

/* REPLY                                                                   */
typedef struct VCS_PACKED vcsfw_reply_application_request_s
{
    vcsUint16_t response_len;
} vcsfw_reply_application_request_t;
/* Folowed with the response data. */

/****************************************************************************/
/* VCSFW_CMD_STORAGE_FWPART_INFO_GET_V2                                     */
/****************************************************************************/

/* Command */
typedef struct VCS_PACKED vcsfw_cmd_storage_fwpart_info_get_v2_s
{
    vcsUint8_t partid;          /* Partition ID of the FW Extension partition */
} vcsfw_cmd_storage_fwpart_info_get_v2_t;

/* Reply */
typedef struct VCS_PACKED vcsfw_reply_storage_fwpart_info_get_v2_s
{
    vcsUint8_t      majorver;   /* major version of the FW extension */
    vcsUint8_t      minorver;   /* minor version of the FW extension */
    vcsUint16_t     buildnum;   /* build number of the FW extension */
    vcsUint32_t     buildtime;  /* build time of the FW extension in
                                 *  Unix-style seconds from 1/1/1970 12:00
                                 *  AM GMT */
    vcsUint32_t     romid;      /* ID to match with ROM.  In our case, it's
                                 *  the buildtime of the ROM.  This is really
                                 *  only for FPGA development use. */
    vcsUint32_t     fwstart;    /* offset from start of this header to the
                                 *  beginning of the firmware module
                                 *  text/literals/rodata.
                                 *  Note that this can be considered to be an
                                 *  offset in the "clear" mapping of SPI flash
                                 *  because this header is referenced in the
                                 *  clear.
                                 */
    vcsUint32_t     fwsize;     /* size (in bytes) of all firmware modules'
                                 *  text/literals/rodata in this firmware
                                 *  extension partition.
                                 */
    vcsUint32_t     datasize;   /* size (in bytes) of all RAM needed by the
                                 *  firmware modules in this extension.  Note
                                 *  that the modules are linked to have these
                                 *  data begin at the end of RAM - datasize.
                                 *  These will be initialized to all 0.
                                 */
    vcsUint32_t     unused[3];  /* for future use */
    vcsUint16_t     type;       /* type of firmware extension.  Not currently
                                 *  used by the ROM firmware.  The
                                 *  authoritative list of possible
                                 *  values for this item is in
                   *  engineering/private/impl/micro/windsor/fwext/fwextids.txt
                                 */
    vcsUint16_t     nmodules;   /* number of modules.  This is the number
                                 *  of module table entries that
                                 *  follow this header.
                                 */
} vcsfw_reply_storage_fwpart_info_get_v2_t;

/*
 * This reply is followed by an array of nmodules
 *  instances of vcsfw_storage_fwpart_module_v2_t.
 */

#define VCSFW_STORAGE_FWPART_MODULE_TYPE_START      0x0001
#define VCSFW_STORAGE_FWPART_MODULE_TYPE_ONDEMAND   0x0002

#define VCSFW_STORAGE_FWPART_MODULE_FLAG_REFCOUNT   0x00000001
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_FINIFUNC   0x00000002
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_DYNINIT    0x00000004
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_BSSRAM     0x00000008
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_DATARAM    0x00000010
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_DATALOAD   0x00000020
#define VCSFW_STORAGE_FWPART_MODULE_FLAG_INVALID    0x80000000

/*
* The flags VCSFW_STORAGE_FWPART_MODULE_FLAG_* are ORed together
*  into vcsfw_storage_fwpart_module_v2_t::flags.
* The values mean:
*
 * + VCSFW_STORAGE_FWPART_MODULE_FLAG_REFCOUNT
*   The module has a reference count, and its value is in
*   vcsfw_storage_fwpart_module_v2_t::refcount.  This bit will be set
*   for most modules.  It should be clear only on those modules that
*   don't use any BSS, data or dynamic RAM.
* + VCSFW_STORAGE_FWPART_MODULE_FLAG_FINIFUNC
*   The module has a fini (finish) function.
* + VCSFW_STORAGE_FWPART_MODULE_FLAG_DYNINIT
*   The module has an initializer for the dynamic space allocated for
*   it.  Note that this bit does not show whether or not the module
*   *has* dynamic storage allocated for it.
* + VCSFW_STORAGE_FWPART_MODULE_FLAG_BSSRAM
*   The module has statically-allocated BSS (initialized-zero) space.
* + VCSFW_STORAGE_FWPART_MODULE_FLAG_DATARAM
*   The module has statically-allocated data (initialized) space.
* + VCSFW_STORAGE_FWPART_MODULE_FLAG_DATALOAD
*   The module has an initializer for its statically-allocated data
*   space.
*/

typedef struct VCS_PACKED vcsfw_storage_fwpart_module_v2_s
{
    vcsUint32_t     flags;      /* bit field combination of
                                 * VCSFW_STORAGE_FWPART_MODULE_FLAG_*, above */
    vcsUint32_t     refcount;   /* reference counter.  Only valid if
                                 *  VCSFW_STORAGE_FWPART_MODULE_FLAG_REFCOUNT
                                 *  is set in flags. */
    vcsUint32_t     size;       /* size of the module's text, in bytes */
    vcsUint32_t     unused[2];  /* for future use */
    vcsUint16_t     type;       /* module type.  Either
                                 *  VCSFW_STORAGE_FWPART_MODULE_TYPE_START
                                 *  or
                                 *  VCSFW_STORAGE_FWPART_MODULE_TYPE_ONDEMAND.
                                 */
    vcsUint16_t     subtype;    /* module subtype.  Not currently used by
                                 *  the ROM firmware.  The
                                 *  authoritative list of possible
                                 *  values for this item is in
                    *  engineering/private/impl/micro/windsor/fwext/fwmodids.txt
                                 */
    vcsUint16_t     dynsize;    /* size of dynamic data to allocate (and
                                 *  possibly initialize) before calling
                                 *  initfuncp.  Can be zero.
                                 */
    vcsUint16_t     bsslen;     /* length (in 32-bit words) of the BSS
                                 *  space for this module. */
    vcsUint16_t     datalen;    /* length (in 32-bit words) of the initialized
                                 *  data space for this module. */
    vcsUint8_t      majorver;   /* module major version */
    vcsUint8_t      minorver;   /* module minor version */
} vcsfw_storage_fwpart_module_v2_t;

/****************************************************************************/
/* VCSFW_CMD_CUSTID_GET                                                     */
/****************************************************************************/

/* Command -- no arguments */

/* Reply */
typedef struct VCS_PACKED vcsfw_reply_custid_get_s {
    vcsUint32_t     custid;     /* Customer ID */
    vcsUint32_t     projid;     /* Project ID */
} vcsfw_reply_custid_get_t;


/****************************************************************************/
/* VCSFW_CMD_WOF2_CONFIGURE                                                 */
/****************************************************************************/

/* WOF2 Finger detection mode defnitions */
#define VCSFW_WOF2_MODE_NONE        0
#define VCSFW_WOF2_MODE_BOTH        1
#define VCSFW_WOF2_MODE_FD          2
#define VCSFW_WOF2_MODE_FU          3
#define VCSFW_WOF2_MODE_FU_FD       4

#define VCSFW_WOF2_FLAG_INDICATOR   0x01
#define VCSFW_WOF2_FLAG_SPIIDLEON   0x04

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */
typedef struct VCS_PACKED vcsfw_cmd_wof2_config_s {
    vcsUint8_t              mode;           /* finger detection mode */
    vcsUint8_t              flags;
    vcsUint8_t              reserved[2];
    vcsfw_param_wof2_v3_t   wof2_param;     /* WOF2 parameters */
} vcsfw_cmd_wof2_config_t;

/* This command is complex.  The data look like:
 *   off sz name
 *   +0  1  cmd = VCSFW_CMD_WOF2_CONFIGURE
 *   +1  1  vcsfw_cmd_wof2_config_t::mode
 *   +2  1  vcsfw_cmd_wof2_config_t::flags
 *   +3  1  vcsfw_cmd_wof2_config_t::reserved[0]
 *   +4  1  vcsfw_cmd_wof2_config_t::reserved[2]
 *   +5  4  vcsfw_cmd_wof2_config_t::wof2_param.wof2_ctrl2
 *   +9  4  vcsfw_cmd_wof2_config_t::wof2_param.wof2_thresh
 *   +13 4  vcsfw_cmd_wof2_config_t::wof2_param.wof2_threshz1
 *   +17 2  vcsfw_cmd_wof2_config_t::wof2_param.wof2_ctrl1
 *   +19 2  vcsfw_cmd_wof2_config_t::wof2_param.wof2_cfg_size
 *   +21 1  vcsfw_cmd_wof2_config_t::wof2_param.wof2_flags
 *   +22 1  vcsfw_cmd_wof2_config_t::wof2_param.reserved[0]
 *   +23 1  vcsfw_cmd_wof2_config_t::wof2_param.reserved[1]
 *   +24 1  vcsfw_cmd_wof2_config_t::wof2_param.reserved[2]
 *
 *   +25    what follows here is
 *          vcsfw_cmd_wof2_config_t::wof2_param.wof2_cfg_size bytes of
 *          data.  If vcsfw_cmd_wof2_config_t::wof2_param.wof2_cfg_size==0
 *          then the data are looked for in the OTPROM under a
 *          OTPROM_TAGTYPE_WOF2_CONFIG tag.  If it's !=0, then then
 *          data are as follows:
 *   +25 2  vcsfw_param_wof2_config_t::so_aisop_config
 *   +27 2  vcsfw_param_wof2_config_t::so_aisom_config
 *   +29 2  vcsfw_param_wof2_config_t::so_trans_config
 *   +31 1  vcsfw_param_wof2_config_t::so_config[0]
 *   +32 1  vcsfw_param_wof2_config_t::so_config[1]
 *
 *   +33    what follows here are the remaining bytes of SO data
 *          (the first two bytes are in vcsfw_param_wof2_config_t::so_config[0]
 *          and vcsfw_param_wof2_config_t::so_config[1]).
 *          The number of bytes here depends on the values
 *          of ::so_aisop_config, ::so_aisom_config, and ::so_trans_config.
 *
 *   +n 4   period.  If the command is long enough then this timer
 *          period is present.  It's in units of the chip's
 *          timer (units of 10 microseconds).
 */

/* REPLY                                                                    */
/*   - Uses vcsfw_generic_reply_t                                           */


/****************************************************************************/
/* VCSFW_CMD_WOF2_STATUS_GET                                                */
/****************************************************************************/

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* WOF2 Finger state definitiions */
#define VCSFW_WOF2_FINGER_STATE_UNKNOWN 0
#define VCSFW_WOF2_FINGER_STATE_FD      1
#define VCSFW_WOF2_FINGER_STATE_FU      2

/* WOF2 Finger detect event definitions */
#define VCSFW_WOF2_FINGER_EVENT_FD      0x01    /* finger down event generated */
#define VCSFW_WOF2_FINGER_EVENT_FU      0x02    /* finger up event generated */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_wof2_status_s {
    vcsUint8_t      mode;       /* finger detection mode */
    vcsUint8_t      fstate;     /* finger state */
    vcsUint8_t      event;      /* outstanding finger events
                                   both FU/FD events could be reported */
    vcsUint8_t      reserved;
    vcsUint16_t     fd_count;   /* finger down sample count */
    vcsUint16_t     fu_count;   /* finger up sample count */
} vcsfw_reply_wof2_status_t;

/****************************************************************************/
/* VCSFW_CMD_READ_RAW_FPDATA                                                */
/****************************************************************************/

/* COMMAND                                                                  */
typedef struct VCS_PACKED vcsfw_cmd_read_raw_fpdata_s
{
    vcsUint32_t bufsize;    /* host buffer size */
} vcsfw_cmd_read_raw_fpdata_t;

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_read_raw_fpdata_s
{
    vcsUint32_t datasize;   /* amount of data returned */
} vcsfw_reply_read_raw_fpdata_t;
/* The reply is followed by the fingerprint data */

/****************************************************************************/
/* VCSFW_CMD_TEMPERATURE_READ                                               */
/****************************************************************************/

/* REPLY                                                                    */
typedef struct vcsfw_reply_temperature_read_s
{
    vcsUint16_t   adccount;   /* ADC counts from sensing register */
    vcsUint16_t   loopcount;  /* Debug: Number of iterations before settling */
} vcsfw_reply_temperature_read_t;

/****************************************************************************/
/* VCSFW_CMD_AUTORESTART_STAT_GET                                           */
/****************************************************************************/

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_autorestart_stat_get_s {
    vcsUint8_t      ff_count;       /* false finger count */
    vcsUint8_t      reserved[3];
} vcsfw_reply_autorestart_stat_get_t;

/****************************************************************************/
/* VCSFW_CMD_ECHO                                                           */
/****************************************************************************/
/* REPLY */
/* and is followed by the entire command received, minus the command byte */

/****************************************************************************/
/* VCSFW_CMD_BOOTLDR_PATCH                                                  */
/****************************************************************************/

/* COMMAND */
/*
 * A VCSFW_CMD_BOOTLDR_PATCH command begins with a header in
 *  plaintext (designed to make it easier to know what a binary
 *  patch is), followed by a possibly-encrypted header.
 *
 * If the patch is signed then ALL of the headers are hashed
 *  as part of the signature.  Note that they are hashed in
 *  plaintext, not encrypted.
 *
 * The reason for the two headers is twofold:
 *  1) The (possibly) encrypted header contains more sensitive
 *     information (load and run addresses) and
 *  2) The (possibly) encrypted header is generated by the linker.
 *     The plaintext header is generated by a script.
 */

/* This header is always transmitted in plaintext */
/*
 * NOTE: The size of this structure is defined as
 *  BOOTLDR_PATCH_PLAINHDR_SIZE in bootldr.h.
 */
typedef struct VCS_PACKED vcsfw_cmd_bootldr_patch_plainhdr_type0_s {
    vcsUint32_t     flags;
    vcsUint32_t     id;             /* patch ID */
    vcsUint32_t     buildnum;       /* patch buildnum */
    vcsUint32_t     payload_id;     /* identity of payload */
    /*
     * The following data are copied out of the payload's ROM
     *  (the version_roinfo_t structure).
     * If this patch doesn't carry a payload then all these values
     *  should be 0.
     */
    vcsUint32_t     payload_buildtime;
    vcsUint32_t     payload_buildnum;
    vcsUint8_t      payload_vmajor;
    vcsUint8_t      payload_vminor;
    vcsUint8_t      payload_target;
    vcsUint8_t      payload_product;
    vcsUint8_t      payload_siliconrev;
    vcsUint8_t      payload_formalrel;

    vcsUint8_t      seq;            /* sequence if > one patch required */
    vcsUint8_t      vmajor;         /* major version number of patch */
    vcsUint8_t      vminor;         /* minor version number of patch */
    vcsUint8_t      unused[3];

} vcsfw_cmd_bootldr_patch_plainhdr_type0_t;

/* vcsfw_cmd_bootldr_patch_plainhdr_t::flags: */
/* payload encrypted: */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_ENCRYPTED 0x00000001
/* signature follows: */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_SIGNED    0x00000002
/* patch is encrypted/signed using production keys: */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PROD      0x00000004
/* patch contains an NVM (flash) programming payload (payload_* are valid ) */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PAYLOAD   0x00000008
/* patch is encrypted/signed using customer-injected keys: */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_CUSTKEY   0x00000010

/* A mask to decode what type of plainhdr we have */
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE  0xf0000000
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE_B      28
#define VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE_N      4

/* Old name alias: */
typedef vcsfw_cmd_bootldr_patch_plainhdr_type0_t vcsfw_cmd_bootldr_patch_plainhdr_t;

/* For programming mission firmware with flashprog */
typedef struct VCS_PACKED vcsfw_cmd_bootldr_patch_plainhdr_type1_s {
    vcsUint32_t     flags;
    vcsUint32_t     id;             /* patch ID */
    vcsUint32_t     buildnum;       /* patch buildnum */

    /* Restriction information */
    vcsUint32_t     restrict_fwflavor;  /* firmware flavor selector */
    vcsUint32_t     payload_buildtime;
    vcsUint32_t     payload_buildnum;
    vcsUint8_t      payload_vmajor;
    vcsUint8_t      payload_vminor;
    vcsUint8_t      restrict_seclevel;  /* security level */
    vcsUint8_t      padding[3];

    vcsUint8_t      seq;            /* sequence if > one patch required */
    vcsUint8_t      vmajor;         /* major version number of patch */
    vcsUint8_t      vminor;         /* minor version number of patch */
    vcsUint8_t      unused[3];

} vcsfw_cmd_bootldr_patch_plainhdr_type1_t;

/* For programming iota chains with flashprog */
typedef struct VCS_PACKED vcsfw_cmd_bootldr_patch_plainhdr_type2_s {
    vcsUint32_t     flags;
    vcsUint32_t     id;             /* patch ID */
    vcsUint32_t     buildnum;       /* patch buildnum */

    /* Restriction information. Reference: vcsfw_config_version_t */
    vcsUint32_t     restrict_configid1;    /* configuration ID 1 */
    vcsUint32_t     restrict_configid2;    /* configuration ID 2 */
    vcsUint16_t     restrict_configver;    /* configuration version */

    vcsUint8_t      padding[8];

    vcsUint8_t      seq;            /* sequence if > one patch required */
    vcsUint8_t      vmajor;         /* major version number of patch */
    vcsUint8_t      vminor;         /* minor version number of patch */
    vcsUint8_t      unused[3];

} vcsfw_cmd_bootldr_patch_plainhdr_type2_t;

/* Some well-known ids: */
/* vcsfw_cmd_bootldr_patch_plainhdr_t::id */
/* a flash programming patch: */
#define VCSFW_CMD_BOOTLDR_PATCH_PLAINHDR_ID_FLASHPROG   0x00000001
#define VCSFW_CMD_BOOTLDR_PATCH_PLAINHDR_ID_IOTAWRITE   0x00000002

/* vcsfw_cmd_bootldr_patch_plainhdr_t::payload_id */
/* standard vcsfw_v4 mission firmware */
#define VCSFW_CMD_BOOTLDR_PATCH_PLAINHDR_PAYLOAD_ID_VCSFW_V4MISSION 0x00000001

/* This header is sometimes transmitted in an encrypted form. */
typedef struct VCS_PACKED vcsfw_cmd_bootldr_patch_enchdr_s {
    vcsUint32_t     buildtime;      /* patch build time */
    vcsUint32_t     loadaddr;       /* expected load address */
    vcsUint32_t     startaddr;      /* address of start function */
    vcsUint32_t     bssaddr;        /* starting address of BSS section */
    vcsUint32_t     bsslen;         /* length of BSS section */
} vcsfw_cmd_bootldr_patch_enchdr_t;

/* the size of the signature, in bytes */
#define VCSFW_CMD_BOOTLDR_PATCH_SIGSIZE         256

/* REPLY */
/* Reply is generic */

/****************************************************************************/
/* VCSFW_CMD_GET_NAV_STATUS_V2                                              */
/****************************************************************************/

/* COMMAND                                                                  */
/*   - Uses vcsfw_generic_command_t                                         */

/* REPLY                                                                    */
typedef struct VCS_PACKED vcsfw_reply_get_nav_status_v2_s
{
    vcsUint8_t      statusCount; /* count of the status data available as part
                                    of reply */
    vcsUint8_t      reserved[3];
} vcsfw_reply_get_nav_status_v2_t;

/* Maximum value of statusCount variable */
#define VCSFW_NAV_STATUS_MAX_STATUSCOUNT    60

/* Optionally (when statusCount is non-zero), above reply bytes will be
followed by statusCount * 12 bytes. Each of those 12 bytes will follow
below structure */
typedef struct VCS_PACKED vcsfw_nav_status_info_s
{
    vcsUint8_t      status; /* finger status */
    vcsUint8_t      reserved;
    vcsInt16_t      posdelta_x;
    vcsInt16_t      negdelta_x;
    vcsInt16_t      posdelta_y;
    vcsInt16_t      negdelta_y;
    vcsUint16_t     timestamp;
} vcsfw_nav_status_info_t;


/****************************************************************************/
/* VCSFW_CMD_FRAME_READ                                                     */
/****************************************************************************/


typedef struct VCS_PACKED vcsfw_cmd_frame_read_s {
    vcsUint16_t  xfernum;        /* ask for */
    vcsUint16_t  offset;
    vcsUint16_t  nbytes;     /* 0xffff = full frame */
    vcsUint16_t  flags;
} vcsfw_cmd_frame_read_t;

/* for vcsfw_cmd_frame_read_t::flags, above */
    /* FREE: free the entire frame after it has been read, even if
     *  the entire frame was not read */
#define VCSFW_CMD_FRAME_READ_FLAGS_FREE         0x0001
    /* XFERNEXT: ignore the value in vcsfw_cmd_frame_read_t::xfernum
     *  and deliver the next available frame. */
#define VCSFW_CMD_FRAME_READ_FLAGS_XFERNEXT     0x0002


typedef struct VCS_PACKED vcsfw_reply_frame_read_s {
    vcsUint16_t  flags;
    vcsUint16_t  xfernum;
    vcsUint16_t  acqnum; /* number of frame as received from SCM */
    vcsUint16_t  validbytes;
} vcsfw_reply_frame_read_t;

/* for vcsfw_reply_frame_read_t::flags, above */
#define VCSFW_REPLY_FRAME_READ_FLAGS_FINALFRAME 0x0001
#define VCSFW_REPLY_FRAME_READ_FLAGS_FINGERLIFT 0x0002

/****************************************************************************/
/* VCSFW_CMD_FRAME_STATE_GET                                                */
/****************************************************************************/

#define VCSFW_CMD_FRAME_STATE_GET_FLAG_ALLTAGS  0x01  /* means tag ignored */
#define VCSFW_CMD_FRAME_STATE_GET_FLAG_READMAX  0x02  /* means nbytes ignored */

typedef struct VCS_PACKED vcsfw_cmd_frame_state_get_s {
    vcsUint32_t  offset;
    vcsUint16_t  nbytes;
    vcsUint8_t   flags;
    vcsUint8_t   tag;
 } vcsfw_cmd_frame_state_get_t;


typedef struct VCS_PACKED vcsfw_reply_frame_state_get_s {
    vcsUint32_t   fullsize;
    vcsUint16_t   nbytes;
    vcsUint8_t    unused[2];
} vcsfw_reply_frame_state_get_t;



/****************************************************************************/
/* VCSFW_CMD_FRAME_ACQ                                                      */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_frame_acq_s {
    vcsUint32_t flags;
    vcsUint32_t nframes;  /* 0 means that no frame is to be acquired. */
} vcsfw_cmd_frame_acq_t;

#define VCSFW_CMD_FRAME_ACQ_FLAGS_INFINITE      0x00000001  /* ignore nframes */
#define VCSFW_CMD_FRAME_ACQ_FLAGS_CAL_BL        0x00000002  /* baseline cal */

/*
 * The reply.  Note that VCSFW_CMD_FRAME_ACQ can return one of
 *  two different replies: the normal 2-byte status, or the 2-byte
 *  status followed by the following structure which describes the
 *  image data that will be coming.
 */
typedef struct VCS_PACKED vcsfw_reply_frame_acq_s {
     /*
      * A line is a group of pixels that are sent consecutively
      *  (their data are adjacent).
      * A frame is a number of lines making up a single 2d image.
      */
    vcsUint32_t     pixpitch;       /* intraline pixel pitch (nanometers) */
    vcsUint32_t     linepitch;      /* interline pixel a/k/a
                                     *  line-to-line pitch (nanometers) */

    vcsUint32_t     bitinfo;                /* descriptions in terms of bits */
/*
 * How many bits per pixel, minus 1.
 *  Values of 0 to 31 represent 1 bits/pixel to 32 bits/pixel.
 */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BITSPERPIXEL      0x000001f
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BITSPERPIXEL_B        0
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BITSPERPIXEL_N        5
/*
 * How many unused extra bits on every pixel.  These
 *  bits will be always be located "above" the highest
 *  (most significant) bit in the pixel.  Values are 0 to 31.
 */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERPIXEL   0x00003e0
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERPIXEL_B     5
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERPIXEL_N     5
/*
 * How many unused extra bits at the end of every line.  Values are 0 to 31.
 */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERLINE    0x0007c00
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERLINE_B      10
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERLINE_N      5
/*
 * How many unused extra bits at the end of every frame.  Values are 0 to 31.
 */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERFRAME   0x000f8000
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERFRAME_B     15
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_PADBITSPERFRAME_N     5
/*
 * Orientation information.  Note that this information is chosen
 *  to exactly match the 'vcsfw_frame_tag_orientpitch_t::orient'
 *  byte layout.
 */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT            0x00700000
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_B              20
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_N              3
/* after optional mirroring, clockwise rotation count: */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT        0x00300000
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_B          20
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_N          2
/* possible rotation values: */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_CW0        0
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_CW90       1
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_CW180      2
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT_CW270      3
/* first transformation to do: mirror data along lines: */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_MIRROR     0x00400000
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_MIRROR_B       22
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_MIRROR_N       1
 /*
  * Endianness.  For big endian values the more significant bits
  *  appear first in the byte stream, for little endian values the
  *  less significant bits are first.
  */
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BIGENDIAN         0x00800000
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BIGENDIAN_B           23
#define VCSFW_REPLY_FRAME_ACQ_BITINFO_BIGENDIAN_N           1

    vcsUint16_t     pixperline;             /* how many pixels on a line */
    vcsUint16_t     linesperframe;          /* how many lines per frame */
} vcsfw_reply_frame_acq_t;


/****************************************************************************/
/* VCSFW_CMD_IOTA_WRITE                                                     */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_iota_write_s {
     vcsUint16_t     itype;
     vcsUint8_t      unused[2];
} vcsfw_cmd_iota_write_t;


/****************************************************************************/
/* VCSFW_CMD_FLASH_ERASE                                                    */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_flash_erase_s {
     vcsUint32_t     flags;  /* specifies what section to erase */
} vcsfw_cmd_flash_erase_t;

#define VCSFW_CMD_FLASH_ERASE_MISSION_FW    0x1  /* erase mission FW */
#define VCSFW_CMD_FLASH_ERASE_IOTA_AREA     0x2  /* erase iota area */
#define VCSFW_CMD_FLASH_ERASE_FIB           0x4  /* erase flash info block */
#define VCSFW_CMD_FLASH_ERASE_SDB           0x8  /* erase security database */

/****************************************************************************/
/* VCSFW_CMD_EVENT_CONFIG                                                   */
/****************************************************************************/
#define VCSFW_EVENT_TYPE_NOOP               0x00
#define VCSFW_EVENT_TYPE_FINGERDOWN         0x01
#define VCSFW_EVENT_TYPE_FINGERUP           0x02
#define VCSFW_EVENT_TYPE_NAV_TAP            0x03
#define VCSFW_EVENT_TYPE_NAV_DTAP           0x04
#define VCSFW_EVENT_TYPE_NAV_LONGPRESS      0x05
#define VCSFW_EVENT_TYPE_NAV_SWIPE_UP       0x06
#define VCSFW_EVENT_TYPE_NAV_SWIPE_DOWN     0x07
#define VCSFW_EVENT_TYPE_NAV_SWIPE_LEFT     0x08
#define VCSFW_EVENT_TYPE_NAV_SWIPE_RIGHT    0x09
#define VCSFW_EVENT_TYPE_OVERFLOW           0x0A
#define VCSFW_EVENT_TYPE_FINGER_SETTLED     0x0B
#define VCSFW_EVENT_TYPE_FW_BL_UPDATED      0x0C
#define VCSFW_EVENT_TYPE_LNA_BL_UPDATED     0x0D
#define VCSFW_EVENT_TYPE_IOTA_INSINUATED    0x0E
#define VCSFW_EVENT_TYPE_FINGER_REJECTED    0x0F
#define VCSFW_EVENT_TYPE_NAV_SWIPE_ABORTED  0x10
/* NOTE: When a new event is added here, the EVENT_SUPPORTED_MASK and
 * EVENT_NEVENTTYPES need to be updated in fw/nassau/mission/event.h.
 */

#define VCSFW_EVENT_NTYPES                  0x80

typedef vcsUint32_t vcsfw_event_mask_t[VCSFW_EVENT_NTYPES/32];

/* The command: */
typedef struct VCS_PACKED vcsfw_cmd_event_config_s {
    vcsfw_event_mask_t  active;     /* bitmask of events to generate */
    vcsfw_event_mask_t  signal;     /* bitmask of events to cause OOB signal */
    vcsUint32_t         flags;      /* flags, below */
#define VCSFW_CMD_EVENT_CONFIG_FLAG_SIGNAL_FPSTATE_ABSENT     0x00000001
#define VCSFW_CMD_EVENT_CONFIG_FLAG_SIGNAL_FPSTATE_PRESENT    0x00000002
#define VCSFW_CMD_EVENT_CONFIG_FLAG_QUEUE_FLUSH               0x00000004
} vcsfw_cmd_event_config_t;

/* The reply: */
typedef struct VCS_PACKED vcsfw_reply_event_config_s {
    vcsfw_event_mask_t  active;     /* bitmask of events to generate */
    vcsfw_event_mask_t  signal;     /* bitmask of events to cause OOB signal */
    vcsUint32_t         flags;      /* flags, above */

    vcsfw_event_mask_t  supported;  /* bitmask of events supported */
    vcsUint32_t         timescale;  /* timescale of event time, in Hz */
    vcsUint32_t         nmax;       /* max number of events buffered */
    vcsUint16_t         npending;   /* number of events in queue now */
    vcsUint16_t         nextnum;    /* next generate event number */
} vcsfw_reply_event_config_t;

/****************************************************************************/
/* VCSFW_CMD_EVENT_READ                                                     */
/****************************************************************************/

/* An event: */
typedef struct VCS_PACKED vcsfw_event_s {
    vcsUint8_t          type;   /* one of VCSFW_EVENT_TYPE_* */
    vcsUint8_t          unused1;
    vcsUint16_t         num;    /* serial number of this event */
    vcsUint32_t         time;   /* time, in units of
                                 *  vcsfw_reply_event_config_t::timescale
                                 *  per second (currently 100,000) */
    union {
        vcsUint32_t         dummy;
        struct {
            vcsUint16_t     nmissed;    /* number of missed events */
        } overflow;
    } details;
} vcsfw_event_t;

/* The command: */
typedef struct VCS_PACKED vcsfw_cmd_event_read_s {
    vcsUint16_t         firstnum;           /* first requested event number */
    vcsUint16_t         nevents;            /* number of events requested */
} vcsfw_cmd_event_read_t;

/* The reply: */
typedef struct VCS_PACKED vcsfw_reply_event_read_s {
    vcsUint16_t         nevents;            /* number of events to follow */
    vcsUint16_t         npending;           /* number of events in the queue */
    /* This header is followed by an array of nevents of vcsfw_event_t */
} vcsfw_reply_event_read_t;

/****************************************************************************/
/* VCSFW_CMD_FMNO_GET                                                       */
/****************************************************************************/

/* Command -- no arguments */

/* Reply */
typedef struct VCS_PACKED vcsfw_reply_fmno_get_s {
    vcsUint32_t     fmno;     /* bits 31:30 unused, 29:10=main, 9:0=dash */
} vcsfw_reply_fmno_get_t;

/* Finally, the generic forms of commands and replies.                      */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_s
{
    vcsUint8_t    cmd;
    union
    {
        vcsfw_cmd_get_print_t    get_print;
        vcsfw_cmd_reset_t        reset;
/*        vcsfw_cmd_patch_t        patch; */ /* Not used */
        vcsfw_cmd_peek_t         peek;
        vcsfw_cmd_poke_t         poke;
        vcsfw_cmd_set_refclk_t   set_refclk;
        vcsfw_cmd_set_spimode_t  set_spimode;
        vcsfw_cmd_spi_transfer_t spi_transfer;
        vcsfw_cmd_woe_setup_t    woe_setup;
        vcsfw_cmd_woe_enter_t    woe_enter;
        vcsfw_cmd_gpio_t         gpio;
        vcsfw_cmd_set_cpuclk_t   set_cpuclk;
        vcsfw_cmd_take_ownership_t    take_ownership;
        vcsfw_cmd_reset_ownership_t   reset_ownership;
        vcsfw_cmd_unload_patch_t    unload_patch;
        vcsfw_cmd_sign_enc_template_data_t   sign_enc_template_data;
        vcsfw_cmd_dec_verify_template_data_t dec_verify_template_data;
        vcsfw_cmd_match_verify_t             match_verify;
        vcsfw_cmd_spislv_fast_read_t         spislv_fast_read;
        vcsfw_cmd_key_exchange_dh_t          key_exchange;
        vcsfw_cmd_led_t                      led;
        vcsfw_cmd_led_ex_t                   led_ex;
        vcsfw_cmd_get_auth_data_t            get_auth_data;
        vcsfw_cmd_spi_flash_t                spi_flash;
        vcsfw_cmd_cal_wof2_t                 metallica_cal_wof2;
    } details;
} vcsfw_cmd_t;

typedef struct VCS_PACKED vcsfw_reply_s
{
    vcsUint16_t   status;
    union
    {
        vcsfw_reply_get_version_t           get_version;
        vcsfw_reply_get_print_signature_t   get_signature;
        vcsfw_reply_peek_t                  peek;
        vcsfw_reply_prng_t                  prng;
        vcsfw_reply_gpio_t                  gpio;
        vcsfw_reply_get_finger_status_t     get_finger_status;
        vcsfw_reply_get_startinfo_t         get_startinfo;
        vcsfw_reply_get_configuration_t     get_config;
        vcsfw_reply_take_ownership_t        take_ownership;
        vcsfw_reply_sign_enc_template_data_t    sign_enc_template_data;
        vcsfw_reply_dec_verify_template_data_t  dec_verify_template_data;
        vcsfw_reply_get_print_signature_t   get_print_signature;
        vcsfw_reply_get_ownership_info_t    get_ownership_info;
        vcsfw_reply_get_uid_t               get_uid;
        vcsfw_reply_key_exchange_dh_t       key_exchange;
        vcsfw_reply_get_auth_data_t         get_auth_data;
        vcsfw_reply_gen_vck_t               gen_vck;
        vcsfw_reply_fmno_get_t              fmno_get;
    } details;
} vcsfw_reply_t;


/****************************************************************************/
/* VCSFW_CMD_FLASH_READ                                                     */
/****************************************************************************/
typedef struct VCS_PACKED vcsfw_cmd_flash_read_s {
    vcsUint32_t    offset;   /* offset (in bytes) into section at which to start reading */
    vcsUint32_t    nbytes;   /* size (in bytes) of payload to be returned */
    vcsUint16_t    flags;
    vcsUint8_t     section;  /* specifies what section to read */
    vcsUint8_t     reserved; /* undefined byte that may be repurposed later */
} vcsfw_cmd_flash_read_t;

typedef struct vcsfw_flash_read_reply_s {
    vcsUint32_t  sectionbytes; /* total size of the section read from */
    vcsUint32_t  nbytes;       /* size of the data payload following this struct */
} vcsfw_flash_read_reply_t;

#define VCSFW_CMD_FLASH_READ_SECTION_MISSION_FW   0x1
#define VCSFW_CMD_FLASH_READ_SECTION_IOTA         0x2
#define VCSFW_CMD_FLASH_READ_SECTION_FIB          0x3

#define VCSFW_CMD_FLASH_READ_FLAGS_BIGGEST        0x1
#define VCSFW_CMD_FLASH_READ_FLAGS_SHA256         0x2


/****************************************************************************/
/* VCSFW_CMD_FRAME_STREAM                                                   */
/****************************************************************************/

typedef struct VCS_PACKED vcsfw_cmd_frame_stream_s {
    vcsUint16_t  nbytes;        /* maximum number of bytes to return */
} vcsfw_cmd_frame_stream_t;

typedef struct VCS_PACKED vcsfw_reply_frame_stream_s {
    vcsUint32_t  nlost;         /* bytes lost between this read and previous */
    vcsUint32_t  nqueued;       /* no. of bytes queued (not counting payload) */
    vcsUint16_t  flags;         /* flags, see below */
    vcsUint16_t  acqnum;        /* number of frame as received from imager */
} vcsfw_reply_frame_stream_t;

#define VCSFW_REPLY_FRAME_STREAM_FLAGS_EOS      0x0001      /* end of stream */
#define VCSFW_REPLY_FRAME_STREAM_FLAGS_EOF      0x0002      /* end of frame */
#define VCSFW_REPLY_FRAME_STREAM_FLAGS_ILLUM    0x0004
                                    /* current state of illumination (HBM) */
#define VCSFW_REPLY_FRAME_STREAM_FLAGS_EXTFP    0x0008
                    /* current state of external finger presence detection */

/****************************************************************************/
/* VCSFW_CMD_IOTA_FIND                                                      */
/****************************************************************************/

/*
 * The IOTA_FIND command.  Iotas can exceed the size of available
 *  RAM in the part.  In order to allow the host to read them
 *  the IOTA_FIND command supports transferring iotas with
 *  multiple commands.
 */
typedef struct VCS_PACKED vcsfw_cmd_iota_find_s
{
    vcsUint16_t     itype;      /* type of iotas to find */
    vcsUint16_t     flags;      /* flags, see below */
    vcsUint8_t      maxniotas;  /* maximum number of iotas to return.
                                 *  0 = unlimited */
    vcsUint8_t      firstidx;   /* first index of iotas to return */
    vcsUint8_t      dummy[2];
    vcsUint32_t     offset;     /* byte offset of data to return */
    vcsUint32_t     nbytes;     /* maximum number of bytes to return */
} vcsfw_cmd_iota_find_t;

#define VCSFW_CMD_IOTA_FIND_FLAGS_ALLIOTAS  0x0001    /* itype ignored*/
#define VCSFW_CMD_IOTA_FIND_FLAGS_READMAX   0x0002    /* nbytes ignored */

typedef struct VCS_PACKED vcsfw_reply_iota_find_s
{
    vcsUint32_t      fullsize;  /* size of all data */
} vcsfw_reply_iota_find_t;

/* This is followed by a chain of iotas, as follows */
typedef struct VCS_PACKED vcsfw_reply_iota_find_hdr_s
{
    vcsUint16_t      nbytes;
    vcsUint16_t      itype;
} vcsfw_reply_iota_find_hdr_t;


/****************************************************************************/
/* VCSFW_CMD_IOTA_INSINUATE                                                 */
/****************************************************************************/

typedef struct VCS_PACKED vcsfw_cmd_iota_insinuate_s
{
    vcsUint16_t     itype;      /* type of iota being insinuated */
    vcsUint16_t     flags;      /* flags, see below */
} vcsfw_cmd_iota_insinuate_t;

#define VCSFW_CMD_IOTA_INSINUATE_FLAGS_CLEARALL  0x0001   /* wipe out all the
                                                        * insinuated iotas */

/* IOTA_INSINUATE returns only the generic reply */


/****************************************************************************/
/* VCSFW_CMD_FRAME_STATS_GET                                                */
/****************************************************************************/

/*
 * Here are the types of image statistics to gather.  Note that the
 *  naming is a bit odd (i.e., these are not of the form
 *  "VCSFW_CMD_FRAME_STATS_GET_TYPE_*") because these values
 *  are also used in the VCSFW_FRAME_TAG_STATS tag.
 */
#define VCSFW_FRAME_STATS_TYPE_NONE      0   /* no report. */
#define VCSFW_FRAME_STATS_TYPE_PIXSTDDEV 1   /* 2d pixel std dev time domain */
#define VCSFW_FRAME_STATS_TYPE_PIXAVG    2   /* 2d pixel avg time domain */
#define VCSFW_FRAME_STATS_TYPE_COLSTDDEV 3   /* 1d column stddev time+space */
#define VCSFW_FRAME_STATS_TYPE_COLAVG    4   /* 1d column avg time+space */
#define VCSFW_FRAME_STATS_TYPE_ROWSTDDEV 5   /* 1d row stddev time+space */
#define VCSFW_FRAME_STATS_TYPE_ROWAVG    6   /* 1d row avg time+space */

typedef struct VCS_PACKED vcsfw_cmd_frame_stats_get_s {
    vcsUint16_t     flags;
    vcsUint8_t      type;      /* one of VCSFW_FRAME_STATS_TYPE_* */
    vcsUint8_t      unused;
} vcsfw_cmd_frame_stats_get_t;

#define VCSFW_CMD_FRAME_STATS_GET_FLAGS_FREE        0x0001  /* free data */

/****************************************************************************/
/* VCSFW_CMD_PUBK_GET                                                       */
/****************************************************************************/

/* Identifier of public keys. */
#define VCSFW_PUBK_ID_SSPUBK        0x00      /* Sensor signing public key. */

typedef struct VCS_PACKED vcsfw_cmd_pubk_get_s {
    vcsUint8_t     key_id;             /* Identifier of the requested keys. */
} vcsfw_cmd_pubk_get_t;

/* ECC public key. */
typedef struct VCS_PACKED vcsfw_ecc_pubkey_s
{
    vcsUint32_t iana_id;
    vcsUint32_t key_len;
    vcsUint8_t  sign;
    vcsUint8_t  unused[3];
    vcsUint8_t  x[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
    vcsUint8_t  y[VCSFW_TAKEOWN_MAX_ECC_PARAM_LEN];
} vcsfw_ecc_pubkey_t;

typedef struct VCS_PACKED vcsfw_reply_pubk_get_s {
    vcsUint16_t     key_len;   /* Length of the key followed to the field. */
    union _key
    {
        vcsfw_ecc_pubkey_t ecc_key;
    } key;
} vcsfw_reply_pubk_get_t;

/****************************************************************************/
/* Definitions related to the line structure of the sensor                  */
/****************************************************************************/
#define VCSFW_LINE_CULL_BIT (0x10)
#define VCSFW_LINE_CULLED(x) ((x & VCSFW_LINE_CULL_BIT) == VCSFW_LINE_CULL_BIT)
#define VCSFW_LINE_MAX_BITS(x) (x & 0x0f)
#define VCSFW_LINE_STATUS(x) ((x >> 5) & 0x07)

/* Some information about finger motion is passed in-band by overwriting    */
/* bits in the line header.  If such information needs to be passed, the    */
/* magic1 and magic2 values in the header will be set to 0x01 0x01, and the */
/* timestamp_lo byte will be overwritten with one of the following values   */
#define VCSFW_LINE_FLAG_EOP     0x00  /* End of Print                       */
#define VCSFW_LINE_FLAG_RESTART 0x01
#define VCSFW_LINE_FLAG_STILL   0x02

/* Header bit definitions (HDR_SPARE) for register list swapping states */
#define VCSFW_LINE_STATUS_NONE             0
#define VCSFW_LINE_STATUS_SWAPOUT_STARTED  1
#define VCSFW_LINE_STATUS_SWAPOUT_DONE     2
#define VCSFW_LINE_STATUS_SWAPBACK_STARTED 3
#define VCSFW_LINE_STATUS_SWAPBACK_DONE    (VCSFW_LINE_STATUS_NONE)
#define VCSFW_LINE_STATUS_STILL            4

typedef struct VCS_PACKED vcsfw_line_header_s
{
    vcsUint8_t magic1;         /* should be 0x01                            */
    vcsUint8_t magic2;         /* should be 0xfe                            */
    vcsUint8_t timestamp_lo;   /* In units of line periods                  */
    vcsUint8_t timestamp_hi;
    vcsUint8_t afe_pga_gain_0;
    vcsUint8_t afe_pga_gain_1;
    vcsUint8_t flags;          /* bits 0-3 = max bits, bit 4 = cull, bit 5-7 spare  */
    vcsUint8_t reserved;
} vcsfw_line_header_t;

/* CEM result data format for IR mode */
typedef struct VCS_PACKED vcsfw_cem_ir_result_s
{
    vcsUint16_t     fix_sum_up;
    vcsUint16_t     fix_sqsum_up;
    vcsUint16_t     lag_sum_up;
    vcsUint16_t     lag_sqsum_up;
    vcsUint8_t      ncc_up;
    vcsUint8_t      ylag_up;
    vcsUint8_t      xlag_up;
    vcsUint8_t      ncc_down;
    vcsUint8_t      ylag_down;
    vcsUint8_t      xlag_down;
    vcsUint16_t     fix_sum_down;
    vcsUint16_t     fix_sqsum_down;
    vcsUint16_t     lag_sum_down;
    vcsUint16_t     lag_sqsum_down;
    vcsUint16_t     reserved;
} vcsfw_cem_ir_result_t;

/* CEM result data format for NAV/DEBUG mode */
typedef struct VCS_PACKED vcsfw_cem_nav_result_s
{
    vcsUint16_t     fix_sum_up;
    vcsUint16_t     fix_sqsum_up;
    vcsUint16_t     lag_sum_up;
    vcsUint16_t     lag_sqsum_up;
    vcsUint16_t     crosssum_up;
    vcsUint8_t      ncc_up;
    vcsUint8_t      ylag_up;
    vcsUint8_t      xlag_up;
    vcsUint8_t      ncc_down;
    vcsUint8_t      ylag_down;
    vcsUint8_t      xlag_down;
    vcsUint16_t     fix_sum_down;
    vcsUint16_t     fix_sqsum_down;
    vcsUint16_t     lag_sum_down;
    vcsUint16_t     lag_sqsum_down;
    vcsUint16_t     crosssum_down;
    vcsUint8_t      ncc_sidea;
    vcsUint8_t      ylag_sidea;
    vcsUint16_t     fix_sum_sidea;
    vcsUint16_t     fix_sqsum_sidea;
    vcsUint16_t     lag_sum_sidea;
    vcsUint16_t     lag_sqsum_sidea;
    vcsUint16_t     crosssum_sidea;
    vcsUint8_t      xlag_sidea;
    vcsUint8_t      ncc_sideb;
    vcsUint8_t      ylag_sideb;
    vcsUint8_t      xlag_sideb;
    vcsUint16_t     fix_sum_sideb;
    vcsUint16_t     fix_sqsum_sideb;
    vcsUint16_t     lag_sum_sideb;
    vcsUint16_t     lag_sqsum_sideb;
    vcsUint16_t     crosssum_sideb;
} vcsfw_cem_nav_result_t;

/****************************************************************************/
/* Transport layer defines                                                  */
/****************************************************************************/
/* first, the Incoming Control Block                                        */
#define VCSFW_ICB_MAGIC 0x01234567
#define VCSFW_ICB_FLAGS_EOM  1

/* Sliding window size for the receiving packets */
#define VCSFW_ICB_WINDOW_SIZE 6

typedef struct VCS_PACKED vcsfw_icb_s
{
    vcsUint32_t magic;
    vcsUint16_t size;
    vcsUint8_t  sequence;
    vcsUint8_t  flags;
} vcsfw_icb_t;

/* Transport layer defines
 * Next, the Outgoing Control Block
 *
*/

#define VCSFW_OCB_MAGIC 0xfedcba98
/* Flags definitions:
 *  Bit 0   - 1 = end of message
 *  Bit 3:1 - 000 = Reply Channel data
 *            001 = Fingerprint Channel Data
 *            010 = ACK data
 *            011 = Announce packet
 *            100 = NOOP packet
 *
*/
#define VCSFW_OCB_FLAGS_EOM   0x01
#define VCSFW_OCB_FLAGS_CHAN  0x0e  /* Mask value for the Channel indicators */
#define VCSFW_OCB_FLAGS_CHAN_REPLY 0x00
#define VCSFW_OCB_FLAGS_CHAN_FP    0x01
#define VCSFW_OCB_FLAGS_CHAN_ACK   0x02
#define VCSFW_OCB_FLAGS_CHAN_ANN   0x03
#define VCSFW_OCB_FLAGS_CHAN_NOOP  0x04

#define VCSFW_OCB_FLAGS_EOM_B      0x0
#define VCSFW_OCB_FLAGS_CHAN_B     0x1

typedef struct VCS_PACKED vcsfw_ocb_s
{
    vcsUint32_t magic;
    vcsUint16_t size;
    vcsUint8_t  lastrxseq;
    vcsUint8_t  flags;
} vcsfw_ocb_t;

/* The Announce packet is transmitted by the SPI and Parallel port           */
/* on initial boot and is preceded by a vcsfw_ocb_t and vcsfw_generic_reply_t*/
/* structure, as described in the interface document.  It is intended to act */
/* as an announcement that the sensor has booted (or rebooted), as well as   */
/* acting as an initial integration message that can be easily extracted from*/
/* the sensor to verify that the implementation is correctly handling        */
/* endianness and structure unpacking issues.                                */
/* The Size of this structure is:                                            */
/*  64 - sizeof(vcsfw_ocb_t) - sizeof(vcsfw_generic_reply_t) = 54 bytes      */
typedef struct VCS_PACKED vcsfw_announce_s
{
    vcsUint16_t VendorID;      /* Used for some devices; 0 otherwise         */
    vcsUint16_t ProductID;     /* Used for some devices; 0 otherwise         */
    vcsUint8_t MajorVersion;   /* Same as vmajor in vcsfw_reply_get_version_t*/
    vcsUint8_t MinorVersion;   /* Same as vminor in vcsfw_reply_get_version_t*/
    vcsUint8_t DeviceType;     /* 0xHL: H=cmd protocol ver.,L=security status*/
    vcsUint8_t StartType;      /* Used WOE start type (woe_start_type_t)     */
    vcsUint8_t ResetType;      /* Used WOE reset type (woe_reset_type_t)     */
    vcsUint8_t TransportVersion;/* 0xHL: H=reserved, L=Transport version     */
        /* This block starts on a 4-byte boundary                            */
    vcsUint32_t Longs1;        /* One 32-bit word (0x01020304)               */
    vcsUint16_t Words1[2];     /* Two words  {0x0506, 0x0708}                */
    vcsUint8_t  Bytes1[3];     /* Three bytes {0x09 0x0a 0x0b}               */
        /* This block starts +1 byte offset from a 4-byte boundary           */
    vcsUint32_t Longs2;        /* One 32-bit word (0x01020304)               */
    vcsUint16_t Words2[2];     /* Two words  {0x0506, 0x0708}                */
    vcsUint8_t  Bytes2[3];     /* Three bytes {0x09 0x0a 0x0b}               */
        /* This block starts +2 bytes offset from a 4-byte boundary          */
    vcsUint32_t Longs3;        /* One 32-bit word (0x01020304)               */
    vcsUint16_t Words3[2];     /* Two words  {0x0506, 0x0708}                */
    vcsUint8_t  Bytes3[3];     /* Three bytes {0x09 0x0a 0x0b}               */
        /* This block starts +3 bytes offset from a 4-byte boundary          */
    vcsUint32_t Longs4;        /* One 32-bit word (0x01020304)               */
    vcsUint16_t Words4[2];     /* Two words  {0x0506, 0x0708}                */
    vcsUint8_t  Bytes4[3];     /* Three bytes {0x09 0x0a 0x0b}               */
} vcsfw_announce_t;

/* Defines for the DeviceType field of the Announce Packet                   */
/* Note that this is also reported in the Device SubType field of the USB    */
/* Device Descriptor                                                         */
#define VCSFW_SECURITY_STATUS_CLEAN             0
#define VCSFW_SECURITY_STATUS_INSECURE          1
#define VCSFW_SECURITY_STATUS_PROVISIONED       2
#define VCSFW_SECURITY_STATUS_SECURE            3
#define VCSFW_SECURITY_STATUS_DECOMMISSIONED    4
#define VCSFW_SECURITY_STATUS_SECURE_RSA        5
#define VCSFW_SECURITY_STATUS_SECURE_RSA_ECC    6
#define VCSFW_SECURITY_STATUS_SECURE_ECC        7
#define VCSFW_SECURITY_STATUS_SECURE_BASIC      8
#define VCSFW_SECURITY_STATUS_UNKNOWN           15  /* The last alowed value */

/* Defines for the TransportVersion field of the Announce Packet             */
#define VCSFW_ICB_SIZE_32                 0
#define VCSFW_ICB_SIZE_64                 1

/* Vendor-specific USB control requests (bRequest field of the Setup message).*/
#define VCFSW_USB_CTRLREQUEST_VENDOR_GET_SECURITYINFO   20
/* Vendor-specific USB control requets to write DFT word (Hayes) */
#define VCFSW_USB_CTRLREQUEST_VENDOR_WRITEDFT           21

/****************************************************************************/
/* SSL definitions                                                          */
/****************************************************************************/
/* -------------------------------------------------------------------------- */
/* SSL macros */

/*
 * Options selection for SSL
 */
/* #define VCSFW_SSL_DEBUG */       /* enable debugging                     */
#define VCSFW_SSL_USE_RSA           /* Use RSA                              */
/* #define VCSFW_SSL_AES_CTR */     /* Use AES in Counter mode              */
#define VCSFW_SSL_AES_CBC           /* Use AES in CBC mode                  */
#define VCSFW_SSL_USE_MAC           /* compute keyed MACs on messages       */
/* #define VCSFW_SSL_USE_CRC */     /* compute CRC on messages              */
#define VCSFW_SSL_RESUME            /* support session resuming             */

#define VCSFW_SSL_MAJOR_VER                  3
#define VCSFW_SSL_MINOR_VER                  0

/* SSL size definitions */
#define VCSFW_SSL_MD5_HASH_SIZE             16
#define VCSFW_SSL_SHA1_HASH_SIZE            20
#define VCSFW_SSL_AES_BLOCK_SIZE            16
#define VCSFW_SSL_RANDOM_SIZE               32
#define VCSFW_SSL_PREMASTER_SECRET_SIZE     48
#define VCSFW_SSL_MASTER_SECRET_SIZE        48
#define VCSFW_SSL_SEQUENCE_NUMBER_SIZE       8
#define VCSFW_SSL_SESSION_ID_MAX_SIZE       32
#define VCSFW_SSL_FINISHED_HASH_SIZE         \
            (VCSFW_SSL_MD5_HASH_SIZE + VCSFW_SSL_SHA1_HASH_SIZE)
#define VCSFW_SSL_SHA1_PAD_SIZE             40
#define VCSFW_SSL_MD5_PAD_SIZE              48

#if defined(VCSFW_SSL_RESUME)
#   define VCSFW_SSL_SESSION_ID_SIZE         7
#   define VCSFW_SSL_SESSION_ID              {'F','A','L','C','S','S','L'}
#endif

/*  SSL record size limitations */
#define VCSFW_SSL_MAX_PLAINTEXT_SIZE        0x4000  /* 16 kB */
#define VCSFW_SSL_MAX_RECORD_SIZE           (VCSFW_SSL_MAX_PLAINTEXT_SIZE + 2048)

/* SSL internal state flags */
#define VCSFW_SSL_FLAGS_SECURE_READ         0x1     /* secure-read state    */
#define VCSFW_SSL_FLAGS_SECURE_WRITE        0x2     /* secure-write state   */
#define VCSFW_SSL_FLAGS_RESUMED             0x4     /* session resumed      */
#define VCSFW_SSL_FLAGS_CLOSED              0x8     /* session closed       */
#define VCSFW_SSL_FLAGS_FAILED              0x10    /* session failed       */
#define VCSFW_SSL_FLAGS_CLIENT_AUTH         0x80    /* require client auth. */

#define VCSFW_SSL_FLAG_SET(ssl_ctx, flag)   ((ssl_ctx)->flags |=  flag)
#define VCSFW_SSL_FLAG_GET(ssl_ctx, flag)   ((ssl_ctx)->flags &   flag)
#define VCSFW_SSL_FLAG_CLR(ssl_ctx, flag)   ((ssl_ctx)->flags &= ~flag)

/*
 * SSL CipherSuite definitions
 */

/* Initial CipherSuite, which does not provide any security. */
#define VCSFW_SSL_NULL_WITH_NULL_NULL                           0x0000

/*
 * The following CipherSuite definitions require that the server
 * provide an RSA certificate that can be used for key exchange.
 * The server requests an RSA signature-capable certificate
 * in the certificate request message.
 */
#if defined(VCSFW_SSL_AES_CTR)
#if     defined(VCSFW_SSL_USE_CRC)
#               define VCSFW_SSL_RSA_WITH_AES_128_CTR_CRC       0x0033
#               define VCSFW_SSL_RSA_WITH_AES_192_CTR_CRC       0x0034
#               define VCSFW_SSL_RSA_WITH_AES_256_CTR_CRC       0x0035
#elif   defined(VCSFW_SSL_USE_MAC)
#               define VCSFW_SSL_RSA_WITH_AES_128_CTR_SHA       0x0036
#               define VCSFW_SSL_RSA_WITH_AES_192_CTR_SHA       0x0037
#               define VCSFW_SSL_RSA_WITH_AES_256_CTR_SHA       0x0038
#else
# error SSL being built without MAC or CRC
#endif      /* defined(VCSFW_SSL_USE_CRC) */
#elif   defined(VCSFW_SSL_AES_CBC)
#if         defined(VCSFW_SSL_USE_CRC)
#               define VCSFW_SSL_RSA_WITH_AES_128_CBC_CRC       0x0039
#               define VCSFW_SSL_RSA_WITH_AES_192_CBC_CRC       0x0040
#               define VCSFW_SSL_RSA_WITH_AES_256_CBC_CRC       0x0041
#elif       defined(VCSFW_SSL_USE_MAC)
#               define VCSFW_SSL_RSA_WITH_AES_128_CBC_SHA       0x0042
#               define VCSFW_SSL_RSA_WITH_AES_192_CBC_SHA       0x0043
#               define VCSFW_SSL_RSA_WITH_AES_256_CBC_SHA       0x0044
#else
#           error SSL being built without MAC or CRC
#endif      /* defined(VCSFW_SSL_USE_CRC) */
#endif /* defined(VCSFW_SSL_AES_CTR) */
/*
 * The following CipherSuite definitions require that the server
 * use AES Counter mode for key exchange.
 */
#if defined(VCSFW_SSL_USE_CRC)
#           define VCSFW_SSL_AES_CTR_WITH_AES_128_CTR_CRC   0x0021
#           define VCSFW_SSL_AES_CTR_WITH_AES_192_CTR_CRC   0x0022
#           define VCSFW_SSL_AES_CTR_WITH_AES_256_CTR_CRC   0x0023
#elif defined(VCSFW_SSL_USE_MAC)
#           define VCSFW_SSL_AES_CTR_WITH_AES_128_CTR_SHA   0x0024
#           define VCSFW_SSL_AES_CTR_WITH_AES_192_CTR_SHA   0x0025
#           define VCSFW_SSL_AES_CTR_WITH_AES_256_CTR_SHA   0x0026
#else
# error SSL being built without MAC or CRC
#endif /* defined(VCSFW_SSL_USE_CRC) */
/*
 * The following CipherSuite definitions require that the server
 * use AES CBC mode for key exchange.
 */
#if defined(VCSFW_SSL_USE_CRC)
#           define VCSFW_SSL_AES_CBC_WITH_AES_128_CBC_CRC   0x0027
#           define VCSFW_SSL_AES_CBC_WITH_AES_192_CBC_CRC   0x0028
#           define VCSFW_SSL_AES_CBC_WITH_AES_256_CBC_CRC   0x0029
#elif defined(VCSFW_SSL_USE_MAC)
#           define VCSFW_SSL_AES_CBC_WITH_AES_128_CBC_SHA   0x0030
#           define VCSFW_SSL_AES_CBC_WITH_AES_192_CBC_SHA   0x0031
#           define VCSFW_SSL_AES_CBC_WITH_AES_256_CBC_SHA   0x0032
#else
# error SSL being built without MAC or CRC
#endif /* defined(VCSFW_SSL_USE_CRC) */

/* RSA definitions */
#if defined(VCSFW_SSL_USE_RSA)
#   define VCSFW_SSL_RSA_KEYLEN      (2048 >> 3)     /* 2048 bit */
#   define VCSFW_SSL_RSA_PUB_EXP     0x00010001      /* 65537    */
#endif /* defined(VCSFW_SSL_USE_RSA) */

/* Certificate types */
#if defined(VCSFW_SSL_USE_RSA)
#   define VCSFW_SSL_CERT_TYPE_RSA_SIGN     1   /* RSA certificate */
#   define VCSFW_RSA_PKCS1_BT1              0x1
#   define VCSFW_RSA_PKCS1_BT2              0x2
#endif /* defined(VCSFW_SSL_USE_RSA) */

/* Calculate padding length */
#define VCSFW_SSL_PAD_LEN(rec_len) \
        ((vcsUint8_t)(VCSFW_SSL_AES_BLOCK_SIZE - ((rec_len) & \
        (VCSFW_SSL_AES_BLOCK_SIZE - 1))))

#if defined(VCSFW_SSL_USE_CRC)
#       define  VCSFW_SSL_MAC_SIZE                      sizeof(vcsUint32_t)
#       define  VCSFW_SSL_KEY_BLOCK_SIZE(cipher_spec) \
                    (2 * (cipher_spec->key_size + VCSFW_SSL_AES_BLOCK_SIZE))
#       define  VCSFW_SSL_MAX_KEY_BLOCK_SIZE          \
                    (2 * (32 + VCSFW_SSL_AES_BLOCK_SIZE))
#elif defined(VCSFW_SSL_USE_MAC)
#       define  VCSFW_SSL_MAC_SIZE                      VCSFW_SSL_SHA1_HASH_SIZE
#       define  VCSFW_SSL_KEY_BLOCK_SIZE(cipher_spec) \
                    (2 * (VCSFW_SSL_MAC_SIZE + cipher_spec->key_size + \
                          VCSFW_SSL_AES_BLOCK_SIZE))
#       define  VCSFW_SSL_MAX_KEY_BLOCK_SIZE \
                    (2 * (VCSFW_SSL_MAC_SIZE + 32 + \
                          VCSFW_SSL_AES_BLOCK_SIZE))
#endif  /* defined(VCSFW_SSL_USE_CRC) */

#define VCSFW_SSL_MAX_TAIL_SIZE  (VCSFW_SSL_MAC_SIZE + VCSFW_SSL_AES_BLOCK_SIZE)

/* -------------------------------------------------------------------------- */
/* SSL types and type-specific macros */

/* Record types */
typedef enum vcsfw_ssl_record_type_s
{
    VCSFW_SSL_RT_CHANGE_CIPHER_SPEC     = 20,
    VCSFW_SSL_RT_ALERT                  = 21,
    VCSFW_SSL_RT_HANDSHAKE              = 22,
    VCSFW_SSL_RT_APPLICATION_DATA       = 23
} vcsfw_ssl_record_type_t;

/* Handshake message types */
typedef enum vcsfw_ssl_handshake_type_s
{
    VCSFW_SSL_HS_HELLO_REQUEST          = 0,
    VCSFW_SSL_HS_CLIENT_HELLO           = 1,
    VCSFW_SSL_HS_SERVER_HELLO           = 2,
    VCSFW_SSL_HS_CERTIFICATE            = 11,
    VCSFW_SSL_HS_SERVER_KEY_EXCHANGE    = 12,
    VCSFW_SSL_HS_CERTIFICATE_REQUEST    = 13,
    VCSFW_SSL_HS_SERVER_HELLO_DONE      = 14,
    VCSFW_SSL_HS_CERTIFICATE_VERIFY     = 15,
    VCSFW_SSL_HS_CLIENT_KEY_EXCHANGE    = 16,
    VCSFW_SSL_HS_FINISHED               = 20,
    VCSFW_SSL_HS_DONE                   = 255 /* Handshake done (internal) */
} vcsfw_ssl_handshake_type_t;

/* Alert levels */
typedef enum vcsfw_ssl_alert_level_s
{
    VCSFW_SSL_ALERT_WARNING = 1,
    VCSFW_SSL_ALERT_FATAL   = 2
} vcsfw_ssl_alert_level_t;

/* Alert descriptions */
typedef enum vcsfw_ssl_alert_description_s
{
    VCSFW_SSL_ALERT_CLOSE_NOTIFY            = 0,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE      = 10,   /* fatal */
    VCSFW_SSL_ALERT_BAD_RECORD_MAC          = 20,   /* fatal */
    VCSFW_SSL_ALERT_HANDSHAKE_FAILURE       = 40,   /* fatal */
    VCSFW_SSL_ALERT_NO_CERTIFICATE          = 41,
    VCSFW_SSL_ALERT_BAD_CERTIFICATE         = 42,
    VCSFW_SSL_ALERT_UNSUPPORTED_CERTIFICATE = 43,
    VCSFW_SSL_ALERT_CERTIFICATE_REVOKED     = 44,
    VCSFW_SSL_ALERT_CERTIFICATE_EXPIRED     = 45,
    VCSFW_SSL_ALERT_CERTIFICATE_UNKNOWN     = 46,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER       = 47,   /* fatal */
    VCSFW_SSL_ALERT_RESUME_DONE             = 50    /* Resume done (internal) */
#if defined(VCSFW_SSL_DEBUG)
    ,VCSFW_SSL_ALERT_ILLEGAL_PARAMETER1     = 101,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER2      = 102,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER3      = 103,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER4      = 104,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER5      = 105,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER6      = 106,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER7      = 107,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER8      = 108,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER9      = 109,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER10     = 110,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER11     = 111,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER12     = 112,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER13     = 113,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER14     = 114,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER15     = 115,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER16     = 116,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER17     = 117,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER18     = 118,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER19     = 119,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER20     = 120,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER21     = 121,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER22     = 122,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER23     = 123,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER24     = 124,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER25     = 125,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER26     = 126,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER27     = 127,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER28     = 128,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER29     = 129,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER30     = 130,
    VCSFW_SSL_ALERT_ILLEGAL_PARAMETER31     = 131,
    VCSFW_SSL_ALERT_HANDSHAKE_FAILURE1      = 141,
    VCSFW_SSL_ALERT_HANDSHAKE_FAILURE2      = 142,
    VCSFW_SSL_ALERT_BAD_RECORD_MAC1         = 151,
    VCSFW_SSL_ALERT_BAD_RECORD_MAC2         = 152,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE1     = 161,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE2     = 162,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE3     = 163,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE4     = 164,
    VCSFW_SSL_ALERT_UNEXPECTED_MESSAGE5     = 165
#endif /* defined(VCSFW_SSL_DEBUG) */
} vcsfw_ssl_alert_description_t;

/* Constants used in Finished hash calculation */
typedef enum vcsfw_ssl_sender_s
{
    VCSFW_SSL_NOT_SPECIFIED = 0,
    VCSFW_SSL_CLIENT        = 0x434C4E54,   /* "CLNT" */
    VCSFW_SSL_SERVER        = 0x53525652    /* "SRVR" */
} vcsfw_ssl_sender_t;

/* Constants used in Finished hash and MAC calculations */
typedef enum vcsfw_ssl_pad_s
{
    VCSFW_SSL_PAD1_PAD  = 0x36,
    VCSFW_SSL_PAD2_PAD  = 0x5c
} vcsfw_ssl_pad_t;

typedef struct vcsfw_ssl_cipher_spec_s
{
    vcsUint16_t id;            /* cipher suite id */
    vcsUint8_t  key_size;      /* key size */
} vcsfw_ssl_cipher_spec_t;

typedef struct VCS_PACKED vcsfw_ssl_handshake_header_s
{
    vcsUint8_t              type;           /* vcsfw_ssl_handshake_type_t */
    vcsUint8_t              length[3];      /* handshake message length */
} vcsfw_ssl_handshake_header_t;

#define VCSFW_SSL_HANDSHAKE_HEADER_SIZE   sizeof(vcsfw_ssl_handshake_header_t)

#if defined(VCSFW_SSL_USE_RSA)

typedef struct vcsfw_ssl_rsa_pub_key_s
{
    vcsUint32_t length;
    vcsUint32_t pub_exp;
    vcsUint8_t  modulus[VCSFW_SSL_RSA_KEYLEN];
} vcsfw_ssl_rsa_pub_key_t;

typedef struct vcsfw_rsa_ssl_certificate_s
{
    vcsfw_ssl_rsa_pub_key_t* pub_key;
} vcsfw_ssl_rsa_certificate_t;

typedef struct VCS_PACKED vcsfw_ssl_certificate_s
{
    vcsfw_ssl_handshake_header_t hs_head;
    vcsUint8_t                   chain_length[3]; /* certificate chain length */
    vcsUint8_t                   length[3];       /* certificate length */
    vcsfw_ssl_rsa_pub_key_t      pub_key;         /* certificate buffer */
} vcsfw_ssl_certificate_t;
#endif /* defined(VCSFW_SSL_USE_RSA) */

typedef struct vcsfw_ssl_ctx_s
{
#if defined(VCSFW_SSL_RESUME)
    vcsUint8_t* session_id;     /* session identifier */
#endif

    vcsUint8_t  master_secret[VCSFW_SSL_MASTER_SECRET_SIZE];
    vcsUint8_t* client_random;
    vcsUint8_t* server_random;

    /* storage for the followed 6(4) items */
    vcsUint8_t  key_block[VCSFW_SSL_MAX_KEY_BLOCK_SIZE];
#if defined(VCSFW_SSL_USE_MAC)
    vcsUint8_t* read_mac_secret;
    vcsUint8_t* write_mac_secret;
#endif
    vcsUint8_t* read_key;
    vcsUint8_t* write_key;
    vcsUint8_t* read_iv;
    vcsUint8_t* write_iv;

#if defined(VCSFW_SSL_USE_MAC)
    vcsUint8_t  write_seq_num[VCSFW_SSL_SEQUENCE_NUMBER_SIZE];
    vcsUint8_t  read_seq_num[VCSFW_SSL_SEQUENCE_NUMBER_SIZE];
#endif

    const vcsfw_ssl_cipher_spec_t* cipher_spec;
    vcsfw_ssl_handshake_type_t hs_state;  /* expected handshake message type */

#if defined(VCSFW_SSL_USE_RSA)
    vcsfw_ssl_rsa_certificate_t server_cert;
    vcsfw_ssl_rsa_certificate_t client_cert;
#endif /* defined(VCSFW_SSL_USE_RSA) */

    void*       hs_md5;         /* MD5 context */
    void*       hs_sha;         /* SHA context */

    vcsUint32_t flags;          /* state flags */
    vcsUint32_t msg_len;        /* reply or application message length */

} vcsfw_ssl_ctx_t;

typedef struct VCS_PACKED vcsfw_ssl_version_s
{
    vcsUint8_t              major;          /* major version */
    vcsUint8_t              minor;          /* minor version */
} vcsfw_ssl_version_t;

typedef struct VCS_PACKED vcsfw_ssl_record_header_s
{
    vcsUint8_t              type;           /* vcsfw_ssl_record_type_t */
    vcsfw_ssl_version_t     version;        /* protocol version */
    vcsUint8_t              length[2];      /* record length */
} vcsfw_ssl_record_header_t;

#define VCSFW_SSL_RECORD_HEADER_SIZE      sizeof(vcsfw_ssl_record_header_t)

typedef struct VCS_PACKED vcsfw_ssl_finished_s
{
    vcsfw_ssl_handshake_header_t    hs_head;
    vcsUint8_t                      hash[VCSFW_SSL_FINISHED_HASH_SIZE];
} vcsfw_ssl_finished_t;

typedef struct VCS_PACKED vcsfw_ssl_change_cipher_spec_s
{
    vcsfw_ssl_record_header_t       rec_head;
    vcsUint8_t                      action;         /* always 1 */
} vcsfw_ssl_change_cipher_spec_t;

typedef struct VCS_PACKED vcsfw_ssl_alert_s
{
    vcsfw_ssl_record_header_t  rec_head;
    vcsUint8_t                 level;       /* vcsfw_ssl_alert_level_t */
    vcsUint8_t                 description; /* vcsfw_ssl_alert_description_t */
} vcsfw_ssl_alert_t;

/****************************************************************************/
/* TLS definitions                                                          */
/****************************************************************************/

/* TLS version: TLS 1.2 is denoted as SSL 3.3 */
#define VCSFW_TLS_VER12_MAJOR               3
#define VCSFW_TLS_VER12_MINOR               3

/* Patch levels for TLS (bit offsts 7, 6, ...). */
/*
 * PATCH1: FIX: seq num is omitted from MAC: BPDFW-605.
 */
#define VCSFW_TLS_PATCH1                    7

/* TLS size definitions */
#define VCSFW_TLS_PREMASTER_SECRET_SIZE     48
#define VCSFW_TLS_MASTER_SECRET_SIZE        48
#define VCSFW_TLS_SEQUENCE_NUMBER_SIZE      8
#define VCSFW_TLS_SESSION_ID_MAX_SIZE       32
#define VCSFW_TLS_SESSION_ID_SIZE           7
#define VCSFW_TLS_RANDOM_SIZE               32
#define VCSFW_TLS_FINISHED_HASH_SIZE        12   /* Truncated SHA256 */
#define VCSFW_TLS_MAC_SIZE                  32
#define VCSFW_TLS_MAX_KEY_BLOCK_SIZE                                           \
    (2 * (VCSFW_TLS_MAC_SIZE + 32))
#define VCSFW_TLS_KEY_BLOCK_SIZE(cipher_specp)                                 \
    (2 * (VCSFW_TLS_MAC_SIZE + cipher_specp->sym_key_size))
#define VCSFW_TLS_MAX_TAIL_SIZE                                                \
    (VCSFW_TLS_MAC_SIZE + 16 /* AES block size. */)

/* Padding length for AES algorithm (block size = 16).  */
#define VCSFW_TLS_PAD_LEN_AES(rec_len) ((vcsUint8_t)(0x10 - ((rec_len) & 0x0f)))

/* TLS record size limitations */
#define VCSFW_TLS_MAX_PLAINTEXT_SIZE        0x00010000  /* 64 KB */
#define VCSFW_TLS_MAX_RECORD_SIZE           (VCSFW_TLS_MAX_PLAINTEXT_SIZE +    \
                                             VCSFW_TLS_MAX_TAIL_SIZE * 2)

/* Labels */
#define VCSFW_TLS_FINISHED_LABEL_CLIENT     "client finished"
#define VCSFW_TLS_FINISHED_LABEL_SERVER     "server finished"
#define VCSFW_TLS_FINISHED_LABEL_LENGTH     15

#define VCSFW_TLS_KEYGEN_LABEL              "key expansion"
#define VCSFW_TLS_KEYGEN_LABEL_LENGTH       13

#define VCSFW_TLS_MASTERSECRET_LABEL        "master secret"
#define VCSFW_TLS_MASTERSECRET_LABEL_LENGTH 13

/* Supported cipher suits. */
#define VCSFW_TLS_NULL_WITH_NULL_NULL              0x0000
#define VCSFW_TLS_RSA_WITH_AES_256_CBC_SHA256      0x003D
#define VCSFW_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA  0xC005
#define VCSFW_TLS_PSK_WITH_AES_256_CBC_SHA         0x008D /* RFC4279 */

/* The PSK identities. */
#define VCSFW_TLS_PSK_IDENTITY0                    0x0000

/* Record types */
#define VCSFW_TLS_RT_CHANGE_CIPHER_SPEC     20
#define VCSFW_TLS_RT_ALERT                  21
#define VCSFW_TLS_RT_HANDSHAKE              22
#define VCSFW_TLS_RT_APPLICATION_DATA       23

/* Handshake message types */
#define VCSFW_TLS_HS_HELLO_REQUEST          0
#define VCSFW_TLS_HS_CLIENT_HELLO           1
#define VCSFW_TLS_HS_SERVER_HELLO           2
#define VCSFW_TLS_HS_CERTIFICATE            11
#define VCSFW_TLS_HS_SERVER_KEY_EXCHANGE    12
#define VCSFW_TLS_HS_CERTIFICATE_REQUEST    13
#define VCSFW_TLS_HS_SERVER_HELLO_DONE      14
#define VCSFW_TLS_HS_CERTIFICATE_VERIFY     15
#define VCSFW_TLS_HS_CLIENT_KEY_EXCHANGE    16
#define VCSFW_TLS_HS_FINISHED               20
#define VCSFW_TLS_HS_DONE                   255 /* Handshake done (internal) */

/* Alert levels */
#define VCSFW_TLS_ALERT_WARNING             1
#define VCSFW_TLS_ALERT_FATAL               2

/* Alert descriptions */
#define VCSFW_TLS_ALERT_CLOSE_NOTIFY            0
#define VCSFW_TLS_ALERT_UNEXPECTED_MESSAGE      10  /* fatal */
#define VCSFW_TLS_ALERT_BAD_RECORD_MAC          20  /* fatal */
#define VCSFW_TLS_ALERT_HANDSHAKE_FAILURE       40  /* fatal */
#define VCSFW_TLS_ALERT_NO_CERTIFICATE          41
#define VCSFW_TLS_ALERT_BAD_CERTIFICATE         42
#define VCSFW_TLS_ALERT_UNSUPPORTED_CERTIFICATE 43
#define VCSFW_TLS_ALERT_CERTIFICATE_REVOKED     44
#define VCSFW_TLS_ALERT_CERTIFICATE_EXPIRED     45
#define VCSFW_TLS_ALERT_CERTIFICATE_UNKNOWN     46
#define VCSFW_TLS_ALERT_ILLEGAL_PARAMETER       47  /* fatal */
#define VCSFW_TLS_ALERT_UNKNOWN_PSK_IDENTITY    115 /* fatal */
#define VCSFW_TLS_ALERT_RESUME_DONE             50  /* Resume done (internal) */


/* Certificate types */
#define VCSFW_TLS_CERT_TYPE_RSA_SIGN            1   /* RSA certificate */
#define VCSFW_TLS_CERT_TYPE_ECDSA_SIGN          64  /* ECDSA certificate */

/* Supported TLS extension types. */
#define VCSFW_TLS_EXT_TYPE_CURVE     0x000A  /* Supported Elliptic Curve ext. */
#define VCSFW_TLS_EXT_TYPE_POINT     0x000B  /* Supported Point Formats ext.  */

/* IDs of supported elliptic curve families. */
#define VCSFW_TLS_ECC_PRIME_CURVES   0xFF01

/* Supported ECC point formats */
#define VCSFW_TLS_POINT_FORMAT_UNCOMPRESSED     0

/* -------------------------------------------------------------------------- */
/* TLS Message/record headers. */

/* Handshake message header. */
typedef struct VCS_PACKED vcsfw_tls_handshake_header_s
{
    vcsUint8_t              type;           /* vcsfw_tls_handshake_type_t */
    vcsUint8_t              length[3];      /* handshake message length   */
} vcsfw_tls_handshake_header_t;

/* TLS version */
typedef struct VCS_PACKED vcsfw_tls_version_s
{
    vcsUint8_t              major;          /* major version */
    vcsUint8_t              minor;          /* minor version */
} vcsfw_tls_version_t;

/* Record header. */
typedef struct VCS_PACKED vcsfw_tls_record_header_s
{
    vcsUint8_t              type;           /* vcsfw_tls_record_type_t */
    vcsfw_tls_version_t     version;        /* protocol version        */
    vcsUint8_t              length[2];      /* record length           */
} vcsfw_tls_record_header_t;

/* Extension header. */
typedef struct VCS_PACKED vcsfw_tls_ext_header_s
{
    vcsUint16_t ext_type;
    vcsUint16_t ext_len;
} vcsfw_tls_ext_header_t;

/* -------------------------------------------------------------------------- */
/* Common for Client and Server messages. */

/* "Finished" message */
typedef struct VCS_PACKED vcsfw_tls_finished_s
{
    vcsfw_tls_handshake_header_t    hs_head;
    vcsUint8_t                      hash[VCSFW_TLS_FINISHED_HASH_SIZE];
} vcsfw_tls_finished_t;

/* "ChangeCipherSpec" message */
typedef struct VCS_PACKED vcsfw_tls_change_cipher_spec_s
{
    vcsfw_tls_record_header_t    rec_head;
    vcsUint8_t                   action;         /* always 1 */
} vcsfw_tls_change_cipher_spec_t;

/* The alert message */
typedef struct VCS_PACKED vcsfw_tls_alert_s
{
    vcsUint8_t   level;       /* vcsfw_tls_alert_level_t */
    vcsUint8_t   description; /* vcsfw_tls_alert_description_t */
} vcsfw_tls_alert_t;

/* -------------------------------------------------------------------------- */
/* TLS extensions. */

/* Supported Elliptic Curve extension. */
typedef struct VCS_PACKED vcsfw_tls_ext_ecc_curve_s
{
    vcsfw_tls_ext_header_t header;          /* Extension header. */
    vcsUint16_t            data_len;        /* Length of the data below. */
    vcsUint16_t            iana_id_list[1]; /* IANA or custom ID of the curve or
                                            ** curve family */
} vcsfw_tls_ext_ecc_curve_t;

/* Supported Point Formats extension. */
typedef struct VCS_PACKED vcsfw_tls_ext_ecc_point_formats_s
{
    vcsfw_tls_ext_header_t header;            /* Extension header. */
    vcsUint8_t             data_len;          /* Length of the data below. */
    vcsUint8_t             format_id_list[1]; /* List of supported format IDs */
} vcsfw_tls_ext_ecc_point_formats_t;


/****************************************************************************/
/* Cal block definitions                                                    */
/****************************************************************************/
/*  Cal block definitions, used as block names to assign ordering of */
/* calibration blocks through the command interface. */
#define VCSFW_CAL_COMMDET    0
#define VCSFW_CAL_PGAGAIN    1
#define VCSFW_CAL_ADC        2
#define VCSFW_CAL_PGAOFFSET  3
#define VCSFW_CAL_WOE        4

/****************************************************************************/
/* Test definitions                                                         */
/* Used by Falcon Test tools build                                          */
/****************************************************************************/
#define VCS_TEST_INITVALUE  0xFFFFFFFF      /* Initial test result value */
#define VCS_TEST_PASSED     0x00000000      /* Passing code */
#define VCS_TEST_MEM_ADDR   0x60000004      /* Hard-coded RAM location to
                                             * get/set test result value */

/* Test result format: 0xLLLLCCCC where L = Line Number, C = Failure Code */
#define VCS_TEST_RESULT_SET(ln,id)  ( ((ln) << 16) + (id) )

/****************************************************************************/
/* Definitions regarding VCSFW_STORAGE_PART_...CFG flash partitions         */
/* (Metallica).                                                             */
/* Data in this partition is stored in                                      */
/* <2 byte TAGID><2 byte LEN><32byte HASH><data> format.                    */
/****************************************************************************/

/* GetPrint command blob / Baseline frame blob */
#define VCSFW_STORAGE_PART_PRINTCFG_TAGID_GETPRINT                      0x5001
#define VCSFW_STORAGE_PART_PRINTCFG_TAGID_BASELINE_FRAME                0x5002
/* Template statistics blob, for smart martching */
#define VCSFW_STORAGE_PART_CFG_TAGID_TEMPLATE_STATS                     0x5003
/* SYSTEMCFG blob  */
#define VCSFW_STORAGE_PART_SYSTEMCFG_TAGID_AUTOMODE                   0x5004
#define VCSFW_STORAGE_PART_SYSTEMCFG_TAGID_AUTH_SESSION               0x5005


/* The entry header. */
typedef struct VCS_PACKED vcsfw_storage_part_printcfg_entry_hdr_s
{
    vcsUint16_t tagid;
    /* Entry type - tag ID.                 */
    vcsUint16_t len;
    /* Data length coming after the header. */
    vcsUint8_t  hash[VCSFW_SHA256_HASH_SIZE];
    /* Data hash coming after the header.   */
    vcsUint8_t  mac[VCSFW_SHA256_HASH_SIZE];
    /* Data MAC coming after the header.
    * Maintained exclusively by firmware.  */
} vcsfw_storage_part_printcfg_entry_hdr_t;
/* Followed by the data of <len> length.
* GetPrint command / Baseline frame is in <2 byte length>+<data> format. */

/* VCSFW_STORAGE_PART_SYSTEMCFG_TAGID_* */
/* The entry header. */
typedef struct VCS_PACKED vcsfw_storage_part_systemcfg_entry_hdr_s
{
    vcsUint16_t tagid;
    /* Entry type - tag ID.                 */
    vcsUint16_t len;
    /* Data length coming after the header. */
    vcsUint8_t  hash[VCSFW_SHA256_HASH_SIZE];
    /* Data hash coming after the header.   */
    vcsUint8_t  mac[VCSFW_SHA256_HASH_SIZE];
    /* Data MAC coming after the header.
     * Maintained exclusively by firmware.  */
} vcsfw_storage_part_systemcfg_entry_hdr_t;

/*  For tagid VCSFW_STORAGE_PART_SYSTEMCFG_TAGID_AUTOMODE the data followed
 *  should be of below defined structure */

typedef struct VCS_PACKED vcsfw_automode_cfg_s
{
    vcsUint32_t  flags;
    /* time to wait for finger. It exits auto mode after the timeout. 0 for infinite */
    vcsUint32_t fdetect_timeout;
    /* time to wait to hold the authentication results. 0 for infinite */
    vcsUint32_t auth_results_timeout;
    /* feature to use gpio to enter into auto mode. */
    vcsUint8_t enable_gpio;
} vcsfw_automode_cfg_t;

/* tagid VCSFW_STORAGE_PART_SYSTEMCFG_TAGID_AUTH_SESSION, the data followed
 * should be same as the one sent for VCSFW_CMD_AUTH_SESSION_START */

/****************************************************************************/
/* IMAGE RECON definitions                                                   */
/****************************************************************************/

#define VCSFW_IMAGE_RECON_STATUS_FINGER_DETECTED                    0x1
#define VCSFW_IMAGE_RECON_STATUS_CAPTURE_PROGRESS                   0x2
#define VCSFW_IMAGE_RECON_STATUS_FINGER_SETTLED                     0x3
#define VCSFW_IMAGE_RECON_STATUS_IMAGE_READY                        0x4
#define VCSFW_IMAGE_RECON_STATUS_FINGER_ON_SENSOR                   0x5
#define VCSFW_IMAGE_RECON_STATUS_FINGER_REMOVED                     0x6
#define VCSFW_IMAGE_RECON_STATUS_IMAGE_ACQUISITION_NO_IMAGE         0x7
#define VCSFW_IMAGE_RECON_STATUS_CAPTURE_ERROR                      0x8
#define VCSFW_IMAGE_RECON_STATUS_FRAME_READY                        0x9

#define VCSFW_IMAGE_RECON_STATUS                   0x03

typedef struct VCS_PACKED vcsfw_image_recon_status_s
{
    vcsUint8_t   status;
    vcsUint8_t   reserved;
    vcsUint16_t  ir_status;
    vcsUint8_t   magic;
} vcsfw_image_recon_status_t;


/****************************************************************************/
/* Frame tag definitions                                                    */
/****************************************************************************/

/* VCSFW_FRAME_TAG */
typedef struct VCS_PACKED vcsfw_frame_tag_s {
    vcsUint16_t   nwords;    /* number of 32-bit to follow */
    vcsUint8_t    flags;
    vcsUint8_t    tagid;
} vcsfw_frame_tag_t;


/* frame tag flags */
#define VCSFW_FRAME_TAG_FLAG_ORIGIN             0xc0
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_B           6
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_N           2
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_FWHW        0
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_HOST        1
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_FLASH       2
#define VCSFW_FRAME_TAG_FLAG_ORIGIN_LPRAM       3       /* low-power RAM */
/*
 * This next flag is informational as far as the mission firmware
 *  is concerned and it tells the world that this particular
 *  tag contains sensor instance-specific data (e.g., calibration).
 * This flag is intended to be used by flash-rewriting patches
 *  which need to preserve sensor instance-specific data.
 */
#define VCSFW_FRAME_TAG_FLAG_INSTSPEC           0x20


/* frame tags  */
#define VCSFW_FRAME_TAG_FW_BL    1 /* "Firmware" baseline RAM
                                     (HWDEF_MEMMAP_FW_BL_RAM) */
#define VCSFW_FRAME_TAG_LNA_BL   2/*LNA baseline RAM (HWDEF_MEMMAP_LNA_BL_RAM)*/
#define VCSFW_FRAME_TAG_DM       3 /* Drive matrix (HWDEF_MEMMAP_DMRAM) */
#define VCSFW_FRAME_TAG_CDM      4 /* Code-division multiplex decode
                                    matrix (HWDEF_MEMMAP_CDMRAM) */
#define VCSFW_FRAME_TAG_REG32BLK 5 /* A block of 32-bit registers */
#define VCSFW_FRAME_TAG_REG16BLK 6 /* A block of 16-bit registers */
#define VCSFW_FRAME_TAG_DIMS     7 /* Frame tag units */
#define VCSFW_FRAME_TAG_ACQOPT   8 /* Acqusition options (HOST ONLY) */
#define VCSFW_FRAME_TAG_XSREG8BLK 9 /* External Sensor 8bit register block */
#define VCSFW_FRAME_TAG_STRIDEBLK 10
#define VCSFW_FRAME_TAG_STATS   11  /* Gather image statistics */
#define VCSFW_FRAME_TAG_ACQCFG   12 /* Acqusition config options */
#define VCSFW_FRAME_TAG_ORIENTPITCH 13 /* information about preferred
                                      *  image orientation and pixel/line
                                      *  pitch.  Currently advisory
                                      *  only (data are not used to change
                                      *  firmware's image processing flow). */
#define VCSFW_FRAME_TAG_IMGPROC_CROP    14  /* image processing, crop filter */
#define VCSFW_FRAME_TAG_IMGPROC_DYNBPDET 15  /* image processing, dynamic bad
                                              *  pixel detection */
#define VCSFW_FRAME_TAG_IMGPROC_3X3SEPSQ 16  /* image processing, 3x3 matrix
                                              *  multiplication (separable
                                              *  squared matrix). */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE  17  /* image processing, selective
                                              *  filter disabling */

/* Development-only tags: */


/* VCSFW_FRAME_TAG_REG32BLK */
typedef struct VCS_PACKED vcsfw_frame_tag_reg32blk_s {
    vcsUint16_t  regbase;
    vcsUint16_t  nregs;
} vcsfw_frame_tag_reg32blk_t;


/* VCSFW_FRAME_TAG_REG16BLK */
typedef struct VCS_PACKED vcsfw_frame_tag_reg16blk_s {
    vcsUint16_t  regbase;
    vcsUint16_t  nregs;
} vcsfw_frame_tag_reg16blk_t;

/* VCSFW_FRAME_TAG_DIMS */
typedef struct VCS_PACKED vcsfw_frame_tag_dims_s {
    vcsUint16_t     bitdepth;       /* bits per pixel (1, 2, 4, 8, 12?, 16) */

    /* frame (line counts) */
    vcsUint16_t     frame_nlines;   /* total number of lines per frame (Y-Dim)*/
    vcsUint16_t     frame_header;   /* number of bytes of per-frame header */
    vcsUint16_t     frame_lineskip; /* lines to skip at beginning of frame */
    vcsUint16_t     frame_linesusable;  /* lines to use for a frame */

    /* line (pixel counts) */
    vcsUint16_t     line_npix;      /* total number of pixels across (X-Dim)*/
    vcsUint16_t     line_header;    /* number of bytes to skip to get to pix0*/
    vcsUint16_t     line_pixskip;   /* pixels to skip at beginning of line
                                     * (with sub-8 bpp could be a fractional
                                     * byte) */
    vcsUint16_t     line_pixusable; /* pixels to use on line */

    vcsUint16_t     unused;
} vcsfw_frame_tag_dims_t;
/*
 * total_frame_size (in bytes) = frame_header
 *        + frame_nlines * (line_header + ROUNDUP(line_npix / pixels_per_byte))
 */

/* VCSFW_FRAME_TAG_ACQOPT */
/*
 * This tag is meant only to be sent by the host to the sensor.
 *  It is not meant to be stored in flash or in the mission firmware.
 */
typedef struct VCS_PACKED vcsfw_frame_tag_acqopt_s {
    vcsUint8_t      mode;
    vcsUint8_t      trigger;
    vcsUint8_t      filter;
    vcsUint8_t      trigger_event;
} vcsfw_frame_tag_acqopt_t;

#define VCSFW_FRAME_TAG_ACQOPT_MODE_RAW         0x00
#define VCSFW_FRAME_TAG_ACQOPT_MODE_IMAGE       0x01
#define VCSFW_FRAME_TAG_ACQOPT_MODE_NAV         0x02

#define VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NONE     0x00
#define VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NORMAL   0x01
#define VCSFW_FRAME_TAG_ACQOPT_TRIGGER_EVENT    0x02

#define VCSFW_FRAME_TAG_ACQOPT_FILTER_NONE      0x00
#define VCSFW_FRAME_TAG_ACQOPT_FILTER_NORMAL    0x01
#define VCSFW_FRAME_TAG_ACQOPT_FILTER_FPPRESENT 0x02

/* VCSFW_FRAME_TAG_ACQCFG */
/*
 * This tag is meant only to be sent by the host to the sensor.
 *  It is not meant to be stored in flash or in the mission firmware.
 * The 'min_interframe_gap_ms' specifies minimum delay between the each frames
 * 'max_buffered_frames' is used for maximum number frames used.
 */
typedef struct VCS_PACKED vcsfw_frame_tag_acqcfg_s {
    vcsUint16_t     min_interframe_gap_ms;
    vcsUint8_t      max_buffered_frames;
    vcsUint8_t      unused;
} vcsfw_frame_tag_acqcfg_t;


/* VCSFW_FRAME_TAG_XSREG8BLK */
typedef struct VCS_PACKED vcsfw_frame_tag_xsreg8blk_s {
    vcsUint32_t  flags;
} vcsfw_frame_tag_xsreg8blk_t;

#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE     0x00ffffff
#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE_B       0
#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE_N       24
#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS       0x03000000
#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS_B         24
#define VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS_N         2

/* VCSFW_FRAME_TAG_STRIDEBLK */
typedef struct VCS_PACKED vcsfw_frame_tag_strideblk_s {
    vcsUint32_t  regbase;
    vcsUint16_t  nregs;
    vcsUint16_t  stride;
    vcsUint32_t  val;
} vcsfw_frame_tag_strideblk_t;

/* VCSFW_FRAME_TAG_STATS */
/*
 * This tag tells the sensor to acquire statistics about the image
 *  data.  Note that this tag is a little different from other tags
 *  in that it is not "sticky" -- a new instance of a VCSFW_FRAME_TAG_STATS
 *  must be sent down with each VCSFW_CMD_FRAME_ACQ.
 * The 'types' member specifies which types of statistics the
 *  host is interested in (the specific statistics will be retrieved later
 *  using the 'VCSFW_CMD_FRAME_STATS_GET' command).
 * 'flags' is used to tell the sensor to send the data to the host
 *  in addition to accumulating statistics.  Right now this is
 *  not supported.
 * 'skipnframes' tells the sensor to acquire that many frames before
 *  starting the statistical analysis.
 */
typedef struct VCS_PACKED vcsfw_frame_tag_stats_s {
    vcsUint32_t  types;
    vcsUint16_t  flags;
    vcsUint16_t  skipnframes;
} vcsfw_frame_tag_stats_t;

#define VCSFW_FRAME_TAG_STATS_TYPES_PIXSTDDEV                               \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_PIXSTDDEV - 1))
#define VCSFW_FRAME_TAG_STATS_TYPES_PIXAVG                                  \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_PIXAVG - 1))
#define VCSFW_FRAME_TAG_STATS_TYPES_COLSTDDEV                               \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_COLSTDDEV - 1))
#define VCSFW_FRAME_TAG_STATS_TYPES_COLAVG                                  \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_COLAVG - 1))
#define VCSFW_FRAME_TAG_STATS_TYPES_ROWSTDDEV                               \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_ROWSTDDEV - 1))
#define VCSFW_FRAME_TAG_STATS_TYPES_ROWAVG                                  \
    (0x00000001 << (VCSFW_FRAME_STATS_TYPE_ROWAVG - 1))


#define VCSFW_FRAME_TAG_STATS_FLAGS_IMGDATA  0x0001 /* send image data too */


/*
 * VCSFW_FRAME_TAG_ORIENTPITCH
 * Image orientation and pixel pitch information.
 *
 * This describes the raw sensor, and currently is simply
 *  passthrough information to the host (in the form of the extended
 *  reply to VCSFW_CMD_FRAME_ACQ).
 * Future firmware could use this information directly, but
 *  it would probably require the ability to buffer more than
 *  one full frame.
 */
typedef struct VCS_PACKED vcsfw_frame_tag_orientpitch_s {
    vcsUint32_t     pixpitch;       /* intraline pixel pitch (nanometers) */
    vcsUint32_t     linepitch;      /* interline pixel a/k/a
                                     *  line-to-line pitch (nanometers) */
    vcsUint8_t      orient;         /* orientation information */
/*
 * The orientation information describes how the receiver of
 *  the image should best adjust it for use.  This information is
 *  really advisory in that the firmware doesn't really use it,
 *  it only returns it as part of the reply to the VCSFW_CMD_FRAME_ACQ.
 *  (in the VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_MIRROR and
 *  VCSFW_REPLY_FRAME_ACQ_BITINFO_ORIENT_ROT fields of the
 *  vcsfw_reply_frame_acq_t::bitinfo member).
 * The receiver of the data should first apply mirroring, if
 *  specified, followed by the rotation, if specified.
 * Note that the layout of this information matches
 */

/* after optional mirroring, clockwise rotation count: */
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT          0x03
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_B            0
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_N            2
/* possible rotation values: */
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_CW0          0
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_CW90         1
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_CW180        2
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_ROT_CW270        3
/* first transformation to do: mirror data along lines: */
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_MIRROR       0x04
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_MIRROR_B         2
#define VCSFW_FRAME_TAG_ORIENTPITCH_ORIENT_MIRROR_N         1

    vcsUint8_t      unused[3];      /* to bring structure to n*4 bytes */
} vcsfw_frame_tag_orientpitch_t;

/*
 * CPID standard order of operations is:
 *    1. temperature estimation and dark current correction
 *       (currently unimplemented)
 *    2. background mean subtraction a/k/a "baseline" and static bad
 *       pixel marking ("blpmk")
 *    3. cropping ("crop")
 *    4. dynamic bad pixel detection ("dynbpdet")
 *    5. bad pixel interpolation ("bpinterp")
 *    6. 3x3 separable-square matrix multiply ("3x3sepsq")
 *    7. resolution reduction a/k/a down-sampling ("reshalf")
 *
 * Steps 3 ("crop"), 4 ("dynbpdet") and 6 ("3x3sepsq") have parameters.
 * Despite the fact that these processes are first described for
 *  CPID it's perfectly possible they'll be useful in future
 *  non-CPID sensors.  So I'm naming them generically as
 *  "IMGPROC" (image processing) parameters.
 */

/* VCSFW_FRAME_TAG_IMGPROC_CROP */
typedef struct VCS_PACKED vcsfw_frame_tag_imgproc_crop_s {
    vcsUint16_t     top;        /* top margin (in lines) */
    vcsUint16_t     bottom;     /* bottom margin (in lines) */
    vcsUint16_t     left;       /* left margin (in pixels) */
    vcsUint16_t     right;      /* right margin (in pixels) */
} vcsfw_frame_tag_imgproc_crop_t;

/* VCSFW_FRAME_TAG_IMGPROC_DYNBPDET */
typedef struct VCS_PACKED vcsfw_frame_tag_imgproc_dynbpdet_s {
    vcsUint16_t     threshold;  /* threshold above/below median for
                                 *  when a pixel can be considered
                                 *  bad. */
} vcsfw_frame_tag_imgproc_dynbpdet_t;

/* VCSFW_FRAME_TAG_IMGPROC_3X3SEPSQ */
/*
 * This transform defines a 3x3 matrix multiplication.
 *  The 3x3 matrix is formed by multiplying the given vector
 *  by its transpose.
 * Because the math in the firmware is done using 32-bit
 *  operations the valid range for the vector is limited.
 *  Assuming 12-bit unsigned pixel data the biggest product
 *  of any two elements in the vector must be < (2^20/9)=116508.
 *  If we restrict the elements to sqrt(2^20/9) = 2^10/3=341 then
 *  we'll be alright.
 */

typedef struct VCS_PACKED vcsfw_frame_tag_imgproc_3x3sepsq_s {
     vcsUint16_t    vector[3]; /* 3 element vector, squared for transform */
     vcsUint16_t    normal;    /* normalizing denominator */
} vcsfw_frame_tag_imgproc_3x3sepsq_t;

/* VCSFW_FRAME_TAG_IMGPROC_DISABLE */
/*
* This tag allows the host to selectively disable individual
*  steps in the flow.  Note that this is a very crude
*  instrument.  You can't change the order of the steps and if,
*  at some future time we use the same step twice you
*  can only turn off both instances.
*/
typedef struct VCS_PACKED vcsfw_frame_tag_imgproc_disable_s {
    vcsUint32_t      filters;
     /* disable the baseline subtraction + static bad pixel marking: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_BLBPMK      0x0000001
     /* disable the cropping: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_CROP        0x0000002
     /* disable the dynamic bad pixel detection: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_DYNBPDET    0x0000004
     /* disable the bad pixel interpolation: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_BPINTERP    0x0000008
     /* disable the 3x3 matrix multiply: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_3X3SEPSQ    0x0000010
     /* disable the 50% resolution reduction: */
#define VCSFW_FRAME_TAG_IMGPROC_DISABLE_FILTERS_RESHALF     0x0000020

} vcsfw_frame_tag_imgproc_disable_t;

/*
 * iotas are blocks of bytes that are stored in non-volatile
 *  storage in a part.  These are first implemented in the Nassau
 *  firmware, first released with Denali.
 * iotas are identified by a 16-bit type.  iotas types with the
 *  high bit (0x8000) set are reserved for host use and considered
 *  opaque to the firmware.
 */
#define VCSFW_IOTA_ITYPE_NOP            0x0000 /* ignore this iota */
/* The FRAME_XXX iotas are composed of frame-tags and are parsed when an
 * ACQOPT tag is received.  The mode field of the ACQOPT initiates loading
 * the associated iota.
 */
#define VCSFW_IOTA_ITYPE_FRAME_BASE     0x0001 /* base FRAME_TAG configuration */
#define VCSFW_IOTA_ITYPE_FRAME_NAV      0x0002 /* nav FRAME_TAG configuration */
#define VCSFW_IOTA_ITYPE_FRAME_IMAGE    0x0003 /* image FRAME_TAG configuration */
/* The CONFIG_PSELECT iota specifies tuning of the partial-scan
 * frame-selection algorithm.  Full documentation is at:
 * https://confluence.synaptics.com/download/attachments/39683013/Partial%20Scan%20Select%20Firmware.docx?api=v2
 */
#define VCSFW_IOTA_ITYPE_CONFIG_PSELECT 0x0004 /* Partial scan parameters */
#define VCSFW_IOTA_ITYPE_CONFIG_WOE     0x0005
/* The CONFIG_WOF_THRESHOLDS is used to apply WOF calibration settings
 * to the WOF registers.  More details are found with the definition of
 * vcsfw_config_wof_thresholds_t below.
 */
#define VCSFW_IOTA_ITYPE_CONFIG_WOF_THRESHOLDS  0x0006
#define VCSFW_IOTA_ITYPE_CAL_REFERENCE  0x0007 /* Reference image from cal */
#define VCSFW_IOTA_ITYPE_BAD_PIXEL_MAP  0x0008 /* Bad pixel map info */
#define VCSFW_IOTA_ITYPE_CONFIG_VERSION 0x0009 /* Configuration id and version */
#define VCSFW_IOTA_ITYPE_CONFIG_NAV_SWIPE 0x000A
#define VCSFW_IOTA_ITYPE_CONFIG_NAV_TAP 0x000B
#define VCSFW_IOTA_ITYPE_CONFIG_FRAME_AVG 0x000C
/* The FPPRESENT_PARAMS iota specifies tuning of the fingerprint-presence
 * verification algorithm used for false trigger rejection.  Full
 * documentation is at:
 * https://confluence.synaptics.com/download/attachments/62957096/FPPresent_filtering_algorithm.docx?api=v2
 */
#define VCSFW_IOTA_ITYPE_FPPRESENT_PARAMS 0x000D
#define VCSFW_IOTA_ITYPE_CPID_ATTRIBUTES  0x000E
#define VCSFW_IOTA_ITYPE_CONFIG_BL_MGT    0x000F
#define VCSFW_IOTA_ITYPE_CAL_GAIN         0x0010 /* Reference image from cal */
#define VCSFW_IOTA_ITYPE_CAL_BACKGROUND   0x0011 /* Background image from cal */
#define VCSFW_IOTA_ITYPE_CAL_DARK_CURRENT 0x0012 /* Dark Current image from cal */
#define VCSFW_IOTA_ITYPE_CPID_CAL_LONG_INTEGRATION   0x0013 /* Long Interpolation 500 DPI image from cal */
#define VCSFW_IOTA_ITYPE_CPID_CAL_DARK_RATE_MAP_1000DPI   0x0014 /* CPID dark rate map saved at 1000 DPI */
#define VCSFW_IOTA_ITYPE_CONFIG_TEST_HISTORY 0x0015 /* MT test history */
/* The FOREGROUND_IMAGE used by image processing library.  The firmware does
* not parse it.  More details are below with vcsfw_config_foreground_img_t. */
#define VCSFW_IOTA_ITYPE_FOREGROUND_IMAGE 0x0016
/* The MISSION_SHA256 iota is used to store the SHA256 of the mission
 * firmware.  This is generated by the missionsha256 patch, and written by
 * module-test or in-system test.  This way if the mission firmware becomes
 * corrupt, the host can identify so. */
#define VCSFW_IOTA_ITYPE_MISSION_SHA256   0x0017

/* Specific to CPID: Temporal standard deviation of reference high frames */
#define VCSFW_IOTA_ITYPE_CPID_CAL_TEMPORAL_STD_DEV_REF_HIGH_FRAMES   0x0018

/* Specific to CPID: Mean background + Bad_Pixel map: This is combination of mean background image
  *                           where bad_pixel values are marked by a special value (say 4095).
  *                           The bad_pixels are determined from RefHigh - Ref.
  */
#define VCSFW_IOTA_ITYPE_CPID_CAL_MEAN_BGD_BAD_PIXELS   0x0019 /* CPID dark rate map saved at 1000 DPI */

/* The IPL_PARAM and IPL_METRIC iotas are pass-through iotas used to configure
 *the host-side image processing library.  */
#define VCSFW_IOTA_ITYPE_IPL_PARAM     0x001A
#define VCSFW_IOTA_ITYPE_IPL_METRIC    0x001B


#define VCSFW_IOTA_ITYPE_CHAINEND       0xFFFF /* end of the chain (internal) */



/* Specific to CPID: Temporal standard deviation of reference high frames
  * #define VCSFW_IOTA_ITYPE_CPID_CAL_TEMPORAL_STANDARD_DEVIATION_OF_REFERENCE_HIGH_FRAMES
  */
typedef struct VCS_PACKED vcsfw_cpid_cal_temporal_std_dev_ref_high_frames_s{
        vcsUint32_t   temporal_std_dev_ref_high_frames;
} vcsfw_cpid_cal_temporal_std_dev_ref_high_frames_t;



/* VCSFW_IOTA_ITYPE_BAD_PIXEL_MAP */
/*
 * This iota contains the count of the bad pixels followed by the actual bad pixel indices.
 */
typedef struct VCS_PACKED vcsfw_cpid_bad_pixel_map_imaging_data_s{
    vcsUint32_t   badpixelcount;
    vcsUint16_t   adc_offset;
    vcsUint8_t    unused[2];
} vcsfw_cpid_bad_pixel_map_imaging_data_t;


/* VCSFW_IOTA_ITYPE_CPID_ATTRIBUTES */
/*
 * This iota contains the CPID attributes.
 */
typedef struct VCS_PACKED vcsfw_cpid_attributes_s{
    vcsUint8_t    sensor_type;
    vcsUint8_t    optical_layer;
    vcsUint8_t    ir_cut_filter;
    vcsUint8_t    display_type;
    vcsUint8_t    unused[4];
} vcsfw_cpid_attributes_t;


/* VCSFW_IOTA_ITYPE_CONFIG_PSELECT */
/*
 * This tag contains configuration settings for the Partial Scan
 * Frame Selection algorithm..
 */
typedef struct VCS_PACKED vcsfw_config_tag_pselect_s{
    vcsUint8_t  diff_thresh;
    vcsUint8_t  cnt_thresh;
    vcsUint8_t  delay_interval_msec;
    vcsUint8_t  frame_avg;
    vcsUint8_t  pscan_col_size;
    vcsUint8_t  pscan_row_size;
    vcsUint8_t  state_check_delay_msec;
    vcsUint8_t  unused;
} vcsfw_config_tag_pselect_t;

/* VCSFW_IOTA_ITYPE_CONFIG_FRAME_AVG*/
/*
 * This tag contains configuration settings for the frame averaging algorithm..
 */
typedef struct VCS_PACKED vcsfw_config_tag_frame_avg_s{
    vcsUint8_t  frame_avg;
    vcsUint8_t  unused[3];
} vcsfw_config_tag_frame_avg_t;


/* VCSFW_IOTA_ITYPE_CONFIG_WOF_THRESHOLDS */
/*
 * This iota contains values determined at test time for the firmware to use
 * to derive FINGER_THD_H, FINGER_THD_L, (from the signal field) and
 * FINGER_THD_L_HYST (from the hyst field) as labled in the Denali
 * Calibration Proposal document.  The reduction field allows for a certain
 * finger coverage to be enforced.  The reduction is treated as a fraction,
 * like the fractional bits of a fixed point number.  i.e.:
         *  Reduction   |   Effect
         *    0x8000    |     x 1/2
         *    0x4000    |     x 1/4
         *    0x1000    |     x 1/16
         *    0x5000    |     x 5/16
 * If the reduction is not specified, the firmware defaults to 50%.  A special
 * case of 0 implies no reduction is applied.
 * The calculations on the WOF thresholds are as follows:
 *  FINGER_THD_L = BASE_THD - signal*coverage
 *  FINGER_THD_L_HYST = FINGER_THD_L + hyst
 *  FINGER_THD_H = BASE_THD + signal*coverage
 */
typedef struct VCS_PACKED vcsfw_config_wof_thresholds_s {
    vcsUint32_t      signal;
    vcsUint32_t      hyst;
    vcsUint16_t      reduction;
    vcsUint16_t      unused;
} vcsfw_config_wof_thresholds_t;


/* VCSFW_IOTA_ITYPE_CONFIG_BL_MGT */
/*
 * This iota contains configuration settings for the dynamic baseline
 * management module
 * period_MS                How often to check for baseline drift
 * partial_scan_treshold    Threshold for detecting drift in the pscan image
 * pos_threshold            Full image pixels that exceed this threshold are
 *                          adjusted downward by this amount.
 * neg_threshold            Full image pixels that are beneath this threshold
 *                          are adjusted upward by this amount.
 * max_positive             If any pixel exceeds this amount in the baseline
 *                          it is counted as a bad pixed for min_rezero_pixel
 *                          check
 * min_negative             If any pixel is less than this amount in the
 *                          baseline it is counted as a bad pixed for
 *                          min_rezero_pixel check
 * partial_scan_steps       How many rows of the drive memory to run for the
 *                          partial image.
 * enable_mode              disable DBM or enable with re-zero options
 *
 * min_rezero_pixels        Minimum number of total pixels exceeding rezero
 *                          thresholds before triggering a rezero
 */

typedef struct VCS_PACKED vcsfw_config_bl_mgt_s{
    vcsUint32_t            period_MS;
    vcsUint16_t            partial_scan_threshold;
    vcsInt16_t             pos_threshold;
    vcsInt16_t             neg_threshold;
    vcsInt16_t             max_positive;
    vcsInt16_t             min_negative;
    vcsUint16_t            partial_scan_steps;
    vcsUint8_t             enable_mode;
    vcsUint8_t             unused;
    vcsUint16_t            min_rezero_pixels;
#define VCSFW_BL_MGT_ENABLE_MODE_OFF                      0
#define VCSFW_BL_MGT_ENABLE_MODE_ON_WITH_FULL_REZERO      1
#define VCSFW_BL_MGT_ENABLE_MODE_ON_WITH_FW_BL_REZERO     2
} vcsfw_config_bl_mgt_t;


/*
 * VCSFW_IOTA_ITYPE_CAL_REFERENCE
 * VCSFW_IOTA_ITYPE_CPID_CAL_LONG_INTEGRATION

 * These iotas contains the reference image generated from the cal.
 * It starts with the image header as defined below, followed by
 * the image data.
 */
typedef struct VCS_PACKED vcsfw_cal_image_header_s {
    vcsUint16_t      npixels;       /* number of pixels in a row */
    vcsUint16_t      nlines;        /* number of rows */
    vcsUint16_t      offset;        /* offset in dwords */
    vcsUint8_t       bitdepth;      /* bit-depth: 8,12,16 */
    vcsUint8_t       dpi;           /* DPI: 1 - 500dpi, 2 - 1000dpi */
} vcsfw_cal_image_header_t;

/*
 * The vcsfw_cal_image_mean_and_bad_pix_header_t is the data header for
 * VCSFW_IOTA_ITYPE_CPID_CAL_MEAN_BGD_BAD_PIXELS iota.
*/
typedef struct VCS_PACKED vcsfw_cal_image_mean_and_bad_pix_header_s {
    vcsUint32_t      compressedSize;
    vcsUint16_t      offset;        /* offset in dwords */
    vcsUint16_t      adc_offset;    /* Offset to be added to the live image during pre-processing*/
    vcsUint16_t      npixels;       /* number of pixels in a row */
    vcsUint16_t      nlines;        /* number of rows */
    vcsUint8_t       bitdepth;      /* bit-depth: 8,12,16 */
    vcsUint8_t       dpi;           /* DPI: 1 - 500dpi, 2 - 1000dpi */
    vcsUint8_t       dummy1;
    vcsUint8_t       dummy2;
} vcsfw_cal_image_mean_and_bad_pix_header_t;


/*
 * VCSFW_IOTA_ITYPE_CPID_CAL_DARK_RATE_MAP_1000DPI

 * This iota corresponds to the CPID dark rate map

 * It starts with the image header as defined below, followed by
 * the 1000 DPI, 12-bpp image data.
 */
typedef struct VCS_PACKED vcsfw_cal_dark_rate_map_image_header_s {
    vcsUint32_t      stdDeviationOfFirstRowOfD1; /* Standard Deviation  Dark rate map
                                                                    MT will get two dark current images at high (D2, 1000 DPI) and low integration (D1, 1000 DPI) times
                                                                    and subtract the low from the high, Dark rate = D2 - D1.
                                                                    Then MT via the SDK provided DLL will find standard deviation of the first row ignoring bad pixels from the first row.
                                                                    Then MT via the SDK provided DLL will use standard deviation to estimate temperature (T1) and write this T1 to flash.
                                                                    */
    vcsUint16_t      offset;        /* offset in dwords */

    vcsUint16_t      darkRateMapMultX10;

    vcsUint16_t      npixels;       /* number of pixels in a row */
    vcsUint16_t      nlines;        /* number of rows */
    vcsUint8_t       bitdepth;      /* bit-depth: 8,12,16. Choose 12 here */
    vcsUint8_t       dpi;           /* DPI: 1 - 500 DPI, 2 - 1000 DPI. Choose 2 here as it is 1000 DPI image*/
    vcsUint8_t       unused[2];
} vcsfw_cal_dark_rate_map_image_header_t;

typedef struct VCS_PACKED vcsfw_cal_dark_rate_map_image_header_cal_5_s {
    vcsUint32_t      compressedSize;
    vcsInt32_t       temperature_std_dev;
    vcsUint16_t      offset;        /* offset in dwords */
    vcsUint16_t      npixels;       /* number of pixels in a row */
    vcsUint16_t      nlines;        /* number of rows */
    vcsUint8_t       bitdepth;      /* bit-depth: 8,12,16. Choose 12 here */
    vcsUint8_t       dpi;           /* DPI: 1 - 500 DPI, 2 - 1000 DPI. Choose 2 here as it is 1000 DPI image*/
} vcsfw_cal_dark_rate_map_image_header_cal_5_t;



/* VCSFW_IOTA_ITYPE_CONFIG_VERSION */
/*
 * This iota contains the configuration id and version.
 */
typedef struct VCS_PACKED vcsfw_config_version_s{
    vcsUint32_t      config_id1;    /* YYMMDD */
    vcsUint32_t      config_id2;    /* HHMMSS */
    vcsUint16_t      version;
    vcsUint16_t      unused[3];
} vcsfw_config_version_t;

/* VCSFW_IOTA_ITYPE_CONFIG_NAV_SWIPE */
/*
 * This iota contains values that are used to tune the swipe algorithm in the
 * navigation code
 */
typedef struct VCS_PACKED vcsfw_config_nav_swipe_s {
    vcsUint32_t      nav_mode;           /* see NAV_SWIPE_MODE definitions below */

    /* parameters for horizontal swipe detection */
    vcsUint8_t       h_regions;         /* number of rcvr or xmtr regions     */
    vcsUint8_t       h_flags;           /* see NAV_SWIPE_FLAGS below          */
    vcsUint16_t      h_req_dist_posdir; /* minimum distance the finger must   */
    vcsUint16_t      h_req_dist_negdir; /*   traverse before it's declared a  */
                                        /*   swipe. This is a 16-bit fixed    */
                                        /*   point number in 8Q8 with the     */
                                        /*   units of regions                 */
    vcsUint16_t      h_min_exit_pos;
    vcsUint16_t      h_max_exit_pos;
    vcsUint16_t      h_min_vel;         /* minimum allowed finger velocity    */
                                        /*   for a swipe                      */
    vcsUint16_t      h_threshold;       /* finger detection threshold         */
    vcsUint8_t       h_xstride;         /* stride used for indexing into the  */
    vcsUint8_t       h_ystride;         /*   2D frame                         */

    /* parameters for vertical swipe detection */
    vcsUint8_t       v_regions;
    vcsUint8_t       v_flags;
    vcsUint16_t      v_req_dist_posdir;
    vcsUint16_t      v_req_dist_negdir;
    vcsUint16_t      v_min_exit_pos;
    vcsUint16_t      v_max_exit_pos;
    vcsUint16_t      v_min_vel;
    vcsUint16_t      v_threshold;
    vcsUint8_t       v_xstride;
    vcsUint8_t       v_ystride;
} vcsfw_config_nav_swipe_t;

/* NAV_SWIPE_MODE */
#define NAV_SWIPE_MODE_BL_REZERO     1
#define NAV_SWIPE_MODE_BL_RELAX      2

/* NAV_SWIPE_FLAGS */
#define NAV_SWIPE_FLAGS_AXIS_METADJ   0x02  /* apply the MATLAB metric
                                             * adjust algorithm */

/* VCSFW_IOTA_ITYPE_CONFIG_NAV_TAP */
/*
 * This iota contains values that are used to tune the tap algorithm in the
 * navigation code. All time values are in units of 10us (e.g. 50000 = 500ms)
 */
typedef struct VCS_PACKED vcsfw_config_nav_tap_s {
    vcsUint32_t      quiescent_time;  /* minimum time between tap gestures    */
    vcsUint32_t      min_tap_time;    /* tap time - single taps or the second */
    vcsUint32_t      max_tap_time;    /*     tap in a double tap              */
    vcsUint32_t      min_gap_time;    /* gap time - time between taps in a    */
    vcsUint32_t      max_gap_time;    /*     double tap                       */
    vcsUint32_t      min_press_time;  /* press time - long press time         */
    vcsUint32_t      max_press_time;
} vcsfw_config_nav_tap_t;


typedef struct VCS_PACKED vcsfw_fppresent_params_s {
    vcsUint32_t variance_thresh;
    vcsUint16_t coverage_thresh;
    vcsUint16_t unused;
    vcsUint16_t blocksizex;
    vcsUint16_t blocksizey;
    vcsUint16_t marginx;
    vcsUint16_t marginy;
} vcsfw_fppresent_params_t;


#define    VCSFW_TEST_HISTORY_IOTA_PART_NUM_STRING_LEN    20

typedef struct VCS_PACKED vcsfw_config_testhistory_s {
    vcsUint32_t date;       /* seconds since 1/1/2000 */
    vcsUint16_t stage;      /* For example: 1=CP1, 2=CP2, 3=FT, 4=MT, 5=IST.*/
    vcsUint16_t error_code; /* 0 == pass */
    /* MT core api part number (null-term string) */
    vcsUint8_t  part_MT[VCSFW_TEST_HISTORY_IOTA_PART_NUM_STRING_LEN];
    /* MT config file part number (null-term string) */
    vcsUint8_t  part_config[VCSFW_TEST_HISTORY_IOTA_PART_NUM_STRING_LEN];
} vcsfw_config_testhistory_t;


/* The FOREGROUND_IMAGE iota contains a header vcsfw_config_foreground_img_t
 * header, and nBytes worth of foreground image data.  This iota is not parsed
 * by firmware, and is used only to pass data calibrated at test time to the host
 * software.
 */
typedef struct VCS_PACKED vcsfw_config_foreground_img_s{
    vcsUint32_t nBytes;     /* total number of bytes in the image (nRows*nCols*bytes/pixel) */
    vcsUint16_t nRows;
    vcsUint16_t nCols;
    vcsUint16_t flags;
    vcsUint16_t unused;
} vcsfw_config_foreground_img_t;

/* The INSTSPEC flag is equivalent to the INSTSPEC flag defined for
 * frame-tags, which indicates that this data is specific to each sensor
 * instance (i.e.: it is calibrated for this sensor only).
 */
#define VCSFW_CONFIG_FOREGROUND_IMAGE_FLAG_INSTSPEC     0x20


/* The MISSION_SHA256 iota is simply a 256-bit number, and thus, 8 words. */
typedef struct VCS_PACKED vcsfw_mission_sha256_s{
    vcsUint32_t sha256 [8];     /* SHA256 */
} vcsfw_mission_sha256_t;

#include "vcsPopPack.h"

#endif /* !__VCSFW_H */
